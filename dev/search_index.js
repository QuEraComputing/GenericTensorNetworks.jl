var documenterSearchIndex = {"docs":
[{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"EditURL = \"https://github.com/QuEraComputing/GenericTensorNetworks.jl/blob/master/examples/IndependentSet.jl\"","category":"page"},{"location":"generated/IndependentSet/#Independent-set-problem","page":"Independent set problem","title":"Independent set problem","text":"","category":"section"},{"location":"generated/IndependentSet/#Problem-definition","page":"Independent set problem","title":"Problem definition","text":"","category":"section"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"In graph theory, an independent set is a set of vertices in a graph, no two of which are adjacent.","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"In the following, we are going to solve the solution space properties of the independent set problem on the Petersen graph. To start, let us define a Petersen graph instance.","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"using GenericTensorNetworks, Graphs\n\ngraph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"We can visualize this graph using the show_graph function","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"# set the vertex locations manually instead of using the default spring layout\nrot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\n\nlocations = [[rot15(0.0, 1.0, i) for i=0:4]..., [rot15(0.0, 0.6, i) for i=0:4]...]\n\nshow_graph(graph; locs=locations)","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"The graphical display is available in the following editors","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"a VSCode editor,\na Jupyter notebook,\nor a Pluto notebook,","category":"page"},{"location":"generated/IndependentSet/#Generic-tensor-network-representation","page":"Independent set problem","title":"Generic tensor network representation","text":"","category":"section"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"The generic tensor network representation of the independent set problem can be constructed with IndependentSet.","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"problem = IndependentSet(graph; optimizer=TreeSA());\nnothing #hide","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"Here, the key word argument optimizer specifies the tensor network contraction order optimizer as a local search based optimizer TreeSA. The resulting contraction order optimized tensor network is contained in the code field of problem.","category":"page"},{"location":"generated/IndependentSet/#Theory-(can-skip)","page":"Independent set problem","title":"Theory (can skip)","text":"","category":"section"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"Let G=(V E) be a graph with each vertex vin V associated with a weight w_v. To reduce the independent set problem on it to a tensor network contraction, we first map a vertex vin V to a label s_v in 0 1 of dimension 2, where we use 0 (1) to denote a vertex absent (present) in the set. For each vertex v, we defined a parameterized rank-one tensor indexed by s_v as","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"W(x_v^w_v) = left(beginmatrix\n    1 \n    x_v^w_v\n    endmatrixright)","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"where x_v is a variable associated with v. Similarly, for each edge (u v) in E, we define a matrix B indexed by s_u and s_v as","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"B = left(beginmatrix\n1   1\n1  0\nendmatrixright)","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"Ideally, an optimal contraction order has a space complexity 2^rm tw(G), where rm tw(G) is the tree-width of G (or graph in the code). We can check the time, space and read-write complexities by typing","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"timespacereadwrite_complexity(problem)","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"The three return values are log2 values of the the number of element-wise multiplication operations, the number elements in the largest tensor during contraction and the number of tensor element read-write operations. For more information about how to improve the contraction order, please check the Performance Tips.","category":"page"},{"location":"generated/IndependentSet/#Solution-space-properties","page":"Independent set problem","title":"Solution space properties","text":"","category":"section"},{"location":"generated/IndependentSet/#Maximum-independent-set-size-\\alpha(G)","page":"Independent set problem","title":"Maximum independent set size alpha(G)","text":"","category":"section"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"We can compute solution space properties with the solve function, which takes two positional arguments, the problem instance and the wanted property.","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"maximum_independent_set_size = solve(problem, SizeMax())[]","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"Here SizeMax means finding the solution with maximum set size. The return value has Tropical type. We can get its content by typing","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"maximum_independent_set_size.n","category":"page"},{"location":"generated/IndependentSet/#Counting-properties","page":"Independent set problem","title":"Counting properties","text":"","category":"section"},{"location":"generated/IndependentSet/#Count-all-solutions-and-best-several-solutions","page":"Independent set problem","title":"Count all solutions and best several solutions","text":"","category":"section"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"We can count all independent sets with the CountingAll property.","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"count_all_independent_sets = solve(problem, CountingAll())[]","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"The return value has type Float64.","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"We can count the maximum independent sets with CountingMax.","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"count_maximum_independent_sets = solve(problem, CountingMax())[]","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"The return value has type CountingTropical, which contains two fields. They are n being the maximum independent set size and c being the number of the maximum independent sets.","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"count_maximum_independent_sets.c","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"Similarly, we can count independent sets of sizes alpha(G) and alpha(G)-1 by feeding an integer positional argument to CountingMax.","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"count_max2_independent_sets = solve(problem, CountingMax(2))[]","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"The return value has type TruncatedPoly, which contains two fields. They are maxorder being the maximum independent set size and coeffs being the number of independent sets having sizes alpha(G)-1 and alpha(G).","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"count_max2_independent_sets.coeffs","category":"page"},{"location":"generated/IndependentSet/#Find-the-graph-polynomial","page":"Independent set problem","title":"Find the graph polynomial","text":"","category":"section"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"We can count the number of independent sets at any size, which is equivalent to finding the coefficients of an independence polynomial that defined as","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"I(G x) = sum_k=0^alpha(G) a_k x^k","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"where alpha(G) is the maximum independent set size, a_k is the number of independent sets of size k. The total number of independent sets is thus equal to I(G 1). There are 3 methods to compute a graph polynomial, :finitefield, :fft and :polynomial. These methods are introduced in the docstring of GraphPolynomial.","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"independence_polynomial = solve(problem, GraphPolynomial(; method=:finitefield))[]","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"The return type is Polynomial.","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"independence_polynomial.coeffs","category":"page"},{"location":"generated/IndependentSet/#Configuration-properties","page":"Independent set problem","title":"Configuration properties","text":"","category":"section"},{"location":"generated/IndependentSet/#Find-one-best-solution","page":"Independent set problem","title":"Find one best solution","text":"","category":"section"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"We can use the bounded or unbounded SingleConfigMax to find one of the solutions with largest size. The unbounded (default) version uses a joint type of CountingTropical and ConfigSampler in computation, where CountingTropical finds the maximum size and ConfigSampler samples one of the best solutions. The bounded version uses the binary gradient back-propagation (see our paper) to compute the gradients. It requires caching intermediate states, but is often faster (on CPU) because it can use TropicalGEMM (see Performance Tips).","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"max_config = solve(problem, SingleConfigMax(; bounded=false))[]","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"The return value has type CountingTropical with its counting field having ConfigSampler type. The data field of ConfigSampler is a bit string that corresponds to the solution","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"single_solution = max_config.c.data","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"This bit string should be read from left to right, with the i-th bit being 1 (0) to indicate the i-th vertex is present (absent) in the set. We can visualize this MIS with the following function.","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"show_graph(graph; locs=locations, vertex_colors=\n    [iszero(single_solution[i]) ? \"white\" : \"red\" for i=1:nv(graph)])","category":"page"},{"location":"generated/IndependentSet/#Enumerate-all-solutions-and-best-several-solutions","page":"Independent set problem","title":"Enumerate all solutions and best several solutions","text":"","category":"section"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"We can use bounded or unbounded ConfigsMax to find all solutions with largest-K set sizes. In most cases, the bounded (default) version is preferred because it can reduce the memory usage significantly.","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"all_max_configs = solve(problem, ConfigsMax(; bounded=true))[]","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"The return value has type CountingTropical, while its counting field having type ConfigEnumerator. The data field of a ConfigEnumerator instance contains a vector of bit strings.","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"all_max_configs.c.data","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"These solutions can be visualized with the show_gallery function.","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"show_gallery(graph, (1, length(all_max_configs.c)); locs=locations, vertex_configs=all_max_configs.c);\nnothing #hide","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"We can use ConfigsAll to enumerate all sets satisfying the independence constraint.","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"all_independent_sets = solve(problem, ConfigsAll())[]","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"The return value has type ConfigEnumerator.","category":"page"},{"location":"generated/IndependentSet/#Sample-solutions","page":"Independent set problem","title":"Sample solutions","text":"","category":"section"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"It is often difficult to store all configurations in a vector. A more clever way to store the data is using the sum product tree format.","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"all_independent_sets_tree = solve(problem, ConfigsAll(; tree_storage=true))[]","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"The return value has the SumProductTree type. Its length corresponds to the number of configurations.","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"length(all_independent_sets_tree)","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"We can use Base.collect function to create a ConfigEnumerator or use generate_samples to generate samples from it.","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"collect(all_independent_sets_tree)\n\ngenerate_samples(all_independent_sets_tree, 10)","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"EditURL = \"https://github.com/QuEraComputing/GenericTensorNetworks.jl/blob/master/examples/PaintShop.jl\"","category":"page"},{"location":"generated/PaintShop/#Binary-paint-shop-problem","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"","category":"section"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"note: Note\nIt is highly recommended to read the Independent set problem chapter before reading this one.","category":"page"},{"location":"generated/PaintShop/#Problem-Definition","page":"Binary paint shop problem","title":"Problem Definition","text":"","category":"section"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"The binary paint shop problem is defined as follows: we are given a 2m length sequence containing m cars, where each car appears twice. Each car need to be colored red in one occurrence, and blue in the other. We need to choose which occurrence for each car to color with which color — the goal is to minimize the number of times we need to change the current color.","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"In the following, we use a character to represent a car, and defined a binary paint shop problem as a string that each character appear exactly twice.","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"using GenericTensorNetworks, Graphs\n\nsequence = collect(\"iadgbeadfcchghebif\")","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"We can visualize this paint shop problem as a graph","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"rot(a, b, θ) = cos(θ)*a + sin(θ)*b, cos(θ)*b - sin(θ)*a\n\nlocations = [rot(0.0, 1.0, -0.25π - 1.5*π*(i-0.5)/length(sequence)) for i=1:length(sequence)]\n\ngraph = path_graph(length(sequence))\nfor i=1:length(sequence)\n    j = findlast(==(sequence[i]), sequence)\n    i != j && add_edge!(graph, i, j)\nend\n\nshow_graph(graph; locs=locations, texts=string.(sequence), edge_colors=\n    [sequence[e.src] == sequence[e.dst] ? \"blue\" : \"black\" for e in edges(graph)])","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"Vertices connected by blue edges must have different colors, and the goal becomes a min-cut problem defined on black edges.","category":"page"},{"location":"generated/PaintShop/#Generic-tensor-network-representation","page":"Binary paint shop problem","title":"Generic tensor network representation","text":"","category":"section"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"Let us construct the problem instance as bellow.","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"problem = PaintShop(sequence);\nnothing #hide","category":"page"},{"location":"generated/PaintShop/#Theory-(can-skip)","page":"Binary paint shop problem","title":"Theory (can skip)","text":"","category":"section"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"Type PaintShop can be used for constructing the tensor network with optimized contraction order for solving a binary paint shop problem. To obtain its tensor network representation, we associating car c_i (the i-th character in our example) with a degree of freedom s_c_i in 0 1, where we use 0 to denote the first appearance of a car is colored red and 1 to denote the first appearance of a car is colored blue. For each black edges (i i+1), we define an edge tensor labeled by (s_c_i s_c_i+1) as follows: If both cars on this edge are their first or second appearance","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"B^rm parallel = left(beginmatrix\nx  1 \n1  x \nendmatrixright)","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"otherwise,","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"B^rm anti-parallel = left(beginmatrix\n1  x \nx  1 \nendmatrixright)","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"It can be understood as, when both cars are their first appearance, they tend to have the same configuration so that the color is not changed. Otherwise, they tend to have different configuration to keep the color unchanged.","category":"page"},{"location":"generated/PaintShop/#Counting-properties","page":"Binary paint shop problem","title":"Counting properties","text":"","category":"section"},{"location":"generated/PaintShop/#graph-polynomial","page":"Binary paint shop problem","title":"graph polynomial","text":"","category":"section"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"The graph polynomial defined for the maximal independent set problem is","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"I_rm max(G x) = sum_k=0^alpha(G) b_k x^k","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"where b_k is the number of maximal independent sets of size k in graph G=(V E).","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"max_config = solve(problem, GraphPolynomial())[]","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"Since it only counts the maximal independent sets, the first several coefficients are 0.","category":"page"},{"location":"generated/PaintShop/#Counting-properties-2","page":"Binary paint shop problem","title":"Counting properties","text":"","category":"section"},{"location":"generated/PaintShop/#graph-polynomial-2","page":"Binary paint shop problem","title":"graph polynomial","text":"","category":"section"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"The graph polynomial of the binary paint shop problem in our convention is defined as","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"P(G x) = sum_k=0^delta(G) p_k x^k","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"where p_k is the number of possible coloring with number of color changes 2m-1-k.","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"paint_polynomial = solve(problem, GraphPolynomial())[]","category":"page"},{"location":"generated/PaintShop/#Configuration-properties","page":"Binary paint shop problem","title":"Configuration properties","text":"","category":"section"},{"location":"generated/PaintShop/#finding-best-solutions","page":"Binary paint shop problem","title":"finding best solutions","text":"","category":"section"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"best_configs = solve(problem, ConfigsMin())[]","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"One can see to identical bitstrings corresponding two different vertex configurations, they are related to bit-flip symmetry.","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"painting1 = paint_shop_coloring_from_config(problem, best_configs.c.data[1])\n\nshow_graph(graph; locs=locations, texts=string.(sequence),\n    edge_colors=[sequence[e.src] == sequence[e.dst] ? \"blue\" : \"black\" for e in edges(graph)],\n    vertex_colors=[isone(c) ? \"red\" : \"black\" for c in painting1], vertex_text_color=\"white\")","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"Since we have different choices of initial color, the number of best solution is 2.","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"The following function will check the solution and return you the number of color switches","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"num_paint_shop_color_switch(sequence, painting1)","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"sumproduct/#Sum-product-representation-for-configurations","page":"Sum product tree representation","title":"Sum product representation for configurations","text":"","category":"section"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"SumProductTree can use polynomial memory to store exponential number of configurations. It is a sum-product expression tree to store ConfigEnumerator in a lazy style, where configurations can be extracted by depth first searching the tree with the Base.collect method. Although it is space efficient, it is in general not easy to extract information from it due to the exponential large configuration space. Directed sampling is one of its most important operations, with which one can get some statistic properties from it with an intermediate effort. For example, if we want to check some property of an intermediate scale graph, one can type","category":"page"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"julia> graph = random_regular_graph(70, 3)\n\njulia> problem = IndependentSet(graph; optimizer=TreeSA());\n\njulia> tree = solve(problem, ConfigsAll(; tree_storage=true))[];\n16633909006371","category":"page"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"If one wants to store these configurations, he will need a hard disk of size 256 TB! However, this sum-product binary tree structure supports efficient and unbiased direct sampling.","category":"page"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"samples = generate_samples(tree, 1000);","category":"page"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"With these samples, one can already compute useful properties like Hamming distance (see hamming_distribution) distribution.","category":"page"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"julia> using UnicodePlots\n\njulia> lineplot(hamming_distribution(samples, samples))\n          ┌────────────────────────────────────────┐ \n   100000 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⠹⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n          │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡎⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n          │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡇⠀⢣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n          │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n          │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠸⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n          │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n          │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n          │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⠃⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n          │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n          │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡞⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n          │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n          │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⠁⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n          │⠀⠀⠀⠀⠀⠀⠀⠀⠀⡼⠀⠀⠀⠀⠀⠀⠈⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n          │⠀⠀⠀⠀⠀⠀⠀⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⢳⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│ \n        0 │⢀⣀⣀⣀⣀⣀⣀⣀⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠓⢄⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⠀⠀⠀⠀│ \n          └────────────────────────────────────────┘ \n          ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀80⠀ ","category":"page"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"Here, the x-axis is the Hamming distance and the y-axis is the counting of pair-wise Hamming distances.","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"EditURL = \"https://github.com/QuEraComputing/GenericTensorNetworks.jl/blob/master/examples/Coloring.jl\"","category":"page"},{"location":"generated/Coloring/#Coloring-problem","page":"Coloring problem","title":"Coloring problem","text":"","category":"section"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"note: Note\nIt is highly recommended to read the Independent set problem chapter before reading this one.","category":"page"},{"location":"generated/Coloring/#Problem-definition","page":"Coloring problem","title":"Problem definition","text":"","category":"section"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"A vertex coloring is an assignment of labels or colors to each vertex of a graph such that no edge connects two identically colored vertices. In the following, we are going to defined a 3-coloring problem for the Petersen graph.","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"using GenericTensorNetworks, Graphs\n\ngraph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"We can visualize this graph using the following function","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\n\nlocations = [[rot15(0.0, 1.0, i) for i=0:4]..., [rot15(0.0, 0.6, i) for i=0:4]...]\n\nshow_graph(graph; locs=locations)","category":"page"},{"location":"generated/Coloring/#Generic-tensor-network-representation","page":"Coloring problem","title":"Generic tensor network representation","text":"","category":"section"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"We construct the tensor network for the 3-coloring problem as","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"problem = Coloring{3}(graph);\nnothing #hide","category":"page"},{"location":"generated/Coloring/#Theory-(can-skip)","page":"Coloring problem","title":"Theory (can skip)","text":"","category":"section"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"Type Coloring can be used for constructing the tensor network with optimized contraction order for a coloring problem. Let us use 3-coloring problem defined on vertices as an example. For a vertex v, we define the degrees of freedom c_vin123 and a vertex tensor labelled by it as","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"W(v) = left(beginmatrix\n    1\n    1\n    1\nendmatrixright)","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"For an edge (u v), we define an edge tensor as a matrix labelled by (c_u c_v) to specify the constraint","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"B = left(beginmatrix\n    1  x  x\n    x  1  x\n    x  x  1\nendmatrixright)","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"The number of possible coloring can be obtained by contracting this tensor network by setting vertex tensor elements r_v g_v and b_v to 1.","category":"page"},{"location":"generated/Coloring/#Solving-properties","page":"Coloring problem","title":"Solving properties","text":"","category":"section"},{"location":"generated/Coloring/#counting-all-possible-coloring","page":"Coloring problem","title":"counting all possible coloring","text":"","category":"section"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"num_of_coloring = solve(problem, CountingMax())[]","category":"page"},{"location":"generated/Coloring/#finding-one-best-coloring","page":"Coloring problem","title":"finding one best coloring","text":"","category":"section"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"single_solution = solve(problem, SingleConfigMax())[]\n\nis_vertex_coloring(graph, single_solution.c.data)\n\nvertex_color_map = Dict(0=>\"red\", 1=>\"green\", 2=>\"blue\")\n\nshow_graph(graph; locs=locations, vertex_colors=[vertex_color_map[Int(c)]\n     for c in single_solution.c.data])","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"Let us try to solve the same issue on its line graph, a graph that generated by mapping an edge to a vertex and two edges sharing a common vertex will be connected.","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"linegraph = line_graph(graph)\n\nshow_graph(linegraph; locs=[0.5 .* (locations[e.src] .+ locations[e.dst])\n     for e in edges(graph)])","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"Let us construct the tensor network and see if there are solutions.","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"lineproblem = Coloring{3}(linegraph);\n\nnum_of_coloring = solve(lineproblem, CountingMax())[]","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"You will see the maximum size 28 is smaller than the number of edges in the linegraph, meaning no solution for the 3-coloring on edges of a Petersen graph.","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"EditURL = \"https://github.com/QuEraComputing/GenericTensorNetworks.jl/blob/master/examples/SetPacking.jl\"","category":"page"},{"location":"generated/SetPacking/#Set-packing-problem","page":"Set packing problem","title":"Set packing problem","text":"","category":"section"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"note: Note\nIt is highly recommended to read the Independent set problem chapter before reading this one.","category":"page"},{"location":"generated/SetPacking/#Problem-definition","page":"Set packing problem","title":"Problem definition","text":"","category":"section"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"The set packing problem is generalization of the IndependentSet problem from the simple graph to the multigraph. Suppose one has a finite set S and a list of subsets of S. Then, the set packing problem asks if some k subsets in the list are pairwise disjoint. In the following, we will find the solution space properties for the set in the Set covering problem.","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"using GenericTensorNetworks, Graphs","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"The packing stadium areas of cameras are represented as the following sets.","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"sets = [[1,3,4,6,7], [4,7,8,12], [2,5,9,11,13],\n    [1,2,14,15], [3,6,10,12,14], [8,14,15],\n    [1,2,6,11], [1,2,4,6,8,12]]","category":"page"},{"location":"generated/SetPacking/#Generic-tensor-network-representation","page":"Set packing problem","title":"Generic tensor network representation","text":"","category":"section"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"We create a [SetPacking] instance that contains a generic tensor network as its code field.","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"problem = SetPacking(sets);\nnothing #hide","category":"page"},{"location":"generated/SetPacking/#Theory-(can-skip)","page":"Set packing problem","title":"Theory (can skip)","text":"","category":"section"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"Let S be the target set packing problem that we want to solve. For each set s in S, we associate it with a weight w_s to it. The tensor network representation map a set sin S to a boolean degree of freedom v_sin0 1. For each set s, we defined a parameterized rank-one tensor indexed by v_s as","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"W(x_s^w_s) = left(beginmatrix\n    1 \n    x_s^w_s\n    endmatrixright)","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"where x_s is a variable associated with s. For each unique element a, we defined the constraint over all sets containing it N(a) = s  s in S land ain s:","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"B_s_1s_2ldotss_N(a) = begincases\n    0  s_1+s_2+ldots+s_N(a)  1\n    1  textotherwise\nendcases","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"This tensor means if in a configuration, two sets contain the element a, then this configuration is forbidden, One can check the contraction time space complexity of a SetPacking instance by typing:","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"timespacereadwrite_complexity(problem)","category":"page"},{"location":"generated/SetPacking/#Solving-properties","page":"Set packing problem","title":"Solving properties","text":"","category":"section"},{"location":"generated/SetPacking/#Counting-properties","page":"Set packing problem","title":"Counting properties","text":"","category":"section"},{"location":"generated/SetPacking/#The-\"graph\"-polynomial","page":"Set packing problem","title":"The \"graph\" polynomial","text":"","category":"section"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"The graph polynomial for the set packing problem is defined as","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"P(S x) = sum_k=0^alpha(S) c_k x^k","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"where c_k is the number of configurations having k sets, and alpha(S) is the maximum size of the packing.","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"packing_polynomial = solve(problem, GraphPolynomial())[]","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"The maximum number of sets that packing the set of elements can be computed with the SizeMax property:","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"max_packing_size = solve(problem, SizeMax())[]","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"Similarly, we have its counting CountingMax:","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"counting_maximum_set_packing = solve(problem, CountingMax())[]","category":"page"},{"location":"generated/SetPacking/#Configuration-properties","page":"Set packing problem","title":"Configuration properties","text":"","category":"section"},{"location":"generated/SetPacking/#Finding-maximum-set-packing","page":"Set packing problem","title":"Finding maximum set packing","text":"","category":"section"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"One can enumerate all maximum set packing with the ConfigsMax property in the program.","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"max_configs = solve(problem, ConfigsMax())[].c","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"Hence the only optimal solution is z_1 z_3 z_6 that has size 3. The correctness of this result can be checked with the is_set_packing function.","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"all(c->is_set_packing(sets, c), max_configs)","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"Similarly, if one is only interested in computing one of the maximum set packing, one can use the graph property SingleConfigMax.","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"EditURL = \"https://github.com/QuEraComputing/GenericTensorNetworks.jl/blob/master/examples/open.jl\"","category":"page"},{"location":"generated/open/#Open-and-fixed-degrees-of-freedom","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"","category":"section"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"Open degrees of freedom is useful when one want to get the marginal about certain degrees of freedom. When one specifies the openvertices keyword argument in solve function as a tuple of vertices, the output will be a tensor that can be indexed by these degrees of freedom. Let us use the maximum independent set problem on Petersen graph as an example.","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"using GenericTensorNetworks, Graphs\n\ngraph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"The following code computes the MIS tropical tensor (reference to be added) with open vertices 1, 2 and 3.","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"problem = IndependentSet(graph; openvertices=[1,2,3]);\n\nmarginal = solve(problem, SizeMax())","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"The return value is a rank-3 tensor, with its elements being the MIS sizes under different configuration of open vertices. For the maximum independent set problem, this tensor is also called the MIS tropical tensor, which can be useful in the MIS tropical tensor analysis (reference to be added).","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"One can also specify the fixed degrees of freedom by providing the fixedvertices keyword argument as a Dict, which can be used to get conditioned probability. For example, we can use the following code to do the same calculation as using openvertices.","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"problem = IndependentSet(graph; fixedvertices=Dict(1=>0, 2=>0, 3=>0));\n\noutput = zeros(TropicalF64,2,2,2);\n\nmarginal_alternative = map(CartesianIndices((2,2,2))) do ci\n    problem.fixedvertices[1] = ci.I[1]-1\n    problem.fixedvertices[2] = ci.I[2]-1\n    problem.fixedvertices[3] = ci.I[3]-1\n    output[ci] = solve(problem, SizeMax())[]\nend","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"One can easily check this one also gets the correct marginal on vertices 1, 2 and 3. As a reminder, their computational hardness can be different, because the contraction order optimization program can optimize over open degrees of freedom.","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"EditURL = \"https://github.com/QuEraComputing/GenericTensorNetworks.jl/blob/master/examples/Matching.jl\"","category":"page"},{"location":"generated/Matching/#Vertex-matching-problem","page":"Vertex Matching problem","title":"Vertex matching problem","text":"","category":"section"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"note: Note\nIt is highly recommended to read the Independent set problem chapter before reading this one.","category":"page"},{"location":"generated/Matching/#Problem-definition","page":"Vertex Matching problem","title":"Problem definition","text":"","category":"section"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"A k-matching in a graph G is a set of k edges, no two of which have a vertex in common.","category":"page"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"using GenericTensorNetworks, Graphs","category":"page"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"In the following, we are going to defined a matching problem for the Petersen graph.","category":"page"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"graph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"We can visualize this graph using the following function","category":"page"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\n\nlocations = [[rot15(0.0, 1.0, i) for i=0:4]..., [rot15(0.0, 0.6, i) for i=0:4]...]\n\nshow_graph(graph; locs=locations)","category":"page"},{"location":"generated/Matching/#Generic-tensor-network-representation","page":"Vertex Matching problem","title":"Generic tensor network representation","text":"","category":"section"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"We construct the tensor network for the matching problem by typing","category":"page"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"problem = Matching(graph);\nnothing #hide","category":"page"},{"location":"generated/Matching/#Theory-(can-skip)","page":"Vertex Matching problem","title":"Theory (can skip)","text":"","category":"section"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"Type Matching can be used for constructing the tensor network with optimized contraction order for a matching problem. We map an edge (u v) in E to a label langle u vrangle in 0 1 in a tensor network, where 1 means two vertices of an edge are matched, 0 means otherwise. Then we define a tensor of rank d(v) = N(v) on vertex v such that,","category":"page"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"W_langle v n_1rangle langle v n_2 rangle ldots langle v n_d(v)rangle = begincases\n    1  sum_i=1^d(v) langle v n_i rangle leq 1\n    0  textotherwise\nendcases","category":"page"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"and a tensor of rank 1 on the bond","category":"page"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"B_langle v wrangle = begincases\n1  langle v w rangle = 0 \nx  langle v w rangle = 1\nendcases","category":"page"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"where label langle v w rangle is equivalent to langle wvrangle.","category":"page"},{"location":"generated/Matching/#Solving-properties","page":"Vertex Matching problem","title":"Solving properties","text":"","category":"section"},{"location":"generated/Matching/#Maximum-matching","page":"Vertex Matching problem","title":"Maximum matching","text":"","category":"section"},{"location":"generated/Matching/#Configuration-properties","page":"Vertex Matching problem","title":"Configuration properties","text":"","category":"section"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"max_matching = solve(problem, SizeMax())[]","category":"page"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"The largest number of matching is 5, which means we have a perfect matching (vertices are all paired).","category":"page"},{"location":"generated/Matching/#matching-polynomial","page":"Vertex Matching problem","title":"matching polynomial","text":"","category":"section"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"The graph polynomial defined for the matching problem is known as the matching polynomial. Here, we adopt the first definition in the wiki page.","category":"page"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"M(G x) = sumlimits_k=1^V2 c_k x^k","category":"page"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"where k is the number of matches, and coefficients c_k are the corresponding counting.","category":"page"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"matching_poly = solve(problem, GraphPolynomial())[]","category":"page"},{"location":"generated/Matching/#Configuration-properties-2","page":"Vertex Matching problem","title":"Configuration properties","text":"","category":"section"},{"location":"generated/Matching/#one-of-the-perfect-matches","page":"Vertex Matching problem","title":"one of the perfect matches","text":"","category":"section"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"match_config = solve(problem, SingleConfigMax())[]","category":"page"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"Let us show the result by coloring the matched edges to red","category":"page"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"show_graph(graph; locs=locations, edge_colors=\n    [isone(match_config.c.data[i]) ? \"red\" : \"black\" for i=1:ne(graph)])","category":"page"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"where we use edges with red color to related pairs of matched vertices.","category":"page"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"","category":"page"},{"location":"generated/Matching/","page":"Vertex Matching problem","title":"Vertex Matching problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"EditURL = \"https://github.com/QuEraComputing/GenericTensorNetworks.jl/blob/master/examples/Satisfiability.jl\"","category":"page"},{"location":"generated/Satisfiability/#Satisfiability-problem","page":"Satisfiability problem","title":"Satisfiability problem","text":"","category":"section"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"note: Note\nIt is highly recommended to read the Independent set problem chapter before reading this one.","category":"page"},{"location":"generated/Satisfiability/#Problem-definition","page":"Satisfiability problem","title":"Problem definition","text":"","category":"section"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"In logic and computer science, the boolean satisfiability problem is the problem of determining if there exists an interpretation that satisfies a given boolean formula. One can specify a satisfiable problem in the conjunctive normal form. In boolean logic, a formula is in conjunctive normal form (CNF) if it is a conjunction (∧) of one or more clauses, where a clause is a disjunction (∨) of literals.","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"using GenericTensorNetworks\n\n@bools a b c d e f g\n\ncnf = ∧(∨(a, b, ¬d, ¬e), ∨(¬a, d, e, ¬f), ∨(f, g), ∨(¬b, c))","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"To goal is to find an assignment to satisfy the above CNF. For a satisfiability problem at this size, we can find the following assignment to satisfy this assignment manually.","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"assignment = Dict([:a=>true, :b=>false, :c=>false, :d=>true, :e=>false, :f=>false, :g=>true])\n\nsatisfiable(cnf, assignment)","category":"page"},{"location":"generated/Satisfiability/#Generic-tensor-network-representation","page":"Satisfiability problem","title":"Generic tensor network representation","text":"","category":"section"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"If we contract this tensor network, we will get a multiplicative factor x whenever there is a clause satisfied.","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"problem = Satisfiability(cnf);\nnothing #hide","category":"page"},{"location":"generated/Satisfiability/#Theory-(can-skip)","page":"Satisfiability problem","title":"Theory (can skip)","text":"","category":"section"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"We can construct a Satisfiability problem to solve the above problem. To generate a tensor network, we map a boolean variable x and its negation neg x to a degree of freedom (label) s_x in 0 1, where 0 stands for variable x having value false while 1 stands for having value true. Then we map a clause to a tensor. For example, a clause x  y  z can be mapped to a tensor labeled by (s_x s_y s_z).","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"C = left(beginmatrix\nleft(beginmatrix\nx  x \nx  x\nendmatrixright) \nleft(beginmatrix\nx  x \n1  x\nendmatrixright)\nendmatrixright)","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"There is only one entry (s_x s_y s_z) = (1 0 1) that makes this clause unsatisfied.","category":"page"},{"location":"generated/Satisfiability/#Solving-properties","page":"Satisfiability problem","title":"Solving properties","text":"","category":"section"},{"location":"generated/Satisfiability/#Satisfiability-and-its-counting","page":"Satisfiability problem","title":"Satisfiability and its counting","text":"","category":"section"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"The size of a satisfiability problem is defined by the number of satisfiable clauses.","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"num_satisfiable = solve(problem, SizeMax())[]","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"The GraphPolynomial of a satisfiability problem counts the number of solutions that k clauses satisfied.","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"num_satisfiable_count = solve(problem, GraphPolynomial())[]","category":"page"},{"location":"generated/Satisfiability/#Find-one-of-the-solutions","page":"Satisfiability problem","title":"Find one of the solutions","text":"","category":"section"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"single_config = solve(problem, SingleConfigMax())[].c.data","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"One will see a bit vector printed. One can create an assignment and check the validity with the following statement:","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"satisfiable(cnf, Dict(zip(labels(problem), single_config)))","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"performancetips/#Performance-Tips","page":"Performance Tips","title":"Performance Tips","text":"","category":"section"},{"location":"performancetips/#Optimize-contraction-orders","page":"Performance Tips","title":"Optimize contraction orders","text":"","category":"section"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Let us use the independent set problem on 3-regular graphs as an example.","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"julia> using GenericTensorNetworks, Graphs, Random\n\njulia> graph = random_regular_graph(120, 3)\n{120, 180} undirected simple Int64 graph\n\njulia> problem = IndependentSet(graph; optimizer=TreeSA(\n    sc_target=20, sc_weight=1.0, rw_weight=3.0, ntrials=10, βs=0.01:0.1:15.0, niters=20), simplifier=MergeGreedy());","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"The IndependentSet constructor maps an independent set problem to a tensor network with optimized contraction order. The key word argument optimizer specifies the contraction order optimizer of the tensor network. Here, we choose the local search based TreeSA algorithm, which often finds the smallest time/space complexity and supports slicing. One can type ?TreeSA in a Julia REPL for more information about how to configure the hyper-parameters of the TreeSA method,  while the detailed algorithm explanation is in arXiv: 2108.05665. Alternative tensor network contraction order optimizers include","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"GreedyMethod (default, fastest in searching speed but worst in contraction complexity)\nKaHyParBipartite\nSABipartite","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"The keyword argument simplifier specifies the preprocessor to improve the searching speed of the contraction order finding. For example, the MergeGreedy() here \"contracts\" tensors greedily whenever the contraction result has a smaller space complexity. It can remove all vertex tensors (vectors) before entering the contraction order optimization algorithm.","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"The returned object problem contains a field code that specifies the tensor network with optimized contraction order. For an independent set problem, the optimal contraction time/space complexity is sim 2^rm tw(G), where rm tw(G) is the tree-width of G. One can check the time, space and read-write complexity with the timespacereadwrite_complexity function.","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"julia> timespacereadwrite_complexity(problem)\n(21.90683335864693, 17.0, 20.03588509836998)","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"The return values are log2 values of the number of multiplications, the number elements in the largest tensor during contraction and the number of read-write operations to tensor elements. In this example, the number * operations is sim 2^219, the number of read-write operations are sim 2^20, and the largest tensor size is 2^17. One can check the element size by typing","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"julia> sizeof(TropicalF64)\n8\n\njulia> sizeof(TropicalF32)\n4\n\njulia> sizeof(StaticBitVector{200,4})\n32\n\njulia> sizeof(TruncatedPoly{5,Float64,Float64})\n48","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"One can use estimate_memory to get a good estimation of peak memory in bytes. For example, to compute the graph polynomial, the peak memory can be estimated as follows.","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"julia> estimate_memory(problem, GraphPolynomial(; method=:finitefield))\n297616\n\njulia> estimate_memory(problem, GraphPolynomial(; method=:polynomial))\n71427840","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"The finite field approach only requires 298 KB memory, while using the Polynomial number type requires 71 MB memory.","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"note: Note\nThe actual run time memory can be several times larger than the size of the maximum tensor, so the estimate_memory is more accurate in estimating the peak memory.\nFor mutable element types like ConfigEnumerator, none of memory estimation functions measure the actual memory usage correctly.","category":"page"},{"location":"performancetips/#Slicing-technique","page":"Performance Tips","title":"Slicing technique","text":"","category":"section"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"For large scale applications, it is also possible to slice over certain degrees of freedom to reduce the space complexity, i.e. loop and accumulate over certain degrees of freedom so that one can have a smaller tensor network inside the loop due to the removal of these degrees of freedom. In the TreeSA optimizer, one can set nslices to a value larger than zero to turn on this feature.","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"julia> using GenericTensorNetworks, Graphs, Random\n\njulia> graph = random_regular_graph(120, 3)\n{120, 180} undirected simple Int64 graph\n\njulia> problem = IndependentSet(graph; optimizer=TreeSA(βs=0.01:0.1:25.0, ntrials=10, niters=10));\n\njulia> timespacereadwrite_complexity(problem)\n(20.856518235241687, 16.0, 18.88208476145812)\n\njulia> problem = IndependentSet(graph; optimizer=TreeSA(βs=0.01:0.1:25.0, ntrials=10, niters=10, nslices=5));\n\njulia> timespacereadwrite_complexity(problem)\n(21.134967710592804, 11.0, 19.84529401927876)","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"In the second IndependentSet constructor, we slice over 5 degrees of freedom, which can reduce the space complexity by at most 5. In this application, the slicing achieves the largest possible space complexity reduction 5, while the time and read-write complexity are only increased by less than 1, i.e. the peak memory usage is reduced by a factor 32, while the (theoretical) computing time is increased by at a factor  2.","category":"page"},{"location":"performancetips/#GEMM-for-Tropical-numbers","page":"Performance Tips","title":"GEMM for Tropical numbers","text":"","category":"section"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"One can speed up the Tropical number matrix multiplication when computing the solution space property SizeMax() by using the Tropical GEMM routines implemented in package TropicalGEMM.","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"julia> using BenchmarkTools\n\njulia> @btime solve(problem, SizeMax())\n  91.630 ms (19203 allocations: 23.72 MiB)\n0-dimensional Array{TropicalF64, 0}:\n53.0ₜ\n\njulia> using TropicalGEMM\n\njulia> @btime solve(problem, SizeMax())\n  8.960 ms (18532 allocations: 17.01 MiB)\n0-dimensional Array{TropicalF64, 0}:\n53.0ₜ","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"The TropicalGEMM package pirates the LinearAlgebra.mul! interface, hence it takes effect upon using. The above example shows more than 10x speed up on a single thread CPU, which can be even faster if the Julia multi-threading if turned on. The benchmark in the TropicalGEMM repo shows this performance is close to the theoretical optimal value.","category":"page"},{"location":"performancetips/#Multiprocessing","page":"Performance Tips","title":"Multiprocessing","text":"","category":"section"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Submodule GenericTensorNetworks.SimpleMutiprocessing provides one function GenericTensorNetworks.SimpleMultiprocessing.multiprocess_run function for simple multi-processing jobs. It is not directly related to GenericTensorNetworks, but is very convenient to have one. Suppose we want to find the independence polynomial for multiple graphs with 4 processes. We can create a file, e.g. named run.jl with the following content","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"using Distributed, GenericTensorNetworks.SimpleMultiprocessing\nusing Random, GenericTensorNetworks  # to avoid multi-precompilation\n@everywhere using Random, GenericTensorNetworks\n\nresults = multiprocess_run(collect(1:10)) do seed\n    Random.seed!(seed)\n    n = 10\n    @info \"Graph size $n x $n, seed= $seed\"\n    g = random_diagonal_coupled_graph(n, n, 0.8)\n    gp = Independence(g; optimizer=TreeSA(), simplifier=MergeGreedy())\n    res = solve(gp, GraphPolynomial())[]\n    return res\nend\n\nprintln(results)","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"One can run this script file with the following command","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"$ julia -p4 run.jl\n      From worker 3:\t[ Info: running argument 4 on device 3\n      From worker 4:\t[ Info: running argument 2 on device 4\n      From worker 5:\t[ Info: running argument 3 on device 5\n      From worker 2:\t[ Info: running argument 1 on device 2\n      From worker 3:\t[ Info: Graph size 10 x 10, seed= 4\n      From worker 4:\t[ Info: Graph size 10 x 10, seed= 2\n      From worker 5:\t[ Info: Graph size 10 x 10, seed= 3\n      From worker 2:\t[ Info: Graph size 10 x 10, seed= 1\n      From worker 4:\t[ Info: running argument 5 on device\n      ...","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"You will see a vector of polynomials printed out.","category":"page"},{"location":"performancetips/#Make-use-of-GPUs","page":"Performance Tips","title":"Make use of GPUs","text":"","category":"section"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"To upload the computation to GPU, you just add using CUDA before calling the solve function, and set the keyword argument usecuda to true.","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"julia> using CUDA\n[ Info: OMEinsum loaded the CUDA module successfully\n\njulia> solve(problem, SizeMax(), usecuda=true)\n0-dimensional CuArray{TropicalF64, 0, CUDA.Mem.DeviceBuffer}:\n53.0ₜ","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Solution space properties computable on GPU includes","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"SizeMax and SizeMin\nCountingAll\nCountingMax and CountingMin\nGraphPolynomial\nSingleConfigMax and SingleConfigMin","category":"page"},{"location":"performancetips/#Benchmarks","page":"Performance Tips","title":"Benchmarks","text":"","category":"section"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"We run a single thread benchmark on central processing units (CPU) Intel(R) Xeon(R) CPU E5-2686 v4 @ 2.30GHz, and its CUDA version on a GPU Tesla V100-SXM2 16G. The results are summarized in the following plot. The benchmark code can be found in our paper repository.","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"(Image: benchmark-independent-set) This benchmark results is for computing different solution space properties of independent sets of random three-regular graphs with different tensor element types. The time in these plots only includes tensor network contraction, without taking into account the contraction order finding and just-in-time compilation time. Legends are properties, algebra, and devices that we used in the computation; one can find the corresponding computed solution space property in Table 1 in the paper.","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"(a) time and space complexity versus the number of vertices for the benchmarked graphs.\n(b) The computation time for calculating the MIS size and for counting the number of all independent sets (ISs), the number of MISs, the number of independent sets having size alpha(G) and alpha(G)-1, and finding 100 largest set sizes.\n(c) The computation time for calculating the independence polynomials with different approaches.\n(d) The computation time for configuration enumeration, including single MIS configuration, the enumeration of all independent set configurations, all MIS configurations, all independent sets, and all independent set configurations having size alpha(G) and alpha(G)-1.","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"The graphs in all benchmarks are random three-regular graphs, which have treewidth that is asymptotically smaller than V6. In this benchmark, we do not include traditional algorithms for finding the MIS sizes such as branching or dynamic programming. To the best of our knowledge, these algorithms are not suitable for computing most of the solution space properties mentioned in this paper. The main goal of this section is to show the relative computation time for calculating different solution space properties.","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Panel (a) shows the time and space complexity of tensor network contraction for different graph sizes. The contraction order is obtained using the TreeSA algorithm that implemented in OMEinsumContractionOrders. If we assume our contraction-order finding program has found the optimal treewidth, which is very likely to be true, the space complexity is the same as the treewidth of the problem graph. Slicing technique has been used for graphs with space complexity greater than 2^27 (above the yellow dashed line) to fit the computation into a 16GB memory. One can see that all the computation times in panels (b), (c), and (d) have a strong correlation with the predicted time and space complexity. While in panel (d), the computation time of configuration enumeration also strongly correlates with other factors such as the configuration space size. Among these benchmarks, computational tasks with data types real numbers, complex numbers, or Tropical numbers (CPU only) can utilize fast basic linear algebra subprograms (BLAS) functions. These tasks usually compute much faster than ones with other element types in the same category. Immutable data types with no reference to other values can be compiled to GPU devices that run much faster than CPUs in all cases when the problem scale is big enough. These data types do not include those defined in Polynomial, ConfigEnumerator, ExtendedTropical and SumProductTree or a data type containing them as a part. In panel (c), one can see the Fourier transformation-based method is the fastest in computing the independence polynomial, but it may suffer from round-off errors. The finite field (GF(p)) approach is the only method that does not have round-off errors and can be run on a GPU. In panel (d), one can see the technique to bound the enumeration space (see paper) improves the performance for more than one order of magnitude in enumerating the MISs. The bounding technique can also reduce the memory usage significantly, without which the largest computable graph size is only sim150 on a device with 32GB main memory.","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"We show the benchmark of computing the maximal independent set properties on 3-regular graphs in the following plot, including a comparison to the Bron-Kerbosch algorithm from Julia package Graphs","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"(Image: benchmark-maximal-independent-set)","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"In this plot, benchmarks of computing different solution space properties of the maximal independent sets (ISs) problem on random three regular graphs at different sizes.","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"(a) time and space complexity of tensor network contraction.\n(b) The wall clock time for counting and enumeration of maximal ISs.","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Panel (a) shows the space and time complexities of tensor contraction, which are typically larger than those for the independent set problem. In panel (b), one can see counting maximal independent sets are much more efficient than enumerating them, while our generic tensor network approach runs slightly faster than the Bron-Kerbosch approach in enumerating all maximal independent sets.","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"EditURL = \"https://github.com/QuEraComputing/GenericTensorNetworks.jl/blob/master/examples/MaximalIS.jl\"","category":"page"},{"location":"generated/MaximalIS/#Maximal-independent-set-problem","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"","category":"section"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"note: Note\nIt is highly recommended to read the Independent set problem chapter before reading this one.","category":"page"},{"location":"generated/MaximalIS/#Problem-definition","page":"Maximal independent set problem","title":"Problem definition","text":"","category":"section"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"In graph theory, a maximal independent set is an independent set that is not a subset of any other independent set. It is different from maximum independent set because it does not require the set to have the max size. In the following, we are going to solve the maximal independent set problem on the Petersen graph.","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"using GenericTensorNetworks, Graphs\n\ngraph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"We can visualize this graph using the following function","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\n\nlocations = [[rot15(0.0, 1.0, i) for i=0:4]..., [rot15(0.0, 0.6, i) for i=0:4]...]\n\nshow_graph(graph; locs=locations)","category":"page"},{"location":"generated/MaximalIS/#Generic-tensor-network-representation","page":"Maximal independent set problem","title":"Generic tensor network representation","text":"","category":"section"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"We can use MaximalIS to construct the tensor network for solving the maximal independent set problem as","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"problem = MaximalIS(graph; optimizer=TreeSA());\nnothing #hide","category":"page"},{"location":"generated/MaximalIS/#Theory-(can-skip)","page":"Maximal independent set problem","title":"Theory (can skip)","text":"","category":"section"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Let G=(VE) be the target graph that we want to solve. The tensor network representation map a vertex vin V to a boolean degree of freedom s_vin0 1. We defined the restriction on its neighborhood N(v):","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"T(x_v)_s_1s_2ldotss_N(v)s_v = begincases\n    s_vx_v^w_v  s_1=s_2=ldots=s_N(v)=0\n    1-s_v textotherwise\nendcases","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"The first case corresponds to all the neighborhood vertices of v are not in I_m, then v must be in I_m and contribute a factor x_v^w_v, where w_v is the weight of vertex v. Otherwise, if any of the neighboring vertices of v is in I_m, v must not be in I_m by the independence requirement.","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Its contraction time space complexity of a MaximalIS instance is no longer determined by the tree-width of the original graph G. It is often harder to contract this tensor network than to contract the one for regular independent set problem.","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"timespacereadwrite_complexity(problem)","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Results are log2 values.","category":"page"},{"location":"generated/MaximalIS/#Solving-properties","page":"Maximal independent set problem","title":"Solving properties","text":"","category":"section"},{"location":"generated/MaximalIS/#Counting-properties","page":"Maximal independent set problem","title":"Counting properties","text":"","category":"section"},{"location":"generated/MaximalIS/#maximal-independence-polynomial","page":"Maximal independent set problem","title":"maximal independence polynomial","text":"","category":"section"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"The graph polynomial defined for the maximal independent set problem is","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"I_rm max(G x) = sum_k=0^alpha(G) b_k x^k","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"where b_k is the number of maximal independent sets of size k in graph G=(V E).","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"maximal_indenpendence_polynomial = solve(problem, GraphPolynomial())[]","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"One can see the first several coefficients are 0, because it only counts the maximal independent sets, The minimum maximal independent set size is also known as the independent domination number. It can be computed with the SizeMin property:","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"independent_domination_number = solve(problem, SizeMin())[]","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Similarly, we have its counting CountingMin:","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"counting_min_maximal_independent_set = solve(problem, CountingMin())[]","category":"page"},{"location":"generated/MaximalIS/#Configuration-properties","page":"Maximal independent set problem","title":"Configuration properties","text":"","category":"section"},{"location":"generated/MaximalIS/#finding-all-maximal-independent-set","page":"Maximal independent set problem","title":"finding all maximal independent set","text":"","category":"section"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"maximal_configs = solve(problem, ConfigsAll())[]\n\nall(c->is_maximal_independent_set(graph, c), maximal_configs)","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"show_gallery(graph, (3, 5); locs=locations, vertex_configs=maximal_configs)","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"This result should be consistent with that given by the Bron Kerbosch algorithm on the complement of Petersen graph.","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"cliques = maximal_cliques(complement(graph))","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"For sparse graphs, the generic tensor network approach is usually much faster and memory efficient than the Bron Kerbosch algorithm.","category":"page"},{"location":"generated/MaximalIS/#finding-minimum-maximal-independent-set","page":"Maximal independent set problem","title":"finding minimum maximal independent set","text":"","category":"section"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"It is the ConfigsMin property in the program.","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"minimum_maximal_configs = solve(problem, ConfigsMin())[].c\n\nshow_gallery(graph, (2, 5); locs=locations, vertex_configs=minimum_maximal_configs)","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Similarly, if one is only interested in computing one of the minimum sets, one can use the graph property SingleConfigMin.","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"EditURL = \"https://github.com/QuEraComputing/GenericTensorNetworks.jl/blob/master/examples/MaxCut.jl\"","category":"page"},{"location":"generated/MaxCut/#Cutting-problem-(Spin-glass-problem)","page":"Cutting problem","title":"Cutting problem (Spin-glass problem)","text":"","category":"section"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"note: Note\nIt is highly recommended to read the Independent set problem chapter before reading this one.","category":"page"},{"location":"generated/MaxCut/#Problem-definition","page":"Cutting problem","title":"Problem definition","text":"","category":"section"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"In graph theory, a cut is a partition of the vertices of a graph into two disjoint subsets. It is closely related to the spin-glass problem in physics. Finding the maximum cut is NP-Hard, where a maximum cut is a cut whose size is at least the size of any other cut, where the size of a cut is the number of edges (or the sum of weights on edges) crossing the cut.","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"using GenericTensorNetworks, Graphs","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"In the following, we are going to defined an cutting problem for the Petersen graph.","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"graph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"We can visualize this graph using the following function","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\n\nlocations = [[rot15(0.0, 1.0, i) for i=0:4]..., [rot15(0.0, 0.6, i) for i=0:4]...]\n\nshow_graph(graph; locs=locations)","category":"page"},{"location":"generated/MaxCut/#Generic-tensor-network-representation","page":"Cutting problem","title":"Generic tensor network representation","text":"","category":"section"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"We define the cutting problem as","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"problem = MaxCut(graph);\nnothing #hide","category":"page"},{"location":"generated/MaxCut/#Theory-(can-skip)","page":"Cutting problem","title":"Theory (can skip)","text":"","category":"section"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"For a vertex vin V, we define a boolean degree of freedom s_vin0 1. Then the maximum cutting problem can be encoded to tensor networks by mapping an edge (ij)in E to an edge matrix labelled by s_is_j","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"B(x_langle i jrangle) = left(beginmatrix\n    1  x_langle i jrangle^w_langle ij rangle\n    x_langle i jrangle^w_langle ij rangle  1\nendmatrixright)","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"If and only if there is a cut on edge (i j), this tensor contributes a factor x_langle i jrangle^w_langle ij rangle, where w_langle ijrangle is the weight of this edge. Similar to other problems, we can define a polynomial about edges variables by setting x_langle i jrangle = x, where its k-th coefficient is two times the number of configurations of cut size k.","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"Its contraction time space complexity is 2^rm tw(G), where rm tw(G) is the tree-width of G.","category":"page"},{"location":"generated/MaxCut/#Solving-properties","page":"Cutting problem","title":"Solving properties","text":"","category":"section"},{"location":"generated/MaxCut/#Maximum-cut-size-\\gamma(G)","page":"Cutting problem","title":"Maximum cut size gamma(G)","text":"","category":"section"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"max_cut_size = solve(problem, SizeMax())[]","category":"page"},{"location":"generated/MaxCut/#Counting-properties","page":"Cutting problem","title":"Counting properties","text":"","category":"section"},{"location":"generated/MaxCut/#graph-polynomial","page":"Cutting problem","title":"graph polynomial","text":"","category":"section"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"The graph polynomial defined for the cutting problem is","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"C(G x) = sum_k=0^gamma(G) c_k x^k","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"where alpha(G) is the maximum independent set size, c_k2 is the number of cuts of size k in graph G=(VE). Since the variable x is defined on edges, the coefficients of the polynomial is the number of configurations having different number of anti-parallel edges.","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"max_config = solve(problem, GraphPolynomial())[]","category":"page"},{"location":"generated/MaxCut/#Configuration-properties","page":"Cutting problem","title":"Configuration properties","text":"","category":"section"},{"location":"generated/MaxCut/#finding-one-max-cut-solution","page":"Cutting problem","title":"finding one max cut solution","text":"","category":"section"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"max_vertex_config = solve(problem, SingleConfigMax())[].c.data\n\nmax_cut_size_verify = cut_size(graph, max_vertex_config)","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"You should see a consistent result as above max_cut_size.","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"show_graph(graph; locs=locations, vertex_colors=[\n        iszero(max_vertex_config[i]) ? \"white\" : \"red\" for i=1:nv(graph)])","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"where red vertices and white vertices are separated by the cut.","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"EditURL = \"https://github.com/QuEraComputing/GenericTensorNetworks.jl/blob/master/examples/saveload.jl\"","category":"page"},{"location":"generated/saveload/#Save-and-load-solutions","page":"Save and load solutions","title":"Save and load solutions","text":"","category":"section"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"Let us use the maximum independent set problem on Petersen graph as an example. The following code enumerates all independent sets.","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"using GenericTensorNetworks, Graphs\n\nproblem = IndependentSet(Graphs.smallgraph(:petersen))\n\nall_independent_sets = solve(problem, ConfigsAll())[]","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"The return value has type ConfigEnumerator. We can use save_configs and load_configs to save and read a ConfigEnumerator instance to the disk.","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"filename = tempname()\n\nsave_configs(filename, all_independent_sets; format=:binary)\n\nloaded_sets = load_configs(filename; format=:binary, bitlength=10)","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"note: Note\nWhen loading the data in the binary format, bit string length information bitlength is required.","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"For the SumProductTree type output, we can use save_sumproduct and load_sumproduct to save and load serialized data.","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"all_independent_sets_tree = solve(problem, ConfigsAll(; tree_storage=true))[]\n\nsave_sumproduct(filename, all_independent_sets_tree)\n\nloaded_sets_tree = load_sumproduct(filename)","category":"page"},{"location":"generated/saveload/#Loading-solutions-to-python","page":"Save and load solutions","title":"Loading solutions to python","text":"","category":"section"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"The following python script loads and unpacks the solutions as a numpy array from a :binary format file.","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"import numpy as np\n\ndef loadfile(filename:str, bitlength:int):\n    C = int(np.ceil(bitlength / 64))\n    arr = np.fromfile(filename, dtype=\"uint8\")\n    # Some axes should be transformed from big endian to little endian\n    res = np.unpackbits(arr).reshape(-1, C, 8, 8)[:,::-1,::-1,:]\n    res = res.reshape(-1, C*64)[:, :(64*C-bitlength)-1:-1]\n    print(\"number of solutions = %d\"%(len(res)))\n    return res  # in big endian format\n\nres = loadfile(filename, 10)","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"note: Note\nCheck section Maximal independent set problem for solution space properties related the maximal independent sets. That example also contains using cases of finding solution space properties related to minimum sizes:SizeMin for finding minimum several set sizes,\nCountingMin for counting minimum several set sizes,\nSingleConfigMin for finding one solution with minimum several sizes,\nConfigsMin for enumerating solutions with minimum several sizes,","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"EditURL = \"https://github.com/QuEraComputing/GenericTensorNetworks.jl/blob/master/examples/SetCovering.jl\"","category":"page"},{"location":"generated/SetCovering/#Set-covering-problem","page":"Set covering problem","title":"Set covering problem","text":"","category":"section"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"note: Note\nIt is highly recommended to read the Independent set problem chapter before reading this one.","category":"page"},{"location":"generated/SetCovering/#Problem-definition","page":"Set covering problem","title":"Problem definition","text":"","category":"section"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"The set covering problem is a significant NP-hard problem in combinatorial optimization. Given a collection of elements, the set covering problem aims to find the minimum number of sets that incorporate (cover) all of these elements. In the following, we will find the solution space properties for the camera location and stadium area example in the Cornell University Computational Optimization Open Textbook.","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"using GenericTensorNetworks, Graphs","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"The covering stadium areas of cameras are represented as the following sets.","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"sets = [[1,3,4,6,7], [4,7,8,12], [2,5,9,11,13],\n    [1,2,14,15], [3,6,10,12,14], [8,14,15],\n    [1,2,6,11], [1,2,4,6,8,12]]","category":"page"},{"location":"generated/SetCovering/#Generic-tensor-network-representation","page":"Set covering problem","title":"Generic tensor network representation","text":"","category":"section"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"We create a [SetCovering] instance that contains a generic tensor network as its code field.","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"problem = SetCovering(sets);\nnothing #hide","category":"page"},{"location":"generated/SetCovering/#Theory-(can-skip)","page":"Set covering problem","title":"Theory (can skip)","text":"","category":"section"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"Let S be the target set covering problem that we want to solve. For each set s in S, we associate it with a weight w_s to it. The tensor network representation map a set sin S to a boolean degree of freedom v_sin0 1. For each set s, we defined a parameterized rank-one tensor indexed by v_s as","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"W(x_s^w_s) = left(beginmatrix\n    1 \n    x_s^w_s\n    endmatrixright)","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"where x_s is a variable associated with s. For each unique element a, we defined the constraint over all sets containing it N(a) = s  s in S land ain s:","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"B_s_1s_2ldotss_N(a) = begincases\n    0  s_1=s_2=ldots=s_N(a)=0\n    1  textotherwise\nendcases","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"This tensor means if none of the sets containing element a are included, then this configuration is forbidden, One can check the contraction time space complexity of a SetCovering instance by typing:","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"timespacereadwrite_complexity(problem)","category":"page"},{"location":"generated/SetCovering/#Solving-properties","page":"Set covering problem","title":"Solving properties","text":"","category":"section"},{"location":"generated/SetCovering/#Counting-properties","page":"Set covering problem","title":"Counting properties","text":"","category":"section"},{"location":"generated/SetCovering/#The-\"graph\"-polynomial","page":"Set covering problem","title":"The \"graph\" polynomial","text":"","category":"section"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"The graph polynomial for the set covering problem is defined as","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"P(S x) = sum_k=0^S c_k x^k","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"where c_k is the number of configurations having k sets.","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"covering_polynomial = solve(problem, GraphPolynomial())[]","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"The minimum number of sets that covering the set of elements can be computed with the SizeMin property:","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"min_cover_size = solve(problem, SizeMin())[]","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"Similarly, we have its counting CountingMin:","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"counting_minimum_setcovering = solve(problem, CountingMin())[]","category":"page"},{"location":"generated/SetCovering/#Configuration-properties","page":"Set covering problem","title":"Configuration properties","text":"","category":"section"},{"location":"generated/SetCovering/#Finding-minimum-set-covering","page":"Set covering problem","title":"Finding minimum set covering","text":"","category":"section"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"One can enumerate all minimum set covering with the ConfigsMin property in the program.","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"min_configs = solve(problem, ConfigsMin())[].c","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"Hence the two optimal solutions are z_1 z_3 z_5 z_6 and z_2 z_3 z_4 z_5. The correctness of this result can be checked with the is_set_covering function.","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"all(c->is_set_covering(sets, c), min_configs)","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"Similarly, if one is only interested in computing one of the minimum set coverings, one can use the graph property SingleConfigMin.","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"gist/#Gist-of-implementation","page":"Gist","title":"Gist of implementation","text":"","category":"section"},{"location":"gist/","page":"Gist","title":"Gist","text":"The code we will show below is a gist of how this package is implemented for pedagogical purpose, which covers many functionalities of the main repo without caring much about performance. This project depends on multiple open source packages in the Julia ecosystem:","category":"page"},{"location":"gist/","page":"Gist","title":"Gist","text":"OMEinsum and OMEinsumContractionOrders are packages providing the support for Einstein's (or tensor network) notation and state-of-the-art algorithms for contraction order optimization, which includes multiple state of the art algorithms.\nTropicalNumbers and TropicalGEMM are packages providing tropical number and efficient tropical matrix multiplication.\nGraphs is a foundational package for graph manipulation in the Julia community.\nPolynomials is a package providing polynomial algebra and polynomial fitting.\nMods and the Primes package providing finite field algebra and prime number manipulation.","category":"page"},{"location":"gist/","page":"Gist","title":"Gist","text":"They can be installed in a similar way to GenericTensorNetworks. After installing the required packages, one can open a Julia REPL, and copy-paste the following code snippet into it.","category":"page"},{"location":"gist/","page":"Gist","title":"Gist","text":"using OMEinsum, OMEinsumContractionOrders\nusing Graphs\nusing Random\n\n# generate a random regular graph of size 50, degree 3\ngraph = (Random.seed!(2); Graphs.random_regular_graph(50, 3))\n\n# generate einsum code, i.e. the labels of tensors\ncode = EinCode(([minmax(e.src,e.dst) for e in Graphs.edges(graph)]..., # labels for edge tensors\n                [(i,) for i in Graphs.vertices(graph)]...), ())        # labels for vertex tensors\n\n# an einsum contraction without a contraction order specified is called `EinCode`,\n# an einsum contraction having a contraction order (specified as a tree structure) is called `NestedEinsum`.\n# assign each label a dimension-2, it will be used in the contraction order optimization\n# `uniquelabels` function extracts the tensor labels into a vector.\nsize_dict = Dict([s=>2 for s in uniquelabels(code)])\n# optimize the contraction order using the `TreeSA` method; the target space complexity is 2^17\noptimized_code = optimize_code(code, size_dict, TreeSA())\nprintln(\"time/space complexity is $(OMEinsum.timespace_complexity(optimized_code, size_dict))\")\n\n# a function for computing the independence polynomial\nfunction independence_polynomial(x::T, code) where {T}\n\txs = map(getixsv(code)) do ix\n        # if the tensor rank is 1, create a vertex tensor.\n        # otherwise the tensor rank must be 2, create a bond tensor.\n        length(ix)==1 ? [one(T), x] : [one(T) one(T); one(T) zero(T)]\n    end\n    # both `EinCode` and `NestedEinsum` are callable, inputs are tensors.\n\tcode(xs...)\nend\n\n########## COMPUTING THE MAXIMUM INDEPENDENT SET SIZE AND ITS COUNTING/DEGENERACY ###########\n\n# using Tropical numbers to compute the MIS size and the MIS degeneracy.\nusing TropicalNumbers\nmis_size(code) = independence_polynomial(TropicalF64(1.0), code)[]\nprintln(\"the maximum independent set size is $(mis_size(optimized_code).n)\")\n\n# A `CountingTropical` object has two fields, tropical field `n` and counting field `c`.\nmis_count(code) = independence_polynomial(CountingTropical{Float64,Float64}(1.0, 1.0), code)[]\nprintln(\"the degeneracy of maximum independent sets is $(mis_count(optimized_code).c)\")\n\n########## COMPUTING THE INDEPENDENCE POLYNOMIAL ###########\n\n# using Polynomial numbers to compute the polynomial directly\nusing Polynomials\nprintln(\"the independence polynomial is $(independence_polynomial(Polynomial([0.0, 1.0]), optimized_code)[])\")\n\n########## FINDING MIS CONFIGURATIONS ###########\n\n# define the set algebra\nstruct ConfigEnumerator{N}\n    # NOTE: BitVector is dynamic and it can be very slow; check our repo for the static version\n    data::Vector{BitVector}\nend\nfunction Base.:+(x::ConfigEnumerator{N}, y::ConfigEnumerator{N}) where {N}\n    res = ConfigEnumerator{N}(vcat(x.data, y.data))\n    return res\nend\nfunction Base.:*(x::ConfigEnumerator{L}, y::ConfigEnumerator{L}) where {L}\n    M, N = length(x.data), length(y.data)\n    z = Vector{BitVector}(undef, M*N)\n    for j=1:N, i=1:M\n        z[(j-1)*M+i] = x.data[i] .| y.data[j]\n    end\n    return ConfigEnumerator{L}(z)\nend\nBase.zero(::Type{ConfigEnumerator{N}}) where {N} = ConfigEnumerator{N}(BitVector[])\nBase.one(::Type{ConfigEnumerator{N}}) where {N} = ConfigEnumerator{N}([falses(N)])\n\n# the algebra sampling one of the configurations\nstruct ConfigSampler{N}\n    data::BitVector\nend\n\nfunction Base.:+(x::ConfigSampler{N}, y::ConfigSampler{N}) where {N}  # biased sampling: return `x`\n    return x  # randomly pick one\nend\nfunction Base.:*(x::ConfigSampler{L}, y::ConfigSampler{L}) where {L}\n    ConfigSampler{L}(x.data .| y.data)\nend\n\nBase.zero(::Type{ConfigSampler{N}}) where {N} = ConfigSampler{N}(trues(N))\nBase.one(::Type{ConfigSampler{N}}) where {N} = ConfigSampler{N}(falses(N))\n\n# enumerate all configurations if `all` is true; compute one otherwise.\n# a configuration is stored in the data type of `StaticBitVector`; it uses integers to represent bit strings.\n# `ConfigTropical` is defined in `TropicalNumbers`. It has two fields: tropical number `n` and optimal configuration `config`.\n# `CountingTropical{T,<:ConfigEnumerator}` stores configurations instead of simple counting.\nfunction mis_config(code; all=false)\n    # map a vertex label to an integer\n    vertex_index = Dict([s=>i for (i, s) in enumerate(uniquelabels(code))])\n    N = length(vertex_index)  # number of vertices\n    xs = map(getixsv(code)) do ix\n        T = all ? CountingTropical{Float64, ConfigEnumerator{N}} : CountingTropical{Float64, ConfigSampler{N}}\n        if length(ix) == 2\n            return [one(T) one(T); one(T) zero(T)]\n        else\n            s = falses(N)\n            s[vertex_index[ix[1]]] = true  # one hot vector\n            if all\n                [one(T), T(1.0, ConfigEnumerator{N}([s]))]\n            else\n                [one(T), T(1.0, ConfigSampler{N}(s))]\n            end\n        end\n    end\n\treturn code(xs...)\nend\n\nprintln(\"one of the optimal configurations is $(mis_config(optimized_code; all=false)[].c.data)\")\n\n# direct enumeration of configurations can be very slow; please check the bounding version in our Github repo.\nprintln(\"all optimal configurations are $(mis_config(optimized_code; all=true)[].c)\")","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"EditURL = \"https://github.com/QuEraComputing/GenericTensorNetworks.jl/blob/master/examples/DominatingSet.jl\"","category":"page"},{"location":"generated/DominatingSet/#Dominating-set-problem","page":"Dominating set problem","title":"Dominating set problem","text":"","category":"section"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"note: Note\nIt is highly recommended to read the Independent set problem chapter before reading this one.","category":"page"},{"location":"generated/DominatingSet/#Problem-definition","page":"Dominating set problem","title":"Problem definition","text":"","category":"section"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"In graph theory, a dominating set for a graph G = (V E) is a subset D of V such that every vertex not in D is adjacent to at least one member of D. The domination number gamma(G) is the number of vertices in a smallest dominating set for G. The decision version of finding the minimum dominating set is an NP-complete. In the following, we are going to solve the dominating set problem on the Petersen graph.","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"using GenericTensorNetworks, Graphs\n\ngraph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"We can visualize this graph using the following function","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\n\nlocations = [[rot15(0.0, 1.0, i) for i=0:4]..., [rot15(0.0, 0.6, i) for i=0:4]...]\n\nshow_graph(graph; locs=locations)","category":"page"},{"location":"generated/DominatingSet/#Generic-tensor-network-representation","page":"Dominating set problem","title":"Generic tensor network representation","text":"","category":"section"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"We can use DominatingSet to construct the tensor network for solving the dominating set problem as","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"problem = DominatingSet(graph; optimizer=TreeSA());\nnothing #hide","category":"page"},{"location":"generated/DominatingSet/#Theory-(can-skip)","page":"Dominating set problem","title":"Theory (can skip)","text":"","category":"section"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"Let G=(VE) be the target graph that we want to solve. The tensor network representation map a vertex vin V to a boolean degree of freedom s_vin0 1. We defined the restriction on a vertex and its neighboring vertices N(v):","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"T(x_v)_s_1s_2ldotss_N(v)s_v = begincases\n    0  s_1=s_2=ldots=s_N(v)=s_v=0\n    1  s_v=0\n    x_v^w_v  textotherwise\nendcases","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"where w_v is the weight of vertex v. This tensor means if both v and its neighboring vertices are not in D, i.e., s_1=s_2=ldots=s_N(v)=s_v=0, this configuration is forbidden because v is not adjacent to any member in the set. otherwise, if v is in D, it has a contribution x_v^w_v to the final result. One can check the contraction time space complexity of a DominatingSet instance by typing:","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"timespacereadwrite_complexity(problem)","category":"page"},{"location":"generated/DominatingSet/#Solving-properties","page":"Dominating set problem","title":"Solving properties","text":"","category":"section"},{"location":"generated/DominatingSet/#Counting-properties","page":"Dominating set problem","title":"Counting properties","text":"","category":"section"},{"location":"generated/DominatingSet/#Domination-polynomial","page":"Dominating set problem","title":"Domination polynomial","text":"","category":"section"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"The graph polynomial for the dominating set problem is known as the domination polynomial (see arXiv:0905.2251). It is defined as","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"D(G x) = sum_k=0^gamma(G) d_k x^k","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"where d_k is the number of dominating sets of size k in graph G=(V E).","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"domination_polynomial = solve(problem, GraphPolynomial())[]","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"The domination number gamma(G) can be computed with the SizeMin property:","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"domination_number = solve(problem, SizeMin())[]","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"Similarly, we have its counting CountingMin:","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"counting_min_dominating_set = solve(problem, CountingMin())[]","category":"page"},{"location":"generated/DominatingSet/#Configuration-properties","page":"Dominating set problem","title":"Configuration properties","text":"","category":"section"},{"location":"generated/DominatingSet/#finding-minimum-dominating-set","page":"Dominating set problem","title":"finding minimum dominating set","text":"","category":"section"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"One can enumerate all minimum dominating sets with the ConfigsMin property in the program.","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"min_configs = solve(problem, ConfigsMin())[].c\n\nall(c->is_dominating_set(graph, c), min_configs)","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"show_gallery(graph, (2, 5); locs=locations, vertex_configs=min_configs)","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"Similarly, if one is only interested in computing one of the minimum dominating sets, one can use the graph property SingleConfigMin.","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"EditURL = \"https://github.com/QuEraComputing/GenericTensorNetworks.jl/blob/master/examples/weighted.jl\"","category":"page"},{"location":"generated/weighted/#Weighted-problems","page":"Weighted problems","title":"Weighted problems","text":"","category":"section"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"Let us use the maximum independent set problem on Petersen graph as an example.","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"using GenericTensorNetworks, Graphs\n\ngraph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"The following code constructs a weighted MIS problem instance.","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"problem = IndependentSet(graph; weights=collect(1:10));\nnothing #hide","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"Here, the weights keyword argument can be a vector for weighted graphs or NoWeight() for unweighted graphs. Most solution space properties work for unweighted graphs also work for the weighted graphs. For example, the maximum independent set can be found as follows.","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"max_config_weighted = solve(problem, SingleConfigMax())[]","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"Let us visualize the solution.","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\n\nlocations = [[rot15(0.0, 1.0, i) for i=0:4]..., [rot15(0.0, 0.6, i) for i=0:4]...]\n\nshow_graph(graph; locs=locations, vertex_colors=\n          [iszero(max_config_weighted.c.data[i]) ? \"white\" : \"red\" for i=1:nv(graph)])","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"The only solution space property that can not be defined for general real-weighted (not including integer-weighted) graphs is the GraphPolynomial.","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"For the weighted MIS problem, a useful solution space property is the \"energy spectrum\", i.e. the largest several configurations and their weights. We can use the solution space property is SizeMax(10) to compute the largest 10 weights.","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"spectrum = solve(problem, SizeMax(10))[]","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"The return value has type ExtendedTropical, which contains one field orders.","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"spectrum.orders","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"We can see the order is a vector of Tropical numbers. Similarly, we can get weighted independent sets with maximum 5 sizes as follows.","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"max5_configs = solve(problem, SingleConfigMax(5))[]","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"The return value also has type ExtendedTropical, but this time the element type of orders has been changed to CountingTropical{Float64,ConfigSampler}.","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"max5_configs.orders","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"Let us visually check these configurations","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"show_gallery(graph, (1, 5); locs=locations, vertex_configs=[max5_configs.orders[k].c.data for k=1:5])","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"ref/#References","page":"References","title":"References","text":"","category":"section"},{"location":"ref/#Graph-problems","page":"References","title":"Graph problems","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"solve\nGraphProblem\nIndependentSet\nMaximalIS\nMatching\nColoring\nDominatingSet\nMaxCut\nPaintShop\nSatisfiability\nSetCovering\nSetPacking\nOpenPitMining","category":"page"},{"location":"ref/#GenericTensorNetworks.solve","page":"References","title":"GenericTensorNetworks.solve","text":"solve(problem, property; usecuda=false, T=Float64)\n\nSolving a certain property of a graph problem.\n\nPositional Arguments\n\nproblem is the graph problem with tensor network information,\nproperty is string specifying the task. Using the maximum independent set problem as an example, it can be one of\nSizeMax(k=Single) for finding maximum-k set sizes,\nSizeMin(k=Single) for finding minimum-k set sizes,\nCountingMax(k=Single) for counting configurations with maximum-k sizes,\nCountingMin(k=Single) for counting configurations with minimum-k sizes,\nCountingAll() for counting all configurations,\nGraphPolynomial(; method=:finitefield, kwargs...) for evaluating the graph polynomial,\nSingleConfigMax(k=Single; bounded=false) for finding one maximum-k configuration for each size,\nSingleConfigMin(k=Single; bounded=false) for finding one minimum-k configuration for each size,\nConfigsMax(k=Single; bounded=true, tree_storage=false) for enumerating configurations with maximum-k sizes,\nConfigsMin(k=Single; bounded=true, tree_storage=false) for enumerating configurations with minimum-k sizes,\nConfigsAll(; tree_storage=false) for enumerating all configurations,\n\nKeyword arguments\n\nusecuda is a switch to use CUDA (if possible), user need to call statement using CUDA before turning on this switch.\nT is the \"base\" element type, sometimes can be used to reduce the memory cost.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.GraphProblem","page":"References","title":"GenericTensorNetworks.GraphProblem","text":"GraphProblem\n\nThe abstract base type of graph problems.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.IndependentSet","page":"References","title":"GenericTensorNetworks.IndependentSet","text":"IndependentSet{CT<:AbstractEinsum,WT<:Union{NoWeight, Vector}} <: GraphProblem\nIndependentSet(graph; weights=NoWeight(), openvertices=(),\n        optimizer=GreedyMethod(), simplifier=nothing,\n        fixedvertices=Dict()\n    )\n\nThe independent set problem in graph theory.\n\nPositional arguments\n\ngraph is the problem graph.\n\nKeyword arguments\n\nweights are associated with the vertices of the graph.\noptimizer and simplifier are for tensor network optimization, check optimize_code for details.\nfixedvertices is a dict to specify the values of degree of freedoms on vertices, where a value can be 0 (absent in the set) or 1 (present in the set).\nopenvertices is a tuple of labels to specify the output tensor. Theses degree of freedoms will not be contracted.\n\nExamples\n\njulia> using GenericTensorNetworks, Graphs\n\njulia> problem = IndependentSet(smallgraph(:petersen));\n\njulia> solve(problem, ConfigsMax())\n0-dimensional Array{CountingTropical{Float64, ConfigEnumerator{10, 1, 1}}, 0}:\n(4.0, {0101010001, 1010000011, 0100100110, 0010111000, 1001001100})ₜ\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.MaximalIS","page":"References","title":"GenericTensorNetworks.MaximalIS","text":"MaximalIS{CT<:AbstractEinsum,WT<:Union{NoWeight, Vector}} <: GraphProblem\nMaximalIS(graph; weights=NoWeight(), openvertices=(),\n        optimizer=GreedyMethod(), simplifier=nothing,\n        fixedvertices=Dict()\n    )\n\nThe maximal independent set problem. In the constructor, weights are the weights of vertices.\n\nPositional arguments\n\ngraph is the problem graph.\n\nKeyword arguments\n\nweights are associated with the vertices of the graph.\noptimizer and simplifier are for tensor network optimization, check optimize_code for details.\nfixedvertices is a dict to specify the values of degree of freedoms, where a value can be 0 (absent in the set) or 1 (present in the set).\nopenvertices is a tuple of labels to specify the output tensor. Theses degree of freedoms will not be contracted.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.Matching","page":"References","title":"GenericTensorNetworks.Matching","text":"Matching{CT<:AbstractEinsum, WT<:Union{NoWeight,Vector}} <: GraphProblem\nMatching(graph; weights=NoWeight(), openvertices=(),\n        optimizer=GreedyMethod(), simplifier=nothing,\n        fixedvertices=Dict()\n    )\n\nThe Vertex matching problem.\n\nPositional arguments\n\ngraph is the problem graph.\n\nKeyword arguments\n\nweights are associated with the edges of the graph.\noptimizer and simplifier are for tensor network optimization, check optimize_code for details.\nfixedvertices is a dict to specify the values of degree of freedoms on edges, where a value can be 0 (not matched) or 1 (mathced).\nopenvertices is a tuple of labels to specify the output tensor. Theses degree of freedoms will not be contracted.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.Coloring","page":"References","title":"GenericTensorNetworks.Coloring","text":"Coloring{K,CT<:AbstractEinsum, WT<:Union{NoWeight, Vector}} <: GraphProblem\nColoring{K}(graph; weights=NoWeight(), openvertices=(),\n        optimizer=GreedyMethod(), simplifier=nothing,\n        fixedvertices=Dict()\n    )\n\nThe Vertex Coloring problem.\n\nPositional arguments\n\ngraph is the problem graph.\n\nKeyword arguments\n\nweights are associated with the edges of the graph.\noptimizer and simplifier are for tensor network optimization, check optimize_code for details.\nfixedvertices is a dict to specify the values of degree of freedoms on vertices, where a value can be in 0K-1 (different colors).\nopenvertices is a tuple of labels to specify the output tensor. Theses degree of freedoms will not be contracted.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.DominatingSet","page":"References","title":"GenericTensorNetworks.DominatingSet","text":"DominatingSet{CT<:AbstractEinsum,WT<:Union{NoWeight, Vector}} <: GraphProblem\nDominatingSet(graph; weights=NoWeight(), openvertices=(),\n        optimizer=GreedyMethod(), simplifier=nothing,\n        fixedvertices=Dict()\n    )\n\nThe dominating set problem.\n\nPositional arguments\n\ngraph is the problem graph.\n\nKeyword arguments\n\nweights are associated with the vertices of the graph.\noptimizer and simplifier are for tensor network optimization, check optimize_code for details.\nfixedvertices is a dict to specify the values of degree of freedoms on vertices, where a value can be 0 (absent in the set) or 1 (present in the set).\nopenvertices is a tuple of labels to specify the output tensor. Theses degree of freedoms will not be contracted.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.MaxCut","page":"References","title":"GenericTensorNetworks.MaxCut","text":"MaxCut{CT<:AbstractEinsum,WT<:Union{NoWieght, Vector}} <: GraphProblem\nMaxCut(graph; weights=NoWeight(), openvertices=(),\n        optimizer=GreedyMethod(), simplifier=nothing,\n        fixedvertices=Dict()\n    )\n\nThe cutting problem (or spin glass problem).\n\nPositional arguments\n\ngraph is the problem graph.\n\nKeyword arguments\n\nweights are associated with the edges of the graph.\noptimizer and simplifier are for tensor network optimization, check optimize_code for details.\nfixedvertices is a dict to specify the values of degree of freedoms, where a value can be 0 (in one side of the cut) or 1 (in the other side of the cut).\nopenvertices is a tuple of labels to specify the output tensor. Theses degree of freedoms will not be contracted.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.PaintShop","page":"References","title":"GenericTensorNetworks.PaintShop","text":"PaintShop{CT<:AbstractEinsum} <: GraphProblem\nPaintShop(sequence::AbstractVector; openvertices=(),\n        optimizer=GreedyMethod(), simplifier=nothing,\n        fixedvertices=Dict()\n    )\n\nThe binary paint shop problem.\n\nPositional arguments\n\nKeyword arguments\n\noptimizer and simplifier are for tensor network optimization, check optimize_code for details.\nfixedvertices is a dict to specify the values of degree of freedoms, where a value can be 0 (the first appearence in blue) or 1 (the first appearence in red).\nopenvertices is a tuple of labels to specify the output tensor. Theses degree of freedoms will not be contracted.\n\nExamples\n\nOne can encode the paint shop problem abaccb as the following\n\njulia> syms = collect(\"abaccb\");\n\njulia> pb = PaintShop(syms);\n\njulia> solve(pb, SizeMin())[]\n2.0ₜ\n\njulia> solve(pb, ConfigsMin())[].c.data\n2-element Vector{StaticBitVector{3, 1}}:\n 100\n 011\n\nIn our definition, we find the maximum number of unchanged color in this sequence, i.e. (n-1) - (minimum number of color changes) In the output of maximum configurations, the two configurations are defined on 5 bonds i.e. pairs of (i, i+1), 0 means color changed, while 1 means color not changed. If we denote two \"colors\" as r and b, then the optimal painting is rbbbrr or brrrbb, both change the colors twice.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.Satisfiability","page":"References","title":"GenericTensorNetworks.Satisfiability","text":"Satisfiability{CT<:AbstractEinsum,T,WT<:Union{NoWeight, Vector}} <: GraphProblem\nSatisfiability(cnf::CNF; weights=NoWeight(), openvertices=(),\n        optimizer=GreedyMethod(), simplifier=nothing,\n        fixedvertices=Dict()\n    )\n\nThe satisfiability problem.\n\nPositional arguments\n\ncnf is a conjunctive normal form (CNF) for specifying the satisfiability problems.\n\nKeyword arguments\n\nweights are associated with clauses.\noptimizer and simplifier are for tensor network optimization, check optimize_code for details.\nfixedvertices is a dict to specify the values of boolean variables, where a value can be 0 or 1.\nopenvertices is a tuple of labels to specify the output tensor. Theses degree of freedoms will not be contracted.\n\nExamples\n\njulia> @bools x y z a b c\n\njulia> c1 = x ∨ ¬y\nx ∨ ¬y\n\njulia> c2 = c ∨ (¬a ∨ b)\nc ∨ ¬a ∨ b\n\njulia> c3 = (z ∨ ¬a) ∨ y\nz ∨ ¬a ∨ y\n\njulia> c4 = (c ∨ z) ∨ ¬b\nc ∨ z ∨ ¬b\n\njulia> cnf = (c1 ∧ c4) ∧ (c2 ∧ c3)\n(x ∨ ¬y) ∧ (c ∨ z ∨ ¬b) ∧ (c ∨ ¬a ∨ b) ∧ (z ∨ ¬a ∨ y)\n\njulia> gp = Satisfiability(cnf);\n\njulia> solve(gp, SizeMax())[]\n4.0ₜ\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.SetCovering","page":"References","title":"GenericTensorNetworks.SetCovering","text":"SetCovering{CT<:AbstractEinsum,WT<:Union{NoWeight, Vector}} <: GraphProblem\nSetCovering(sets; weights=NoWeight(), openvertices=(),\n        optimizer=GreedyMethod(), simplifier=nothing,\n        fixedvertices=Dict()\n    )\n\nThe set covering problem.\n\nPositional arguments\n\nsets is a vector of vectors, each set is associated with a weight specified in weights.\n\nKeyword arguments\n\nweights are associated with sets.\noptimizer and simplifier are for tensor network optimization, check optimize_code for details.\nfixedvertices is a dict to specify the values of degree of freedoms, where a value can be 0 (absent in the set) or 1 (present in the set).\nopenvertices is a tuple of labels to specify the output tensor. Theses degree of freedoms will not be contracted.\n\nExamples\n\njulia> sets = [[1, 2, 5], [1, 3], [2, 4], [3, 6], [2, 3, 6]];  # each set is a vertex\n\njulia> gp = SetCovering(sets);\n\njulia> res = solve(gp, ConfigsMin())[]\n(3.0, {10110, 10101})ₜ\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.SetPacking","page":"References","title":"GenericTensorNetworks.SetPacking","text":"SetPacking{CT<:AbstractEinsum,WT<:Union{NoWeight, Vector}} <: GraphProblem\nSetPacking(sets; weights=NoWeight(), openvertices=(),\n        optimizer=GreedyMethod(), simplifier=nothing,\n        fixedvertices=Dict()\n    )\n\nThe set packing problem, a generalization of independent set problem to hypergraphs.\n\nPositional arguments\n\nsets is a vector of vectors, each set is associated with a weight specified in weights.\n\nKeyword arguments\n\nweights are associated with sets.\noptimizer and simplifier are for tensor network optimization, check optimize_code for details.\nfixedvertices is a dict to specify the values of degree of freedoms, where a value can be 0 (absent in the set) or 1 (present in the set).\nopenvertices is a tuple of labels to specify the output tensor. Theses degree of freedoms will not be contracted.\n\nExamples\n\njulia> sets = [[1, 2, 5], [1, 3], [2, 4], [3, 6], [2, 3, 6]];  # each set is a vertex\n\njulia> gp = SetPacking(sets);\n\njulia> res = solve(gp, ConfigsMax())[]\n(2.0, {00110, 10010, 01100})ₜ\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.OpenPitMining","page":"References","title":"GenericTensorNetworks.OpenPitMining","text":"OpenPitMining{ET, CT<:AbstractEinsum} <: GraphProblem\nOpenPitMining(rewards; openvertices=(),\n             optimizer=GreedyMethod(), simplifier=nothing,\n             fixedvertices=Dict())\n\nThe open pit mining problem. This problem can be solved in polynomial time with the pseudoflow algorithm.\n\nPositional arguments\n\nrewards is a matrix of rewards.\n\nKeyword arguments\n\nopenvertices specifies labels of the output tensor.\noptimizer and simplifier are for tensor network optimization, check optimize_code for details.\nfixedvertices is a dict to specify the values of labels, where a value can be 0 (not mined) or 1 (mined)\nopenvertices is a tuple of labels to specify the output tensor. Theses degree of freedoms will not be contracted.\n\nExample\n\njulia> rewards =  [-4  -7  -7  -17  -7  -26;\n         0  39  -7   -7  -4    0;\n         0   0   1    8   0    0;\n         0   0   0    0   0    0;\n         0   0   0    0   0    0;\n         0   0   0    0   0    0];\n\njulia> gp = OpenPitMining(rewards);\n\njulia> res = solve(gp, SingleConfigMax())[]\n(21.0, ConfigSampler{12, 1, 1}(111000100000))ₜ\n\njulia> is_valid_mining(rewards, res.c.data)\ntrue\n\njulia> print_mining(rewards, res.c.data)\n     -4      -7      -7     -17      -7     -26 \n      ◼      39      -7      -7      -4       ◼ \n      ◼       ◼       1       8       ◼       ◼ \n      ◼       ◼       ◼       ◼       ◼       ◼ \n      ◼       ◼       ◼       ◼       ◼       ◼ \n      ◼       ◼       ◼       ◼       ◼       ◼\n\nYou will the the mining is printed as green in an colored REPL.\n\n\n\n\n\n","category":"type"},{"location":"ref/#Graph-Problem-Interfaces","page":"References","title":"Graph Problem Interfaces","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"To subtype GraphProblem, a new type must contain a code field to represent the (optimized) tensor network. Interfaces GenericTensorNetworks.generate_tensors, labels, flavors and get_weights are required. nflavor is optional.","category":"page"},{"location":"ref/","page":"References","title":"References","text":"GenericTensorNetworks.generate_tensors\nlabels\nterms\nflavors\nget_weights\nnflavor\nfixedvertices","category":"page"},{"location":"ref/#GenericTensorNetworks.generate_tensors","page":"References","title":"GenericTensorNetworks.generate_tensors","text":"generate_tensors(func, problem::GraphProblem)\n\nGenerate a vector of tensors as the inputs of the tensor network contraction code problem.code. func is a function to customize the tensors. func(symbol) returns a vector of elements, the length of which is same as the number of flavors.\n\nExample\n\nThe following code gives your the maximum independent set size\n\njulia> using Graphs, GenericTensorNetworks\n\njulia> gp = IndependentSet(smallgraph(:petersen));\n\njulia> getixsv(gp.code)\n25-element Vector{Vector{Int64}}:\n [1]\n [2]\n [3]\n [4]\n [5]\n [6]\n [7]\n [8]\n [9]\n [10]\n ⋮\n [3, 8]\n [4, 5]\n [4, 9]\n [5, 10]\n [6, 8]\n [6, 9]\n [7, 9]\n [7, 10]\n [8, 10]\n\njulia> gp.code(GenericTensorNetworks.generate_tensors(Tropical(1.0), gp)...)\n0-dimensional Array{TropicalF64, 0}:\n4.0ₜ\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.labels","page":"References","title":"GenericTensorNetworks.labels","text":"labels(problem::GraphProblem) -> Vector\n\nThe labels of a graph problem is defined as the degrees of freedoms in the graph problem. e.g. for the maximum independent set problems, they are the indices of vertices: 1, 2, 3..., while for the max cut problem, they are the edges.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.terms","page":"References","title":"GenericTensorNetworks.terms","text":"terms(problem::GraphProblem) -> Vector\n\nThe terms of a graph problem is defined as the tensor labels that defining local energies (or weights) in the graph problem. e.g. for the maximum independent set problems, they are the vertex-tensor labels: [1], [2], [3]... The weight of a term is same as the power of x in the graph polynomial.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.flavors","page":"References","title":"GenericTensorNetworks.flavors","text":"flavors(::Type{<:GraphProblem}) -> Vector\n\nIt returns a vector of integers as the flavors of a degree of freedom. Its size is the same as the degree of freedom on a single vertex/edge.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.get_weights","page":"References","title":"GenericTensorNetworks.get_weights","text":"get_weights(problem::GraphProblem, sym) -> Vector\n\nThe weights for the degree of freedom specified by sym of the graph problem, where sym is a symbol. In graph polynomial, integer weights are the orders of x.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.nflavor","page":"References","title":"GenericTensorNetworks.nflavor","text":"nflavor(::Type{<:GraphProblem}) -> Int\n\nBond size is equal to the number of flavors.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.fixedvertices","page":"References","title":"GenericTensorNetworks.fixedvertices","text":"fixedvertices(problem::GraphProblem) -> Dict\n\nFix degree of freedoms in a graph problem to a certain value using a dict, where the key is a label, and the value should be in, e.g. [0, 1] in the indepenent set problem. When a degree of freedom is fixed, its size is 1. The optimal tensor network contraction order is then different from the default case.\n\n\n\n\n\n","category":"function"},{"location":"ref/#Graph-Problem-Utilities","page":"References","title":"Graph Problem Utilities","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"is_independent_set\nis_maximal_independent_set\nis_dominating_set\nis_vertex_coloring\nis_matching\nis_set_covering\nis_set_packing\n\ncut_size\nnum_paint_shop_color_switch\npaint_shop_coloring_from_config\nmis_compactify!\n\nCNF\nCNFClause\nBoolVar\nsatisfiable\n@bools\n∨\n¬\n∧\n\nis_valid_mining\nprint_mining","category":"page"},{"location":"ref/#GenericTensorNetworks.is_independent_set","page":"References","title":"GenericTensorNetworks.is_independent_set","text":"is_independent_set(g::SimpleGraph, config)\n\nReturn true if config (a vector of boolean numbers as the mask of vertices) is an independent set of graph g.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.is_maximal_independent_set","page":"References","title":"GenericTensorNetworks.is_maximal_independent_set","text":"is_maximal_independent_set(g::SimpleGraph, config)\n\nReturn true if config (a vector of boolean numbers as the mask of vertices) is a maximal independent set of graph g.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.is_dominating_set","page":"References","title":"GenericTensorNetworks.is_dominating_set","text":"is_dominating_set(g::SimpleGraph, config)\n\nReturn true if config (a vector of boolean numbers as the mask of vertices) is a dominating set of graph g.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.is_vertex_coloring","page":"References","title":"GenericTensorNetworks.is_vertex_coloring","text":"is_vertex_coloring(graph::SimpleGraph, config)\n\nReturns true if the coloring specified by config is a valid one, i.e. does not violate the contraints of vertices of an edges having different colors.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.is_matching","page":"References","title":"GenericTensorNetworks.is_matching","text":"is_matching(graph::SimpleGraph, config)\n\nReturns true if config is a valid matching on graph, and false if a vertex is double matched. config is a vector of boolean variables, which has one to one correspondence with edges(graph).\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.is_set_covering","page":"References","title":"GenericTensorNetworks.is_set_covering","text":"is_set_covering(sets::AbstractVector, config)\n\nReturn true if config (a vector of boolean numbers as the mask of sets) is a set covering of sets.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.is_set_packing","page":"References","title":"GenericTensorNetworks.is_set_packing","text":"is_set_packing(sets::AbstractVector, config)\n\nReturn true if config (a vector of boolean numbers as the mask of sets) is a set packing of sets.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.cut_size","page":"References","title":"GenericTensorNetworks.cut_size","text":"cut_size(g::SimpleGraph, config; weights=NoWeight())\n\nCompute the cut size from vertex config (an iterator).\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.num_paint_shop_color_switch","page":"References","title":"GenericTensorNetworks.num_paint_shop_color_switch","text":"num_paint_shop_color_switch(sequence::AbstractVector, coloring)\n\nReturns the number of color switches.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.paint_shop_coloring_from_config","page":"References","title":"GenericTensorNetworks.paint_shop_coloring_from_config","text":"paint_shop_coloring_from_config(p::PaintShop, config)\n\nReturns a valid painting from the paint shop configuration (given by the configuration solvers). The config is a sequence of 0 and 1, where 0 means painting the first appearence of a car in blue, 1 otherwise.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.mis_compactify!","page":"References","title":"GenericTensorNetworks.mis_compactify!","text":"mis_compactify!(tropicaltensor)\n\nCompactify tropical tensor for maximum independent set problem. It will eliminate some entries by setting them to zero, by the criteria that removing these entry does not change the MIS size of its parent graph (reference to be added).\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.CNF","page":"References","title":"GenericTensorNetworks.CNF","text":"CNF{T}\nCNF(clauses)\n\nBoolean expression in conjunctive normal form. clauses is a vector of CNFClause, if and only if all clauses are satisfied, this CNF is satisfied.\n\nExample\n\njulia> @bools x y z\n\njulia> cnf = (x ∨ y) ∧ (¬y ∨ z)\n(x ∨ y) ∧ (¬y ∨ z)\n\njulia> satisfiable(cnf, Dict([:x=>true, :y=>false, :z=>true]))\ntrue\n\njulia> satisfiable(cnf, Dict([:x=>false, :y=>false, :z=>true]))\nfalse\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.CNFClause","page":"References","title":"GenericTensorNetworks.CNFClause","text":"CNFClause{T}\nCNFClause(vars)\n\nA clause in CNF, its value is the logical or of vars, where vars is a vector of BoolVar.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.BoolVar","page":"References","title":"GenericTensorNetworks.BoolVar","text":"BoolVar{T}\nBoolVar(name, neg)\n\nBoolean variable for constructing CNF clauses.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.satisfiable","page":"References","title":"GenericTensorNetworks.satisfiable","text":"satisfiable(cnf::CNF, config::AbstractDict)\n\nReturns true if an assignment of variables satisfies a CNF.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.@bools","page":"References","title":"GenericTensorNetworks.@bools","text":"@bools(syms::Symbol...)\n\nCreate some boolean variables of type BoolVar in current scope that can be used in create a CNF.\n\nExample\n\njulia> @bools x y z\n\njulia> (x ∨ y) ∧ (¬y ∨ z)\n(x ∨ y) ∧ (¬y ∨ z)\n\n\n\n\n\n","category":"macro"},{"location":"ref/#GenericTensorNetworks.:∨","page":"References","title":"GenericTensorNetworks.:∨","text":"∨(vars...)\n\nLogical or applied on BoolVar and CNFClause. Returns a CNFClause.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.:¬","page":"References","title":"GenericTensorNetworks.:¬","text":"¬(var::BoolVar)\n\nNegation of a boolean variables of type BoolVar.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.:∧","page":"References","title":"GenericTensorNetworks.:∧","text":"∧(vars...)\n\nLogical and applied on CNFClause and CNF. Returns a new CNF.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.is_valid_mining","page":"References","title":"GenericTensorNetworks.is_valid_mining","text":"is_valid_mining(rewards::AbstractMatrix, config)\n\nReturn true if config (a boolean mask for the feasible region) is a valid mining of rewards.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.print_mining","page":"References","title":"GenericTensorNetworks.print_mining","text":"print_mining(rewards::AbstractMatrix, config)\n\nPrinting the mining solution in a colored REPL.\n\n\n\n\n\n","category":"function"},{"location":"ref/#Properties","page":"References","title":"Properties","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"SizeMax\nSizeMin\nCountingAll\nCountingMax\nCountingMin\nGraphPolynomial\nSingleConfigMax\nSingleConfigMin\nConfigsAll\nConfigsMax\nConfigsMin","category":"page"},{"location":"ref/#GenericTensorNetworks.SizeMax","page":"References","title":"GenericTensorNetworks.SizeMax","text":"SizeMax{K} <: AbstractProperty\nSizeMax(k::Int)\n\nThe maximum-K set sizes. e.g. the largest size of the IndependentSet  problem is also know as the independence number.\n\nThe corresponding tensor element type are max-plus tropical number Tropical if K is Single and ExtendedTropical if K is an integer.\nIt is compatible with weighted graph problems.\nBLAS (on CPU) and GPU are supported only if K is Single,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.SizeMin","page":"References","title":"GenericTensorNetworks.SizeMin","text":"SizeMin{K} <: AbstractProperty\nSizeMin(k::Int)\n\nThe minimum-K set sizes. e.g. the smallest size ofthe MaximalIS problem is also known as the independent domination number.\n\nThe corresponding tensor element type are inverted max-plus tropical number Tropical if K is Single and inverted ExtendedTropical K is an integer.\n\nThe inverted Tropical number emulates the min-plus tropical number.\n\nIt is compatible with weighted graph problems.\nBLAS (on CPU) and GPU are supported only if K is Single,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.CountingAll","page":"References","title":"GenericTensorNetworks.CountingAll","text":"CountingAll <: AbstractProperty\nCountingAll()\n\nCounting the total number of sets. e.g. for the IndependentSet problem, it counts the independent sets.\n\nThe corresponding tensor element type is Base.Real.\nThe weights on graph does not have effect.\nBLAS (GPU and CPU) and GPU are supported,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.CountingMax","page":"References","title":"GenericTensorNetworks.CountingMax","text":"CountingMax{K} <: AbstractProperty\nCountingMax(K=Single)\n\nCounting the number of sets with largest-K size. e.g. for IndependentSet problem, it counts independent sets of size alpha(G) alpha(G)-1 ldots alpha(G)-K+1.\n\nThe corresponding tensor element type is CountingTropical if K is Single, and TruncatedPoly{K} if K is an integer.\nWeighted graph problems is only supported if K is Single.\nGPU is supported,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.CountingMin","page":"References","title":"GenericTensorNetworks.CountingMin","text":"CountingMin{K} <: AbstractProperty\nCountingMin(K=Single)\n\nCounting the number of sets with smallest-K size.\n\nThe corresponding tensor element type is inverted CountingTropical if K is Single, and TruncatedPoly{K} if K is an integer.\nWeighted graph problems is only supported if K is Single.\nGPU is supported,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.GraphPolynomial","page":"References","title":"GenericTensorNetworks.GraphPolynomial","text":"GraphPolynomial{METHOD} <: AbstractProperty\nGraphPolynomial(; method=:finitefield, kwargs...)\n\nCompute the graph polynomial, e.g. for IndependentSet problem, it is the independence polynomial. The METHOD type parameter can be one of the following symbols\n\nMethod Argument\n\n:finitefield, uses finite field algebra to fit the polynomial.\nThe corresponding tensor element type is Mods.Mod,\nIt does not have round-off error,\nGPU is supported,\nIt accepts keyword arguments maxorder (optional, e.g. the MIS size in the IndependentSet problem).\n:polynomial, use polynomial numbers to solve the polynomial directly.\nThe corresponding tensor element type is Polynomial.\nIt might have small round-off error depending on the data type for storing the counting.\nIt has memory overhead that linear to the graph size.\n:fft, use fast fourier transformation to fit the polynomial.\nThe corresponding tensor element type is Base.Complex.\nIt has (controllable) round-off error.\nBLAS and GPU are supported.\nIt accepts keyword arguments maxorder (optional) and r,   if r > 1, one has better precision for coefficients of large order, if r < 1,   one has better precision for coefficients of small order.\n:fitting, fit the polynomial directly.\nThe corresponding tensor element type is floating point numbers like Base.Float64.\nIt has round-off error.\nBLAS and GPU are supported, it is the fastest among all methods.\n\nGraph polynomials are not defined for weighted graph problems.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.SingleConfigMax","page":"References","title":"GenericTensorNetworks.SingleConfigMax","text":"SingleConfigMax{K, BOUNDED} <: AbstractProperty\nSingleConfigMax(k::Int; bounded=false)\n\nFinding single solution for largest-K sizes, e.g. for IndependentSet problem, it is one of the maximum independent sets.\n\nThe corresponding data type is CountingTropical{Float64,<:ConfigSampler} if BOUNDED is false, Tropical otherwise.\nWeighted graph problems is supported.\nGPU is supported,\n\nKeyword Arguments\n\nbounded, if it is true, use bounding trick (or boolean gradients) to reduce the working memory to store intermediate configurations.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.SingleConfigMin","page":"References","title":"GenericTensorNetworks.SingleConfigMin","text":"SingleConfigMin{K, BOUNDED} <: AbstractProperty\nSingleConfigMin(k::Int; bounded=false)\n\nFinding single solution with smallest-K size.\n\nThe corresponding data type is inverted CountingTropical{Float64,<:ConfigSampler} if BOUNDED is false, inverted Tropical otherwise.\nWeighted graph problems is supported.\nGPU is supported,\n\nKeyword Arguments\n\nbounded, if it is true, use bounding trick (or boolean gradients) to reduce the working memory to store intermediate configurations.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.ConfigsAll","page":"References","title":"GenericTensorNetworks.ConfigsAll","text":"ConfigsAll{TREESTORAGE} <:AbstractProperty\nConfigsAll(; tree_storage=false)\n\nFind all valid configurations, e.g. for IndependentSet problem, it is finding all independent sets.\n\nThe corresponding data type is ConfigEnumerator.\nWeights do not take effect.\n\nKeyword Arguments\n\ntree_storage, if it is true, it uses more memory efficient tree-structure to store the configurations.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.ConfigsMax","page":"References","title":"GenericTensorNetworks.ConfigsMax","text":"ConfigsMax{K, BOUNDED, TREESTORAGE} <:AbstractProperty\nConfigsMax(K=Single; bounded=true, tree_storage=true)\n\nFind configurations with largest-K sizes, e.g. for IndependentSet problem, it is finding all independent sets of sizes alpha(G) alpha(G)-1 ldots alpha(G)-K+1.\n\nThe corresponding data type is CountingTropical{Float64,<:ConfigEnumerator} if K is Single and TruncatedPoly{K,<:ConfigEnumerator} if K is an integer.\nWeighted graph problems is only supported if K is Single.\n\nKeyword Arguments\n\nbounded, if it is true, use bounding trick (or boolean gradients) to reduce the working memory to store intermediate configurations.\ntree_storage, if it is true, it uses more memory efficient tree-structure to store the configurations.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.ConfigsMin","page":"References","title":"GenericTensorNetworks.ConfigsMin","text":"ConfigsMin{K, BOUNDED, TREESTORAGE} <:AbstractProperty\nConfigsMin(K=Single; bounded=true, tree_storage=false)\n\nFind configurations with smallest-K sizes.\n\nThe corresponding data type is inverted CountingTropical{Float64,<:ConfigEnumerator} if K is Single and inverted TruncatedPoly{K,<:ConfigEnumerator} if K is an integer.\nWeighted graph problems is only supported if K is Single.\n\nKeyword Arguments\n\nbounded, if it is true, use bounding trick (or boolean gradients) to reduce the working memory to store intermediate configurations.\ntree_storage, if it is true, it uses more memory efficient tree-structure to store the configurations.\n\n\n\n\n\n","category":"type"},{"location":"ref/#Element-Algebras","page":"References","title":"Element Algebras","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"is_commutative_semiring","category":"page"},{"location":"ref/#GenericTensorNetworks.is_commutative_semiring","page":"References","title":"GenericTensorNetworks.is_commutative_semiring","text":"is_commutative_semiring(a::T, b::T, c::T) where T\n\nCheck if elements a, b and c satisfied the commutative semiring requirements.\n\nbeginalign*\n(a oplus b) oplus c = a oplus (b oplus c)  hspace5emtrianglerighttextcommutative monoid oplus with identity mathbb0\na oplus mathbb0 = mathbb0 oplus a = a \na oplus b = b oplus a \n\n(a odot b) odot c = a odot (b odot c)     hspace5emtriangleright textcommutative monoid odot with identity mathbb1\na odot  mathbb1 =  mathbb1 odot a = a \na odot b = b odot a \n\na odot (boplus c) = aodot b oplus aodot c    hspace5emtriangleright textleft and right distributive\n(aoplus b) odot c = aodot c oplus bodot c \n\na odot mathbb0 = mathbb0 odot a = mathbb0\nendalign*\n\n\n\n\n\n","category":"function"},{"location":"ref/","page":"References","title":"References","text":"TropicalNumbers.Tropical\nTropicalNumbers.CountingTropical\nExtendedTropical\nMods.Mod\nTruncatedPoly\nMax2Poly\nConfigEnumerator\nSumProductTree\nConfigSampler","category":"page"},{"location":"ref/#TropicalNumbers.Tropical","page":"References","title":"TropicalNumbers.Tropical","text":"Tropical{T} <: Number\n\nTropical number is a semiring algebra that maps\n\n+ in regular algebra to max,\n* in regular algebra to +,\n1 in regular algebra to 0,\n0 in regular algebra to -Inf (for integer content types, this is chosen as a mall integer).\n\nWe implemented fast tropical matrix multiplication in TropicalGEMM.\n\nExample\n\njulia> Tropical(1.0) + Tropical(3.0)\n3.0ₜ\n\njulia> Tropical(1.0) * Tropical(3.0)\n4.0ₜ\n\njulia> one(TropicalF64)\n0.0ₜ\n\njulia> zero(TropicalF64)\n-Infₜ\n\n\n\n\n\n","category":"type"},{"location":"ref/#TropicalNumbers.CountingTropical","page":"References","title":"TropicalNumbers.CountingTropical","text":"CountingTropical{T,CT} <: Number\n\nCounting tropical number type is also a semiring algebra. It is tropical algebra with one extra field for counting, it is introduced in arXiv:2008.06888.\n\nExample\n\njulia> CountingTropical(1.0, 5.0) + CountingTropical(3.0, 2.0)\n(3.0, 2.0)ₜ\n\njulia> CountingTropical(1.0, 5.0) * CountingTropical(3.0, 2.0)\n(4.0, 10.0)ₜ\n\njulia> one(CountingTropicalF64)\n(0.0, 1.0)ₜ\n\njulia> zero(CountingTropicalF64)\n(-Inf, 0.0)ₜ\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.ExtendedTropical","page":"References","title":"GenericTensorNetworks.ExtendedTropical","text":"ExtendedTropical{K,TO} <: Number\nExtendedTropical{K}(orders)\n\nExtended Tropical numbers with largest K orders keeped, or the TruncatedPoly without coefficients, TO is the element type of orders, usually Tropical numbers. This algebra maps\n\n+ to finding largest K values of union of two sets.\n* to finding largest K values of sum combination of two sets.\n0 to set [-Inf, -Inf, ..., -Inf, -Inf]\n1 to set [-Inf, -Inf, ..., -Inf, 0]\n\nExample\n\njulia> x = ExtendedTropical{3}(Tropical.([1.0, 2, 3]))\nExtendedTropical{3, TropicalF64}(TropicalF64[1.0ₜ, 2.0ₜ, 3.0ₜ])\n\njulia> y = ExtendedTropical{3}(Tropical.([-Inf, 2, 5]))\nExtendedTropical{3, TropicalF64}(TropicalF64[-Infₜ, 2.0ₜ, 5.0ₜ])\n\njulia> x * y\nExtendedTropical{3, TropicalF64}(TropicalF64[6.0ₜ, 7.0ₜ, 8.0ₜ])\n\njulia> x + y\nExtendedTropical{3, TropicalF64}(TropicalF64[2.0ₜ, 3.0ₜ, 5.0ₜ])\n\njulia> one(x)\nExtendedTropical{3, TropicalF64}(TropicalF64[-Infₜ, -Infₜ, 0.0ₜ])\n\njulia> zero(x)\nExtendedTropical{3, TropicalF64}(TropicalF64[-Infₜ, -Infₜ, -Infₜ])\n\n\n\n\n\n","category":"type"},{"location":"ref/#Mods.Mod","page":"References","title":"Mods.Mod","text":"Mod{m}(v) creates a modular number in mod m with value mod(v,m).\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.TruncatedPoly","page":"References","title":"GenericTensorNetworks.TruncatedPoly","text":"TruncatedPoly{K,T,TO} <: Number\nTruncatedPoly(coeffs::Tuple, maxorder)\n\nPolynomial truncated to largest K orders. T is the coefficients type and TO is the orders type.\n\nExample\n\njulia> TruncatedPoly((1,2,3), 6)\nx^4 + 2*x^5 + 3*x^6\n\njulia> TruncatedPoly((1,2,3), 6) * TruncatedPoly((5,2,1), 3)\n20*x^7 + 8*x^8 + 3*x^9\n\njulia> TruncatedPoly((1,2,3), 6) + TruncatedPoly((5,2,1), 3)\nx^4 + 2*x^5 + 3*x^6\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.Max2Poly","page":"References","title":"GenericTensorNetworks.Max2Poly","text":"Max2Poly{T,TO} = TruncatedPoly{2,T,TO}\nMax2Poly(a, b, maxorder)\n\nA shorthand of TruncatedPoly{2}.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.ConfigEnumerator","page":"References","title":"GenericTensorNetworks.ConfigEnumerator","text":"ConfigEnumerator{N,S,C} <: AbstractSetNumber\n\nSet algebra for enumerating configurations, where N is the length of configurations, C is the size of storage in unit of UInt64, S is the bit width to store a single element in a configuration, i.e. log2(# of flavors), for bitstrings, it is 1`.\n\nExample\n\njulia> a = ConfigEnumerator([StaticBitVector([1,1,1,0,0]), StaticBitVector([1,0,0,0,1])])\n{11100, 10001}\n\njulia> b = ConfigEnumerator([StaticBitVector([0,0,0,0,0]), StaticBitVector([1,0,1,0,1])])\n{00000, 10101}\n\njulia> a + b\n{11100, 10001, 00000, 10101}\n\njulia> one(a)\n{00000}\n\njulia> zero(a)\n{}\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.SumProductTree","page":"References","title":"GenericTensorNetworks.SumProductTree","text":"SumProductTree{ET} <: AbstractSetNumber\n\nConfiguration enumerator encoded in a tree, it is the most natural representation given by a sum-product network and is often more memory efficient than putting the configurations in a vector. One can use generate_samples to sample configurations from this tree structure efficiently.\n\nFields\n\ntag is one of ZERO, ONE, LEAF, SUM, PROD.\ndata is the element stored in a LEAF node.\nleft and right are two operands of a SUM or PROD node.\n\nExample\n\njulia> s = SumProductTree(bv\"00111\")\n00111\n\n\njulia> q = SumProductTree(bv\"10000\")\n10000\n\n\njulia> x = s + q\n+ (count = 2.0)\n├─ 00111\n└─ 10000\n\n\njulia> y = x * x\n* (count = 4.0)\n├─ + (count = 2.0)\n│  ├─ 00111\n│  └─ 10000\n└─ + (count = 2.0)\n   ├─ 00111\n   └─ 10000\n\n\njulia> collect(y)\n4-element Vector{StaticBitVector{5, 1}}:\n 00111\n 10111\n 10111\n 10000\n\njulia> zero(s)\n∅\n\n\n\njulia> one(s)\n00000\n\n\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.ConfigSampler","page":"References","title":"GenericTensorNetworks.ConfigSampler","text":"ConfigSampler{N,S,C} <: AbstractSetNumber\nConfigSampler(elements::StaticElementVector)\n\nThe algebra for sampling one configuration, where N is the length of configurations, C is the size of storage in unit of UInt64, S is the bit width to store a single element in a configuration, i.e. log2(# of flavors), for bitstrings, it is 1`.\n\nnote: Note\nConfigSampler is a probabilistic commutative semiring, adding two config samplers do not give you deterministic results.\n\nExample\n\njulia> ConfigSampler(StaticBitVector([1,1,1,0,0]))\nConfigSampler{5, 1, 1}(11100)\n\njulia> ConfigSampler(StaticBitVector([1,1,1,0,0])) + ConfigSampler(StaticBitVector([1,0,1,0,0]))\nConfigSampler{5, 1, 1}(10100)\n\njulia> ConfigSampler(StaticBitVector([1,1,1,0,0])) * ConfigSampler(StaticBitVector([0,0,0,0,1]))\nConfigSampler{5, 1, 1}(11101)\n\njulia> one(ConfigSampler{5, 1, 1})\nConfigSampler{5, 1, 1}(00000)\n\njulia> zero(ConfigSampler{5, 1, 1})\nConfigSampler{5, 1, 1}(11111)\n\n\n\n\n\n","category":"type"},{"location":"ref/","page":"References","title":"References","text":"GenericTensorNetworks also exports the Polynomial type defined in package Polynomials.","category":"page"},{"location":"ref/","page":"References","title":"References","text":"StaticBitVector\nStaticElementVector\nOnehotVec\nsave_configs\nload_configs\nsave_sumproduct\nload_sumproduct\n@bv_str\nonehotv\n\ngenerate_samples\nhamming_distribution","category":"page"},{"location":"ref/#GenericTensorNetworks.StaticBitVector","page":"References","title":"GenericTensorNetworks.StaticBitVector","text":"StaticBitVector{N,C} = StaticElementVector{N,1,C}\nStaticBitVector(x::AbstractVector)\n\nExample\n\njulia> sb = StaticBitVector([1,0,0,1,1])\n10011\n\njulia> sb[3]\n0x0000000000000000\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.StaticElementVector","page":"References","title":"GenericTensorNetworks.StaticElementVector","text":"StaticElementVector{N,S,C}\nStaticElementVector(nflavor::Int, x::AbstractVector)\n\nN is the length of vector, C is the size of storage in unit of UInt64, S is the stride defined as the log2(# of flavors). When the number of flavors is 2, it is a StaticBitVector.\n\nExample\n\njulia> ev = StaticElementVector(3, [1,2,0,1,2])\n12012\n\njulia> ev[2]\n0x0000000000000002\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.OnehotVec","page":"References","title":"GenericTensorNetworks.OnehotVec","text":"OnehotVec{N,NF}\nOnehotVec{N,NF}(loc, val)\n\nOnehot vector type, N is the number of vector length, NF is the number of flavors.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.save_configs","page":"References","title":"GenericTensorNetworks.save_configs","text":"save_configs(filename, data::ConfigEnumerator; format=:binary)\n\nSave configurations data to file filename. The format is :binary or :text.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.load_configs","page":"References","title":"GenericTensorNetworks.load_configs","text":"load_configs(filename; format=:binary, bitlength=nothing, nflavors=2)\n\nLoad configurations from file filename. The format is :binary or :text. If the format is :binary, the bitstring length bitlength must be specified, nflavors specifies the degree of freedom.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.save_sumproduct","page":"References","title":"GenericTensorNetworks.save_sumproduct","text":"save_sumproduct(filename, t::SumProductTree)\n\nSerialize a sum-product tree into a file.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.load_sumproduct","page":"References","title":"GenericTensorNetworks.load_sumproduct","text":"load_sumproduct(filename)\n\nDeserialize a sum-product tree from a file.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.@bv_str","page":"References","title":"GenericTensorNetworks.@bv_str","text":"Constructing a static bit vector.\n\n\n\n\n\n","category":"macro"},{"location":"ref/#GenericTensorNetworks.onehotv","page":"References","title":"GenericTensorNetworks.onehotv","text":"onehotv(::Type{<:StaticElementVector}, i, v)\nonehotv(::Type{<:StaticBitVector, i)\n\nReturns a static element vector, with the value at location i being v (1 if not specified).\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.generate_samples","page":"References","title":"GenericTensorNetworks.generate_samples","text":"generate_samples(t::SumProductTree, nsamples::Int)\n\nDirect sampling configurations from a SumProductTree instance.\n\nExample\n\njulia> using Graphs\n\njulia> g= smallgraph(:petersen)\n{10, 15} undirected simple Int64 graph\n\njulia> t = solve(IndependentSet(g), ConfigsAll(; tree_storage=true))[];\n\njulia> samples = generate_samples(t, 1000);\n\njulia> all(s->is_independent_set(g, s), samples)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.hamming_distribution","page":"References","title":"GenericTensorNetworks.hamming_distribution","text":"hamming_distribution(S, T)\n\nCompute the distribution of pair-wise Hamming distances, which is defined as:\n\nc(k) = sum_sigmain S tauin T delta(rm dist(sigma tau) k)\n\nwhere delta is a function that returns 1 if two arguments are equivalent, 0 otherwise, rm dist is the Hamming distance function.\n\nReturns the counting as a vector.\n\n\n\n\n\n","category":"function"},{"location":"ref/#Tensor-Network","page":"References","title":"Tensor Network","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"optimize_code\ngetixsv\ngetiyv\ntimespace_complexity\ntimespacereadwrite_complexity\nestimate_memory\n@ein_str\nGreedyMethod\nTreeSA\nSABipartite\nKaHyParBipartite\nMergeVectors\nMergeGreedy","category":"page"},{"location":"ref/#OMEinsumContractionOrders.optimize_code","page":"References","title":"OMEinsumContractionOrders.optimize_code","text":"optimize_code(eincode, size_dict, optimizer = GreedyMethod(), simplifier=nothing, permute=true)\n\nOptimize the einsum contraction code and reduce the time/space complexity of tensor network contraction. Returns a NestedEinsum instance. Input arguments are\n\neincode is an einsum contraction code instance, one of DynamicEinCode, StaticEinCode or NestedEinsum.\nsize is a dictionary of \"edge label=>edge size\" that contains the size information, one can use uniformsize(eincode, 2) to create a uniform size.\noptimizer is a CodeOptimizer instance, should be one of GreedyMethod, KaHyParBipartite, SABipartite or TreeSA. Check their docstrings for details.\nsimplifier is one of MergeVectors or MergeGreedy.\noptimize the permutation if permute is true.\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsum.getixsv","page":"References","title":"OMEinsum.getixsv","text":"getixsv(code)\n\nGet labels of input tensors for EinCode, NestedEinsum and some other einsum like objects. Returns a vector of vector.\n\njulia> getixsv(ein\"(ij,jk),k->i\")\n3-element Vector{Vector{Char}}:\n ['i', 'j']\n ['j', 'k']\n ['k']\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsum.getiyv","page":"References","title":"OMEinsum.getiyv","text":"getiy(code)\n\nGet labels of the output tensor for EinCode, NestedEinsum and some other einsum like objects. Returns a vector.\n\njulia> getiyv(ein\"(ij,jk),k->i\")\n1-element Vector{Char}:\n 'i': ASCII/Unicode U+0069 (category Ll: Letter, lowercase)\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsum.timespace_complexity","page":"References","title":"OMEinsum.timespace_complexity","text":"timespace_complexity(eincode, size_dict)\n\nReturns the time and space complexity of the einsum contraction. The time complexity is defined as log2(number of element multiplication). The space complexity is defined as log2(size of the maximum intermediate tensor).\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsum.timespacereadwrite_complexity","page":"References","title":"OMEinsum.timespacereadwrite_complexity","text":"timespacereadwrite_complexity(eincode, size_dict)\n\nReturns the time, space and read-write complexity of the einsum contraction. The time complexity is defined as log2(number of element-wise multiplication). The space complexity is defined as log2(size of the maximum intermediate tensor). The read-write complexity is defined as log2(the number of read-write operations).\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.estimate_memory","page":"References","title":"GenericTensorNetworks.estimate_memory","text":"estimate_memory(problem, property; T=Float64)\n\nMemory estimation in number of bytes to compute certain property of a problem. T is the base type.\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsum.@ein_str","page":"References","title":"OMEinsum.@ein_str","text":"ein\"ij,jk -> ik\"(A,B)\n\nString macro interface which understands numpy.einsum's notation. Translates strings into StaticEinCode-structs that can be called to evaluate an einsum. To control evaluation order, use parentheses - instead of an EinCode, a NestedEinsum is returned which evaluates the expression according to parens. The valid character ranges for index-labels are a-z and α-ω.\n\nexample\n\njulia> a, b, c = rand(10,10), rand(10,10), rand(10,1);\n\njulia> ein\"ij,jk,kl -> il\"(a,b,c) ≈ ein\"(ij,jk),kl -> il\"(a,b,c) ≈ a * b * c\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"ref/#OMEinsumContractionOrders.GreedyMethod","page":"References","title":"OMEinsumContractionOrders.GreedyMethod","text":"GreedyMethod{MT}\nGreedyMethod(; method=MinSpaceOut(), nrepeat=10)\n\nThe fast but poor greedy optimizer. Input arguments are\n\nmethod is MinSpaceDiff() or MinSpaceOut.\nMinSpaceOut choose one of the contraction that produces a minimum output tensor size,\nMinSpaceDiff choose one of the contraction that decrease the space most.\nnrepeat is the number of repeatition, returns the best contraction order.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.TreeSA","page":"References","title":"OMEinsumContractionOrders.TreeSA","text":"TreeSA{RT,IT,GM}\nTreeSA(; sc_target=20, βs=collect(0.01:0.05:15), ntrials=10, niters=50,\n    sc_weight=1.0, rw_weight=0.2, initializer=:greedy, greedy_config=GreedyMethod(; nrepeat=1))\n\nOptimize the einsum contraction pattern using the simulated annealing on tensor expression tree.\n\nsc_target is the target space complexity,\nntrials, βs and niters are annealing parameters, doing ntrials indepedent annealings, each has inverse tempteratures specified by βs, in each temperature, do niters updates of the tree.\nsc_weight is the relative importance factor of space complexity in the loss compared with the time complexity.\nrw_weight is the relative importance factor of memory read and write in the loss compared with the time complexity.\ninitializer specifies how to determine the initial configuration, it can be :greedy or :random. If it is using :greedy method to generate the initial configuration, it also uses two extra arguments greedy_method and greedy_nrepeat.\nnslices is the number of sliced legs, default is 0.\nfixed_slices is a vector of sliced legs, default is [].\n\nReferences\n\nRecursive Multi-Tensor Contraction for XEB Verification of Quantum Circuits\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.SABipartite","page":"References","title":"OMEinsumContractionOrders.SABipartite","text":"SABipartite{RT,BT}\nSABipartite(; sc_target=25, ntrials=50, βs=0.1:0.2:15.0, niters=1000\n    max_group_size=40, greedy_config=GreedyMethod(), initializer=:random)\n\nOptimize the einsum code contraction order using the Simulated Annealing bipartition + Greedy approach. This program first recursively cuts the tensors into several groups using simulated annealing, with maximum group size specifed by max_group_size and maximum space complexity specified by sc_target, Then finds the contraction order inside each group with the greedy search algorithm. Other arguments are\n\nsize_dict, a dictionary that specifies leg dimensions,\nsc_target is the target space complexity, defined as log2(number of elements in the largest tensor),\nmax_group_size is the maximum size that allowed to used greedy search,\nβs is a list of inverse temperature 1/T,\nniters is the number of iteration in each temperature,\nntrials is the number of repetition (with different random seeds),\ngreedy_config configures the greedy method,\ninitializer, the partition configuration initializer, one can choose :random or :greedy (slow but better).\n\nReferences\n\nHyper-optimized tensor network contraction\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.KaHyParBipartite","page":"References","title":"OMEinsumContractionOrders.KaHyParBipartite","text":"KaHyParBipartite{RT,IT,GM}\nKaHyParBipartite(; sc_target, imbalances=collect(0.0:0.005:0.8),\n    max_group_size=40, greedy_config=GreedyMethod())\n\nOptimize the einsum code contraction order using the KaHyPar + Greedy approach. This program first recursively cuts the tensors into several groups using KaHyPar, with maximum group size specifed by max_group_size and maximum space complexity specified by sc_target, Then finds the contraction order inside each group with the greedy search algorithm. Other arguments are\n\nsc_target is the target space complexity, defined as log2(number of elements in the largest tensor),\nimbalances is a KaHyPar parameter that controls the group sizes in hierarchical bipartition,\nmax_group_size is the maximum size that allowed to used greedy search,\ngreedy_config is a greedy optimizer.\n\nReferences\n\nHyper-optimized tensor network contraction\nSimulating the Sycamore quantum supremacy circuits\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.MergeVectors","page":"References","title":"OMEinsumContractionOrders.MergeVectors","text":"MergeVectors <: CodeSimplifier\nMergeVectors()\n\nContraction code simplifier (in order to reduce the time of calling optimizers) that merges vectors to closest tensors.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.MergeGreedy","page":"References","title":"OMEinsumContractionOrders.MergeGreedy","text":"MergeGreedy <: CodeSimplifier\nMergeGreedy(; threshhold=-1e-12)\n\nContraction code simplifier (in order to reduce the time of calling optimizers) that merges tensors greedily if the space complexity of merged tensors is reduced (difference smaller than the threshhold).\n\n\n\n\n\n","category":"type"},{"location":"ref/#Others","page":"References","title":"Others","text":"","category":"section"},{"location":"ref/#Graph","page":"References","title":"Graph","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"show_graph\nshow_gallery\nspring_layout\n\ndiagonal_coupled_graph\nsquare_lattice_graph\nunit_disk_graph\nline_graph\n\nrandom_diagonal_coupled_graph\nrandom_square_lattice_graph","category":"page"},{"location":"ref/#GenericTensorNetworks.show_graph","page":"References","title":"GenericTensorNetworks.show_graph","text":"show_graph(graph;\n    locs=spring_layout(graph),\n    vertex_colors=[\"black\", \"black\", ...],\n    edge_colors=[\"black\", \"black\", ...],\n    texts=[\"1\", \"2\", ...],\n    format=SVG,\n    io=nothing,\n    kwargs...\n    )\n\nShow a graph featured with vertex and edge information.\n\nPositional arguments\n\ngraph is a graph instance.\n\nKeyword arguments\n\nlocs is a vector of tuples for specifying the vertex locations.\nvertex_colors is a vector of color strings for specifying vertex configurations, e.g. a ConfigEnumerator instance.\nedge_colors is a vector of color strings for specifying edge configurations.\ntexts is a vector of strings for labeling vertices.\nformat is the output format, which can be Compose.SVG, Compose.PNG, Compose.PDF et al. Check the Compose documentation for details.\nio can be nothing for the direct output, or a filename to saving to a file. For direct output, you will need a VSCode editor, an Atom editor, a Pluto notebook or a Jupyter notebook to display the image.\n\nExtra keyword arguments\n\nline, vertex and text\nscale::Float64 = 1.0\npad::Float64 = 1.5\nvertex\nvertex_text_color::String = \"black\"\nvertex_stroke_color = \"black\"\nvertex_fill_color = \"white\"\nedge\nedge_color::String = \"black\"\nimage size in cm\nimage_size::Float64 = 12\n\nExample\n\njulia> using Graphs, GenericTensorNetworks, Compose\n\njulia> show_graph(smallgraph(:petersen); format=Compose.SVG, io=tempname(), vertex_colors=rand([\"blue\", \"red\"], 10));\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.show_gallery","page":"References","title":"GenericTensorNetworks.show_gallery","text":"show_gallery(graph::SimpleGraph, grid::Tuple{Int,Int};\n    locs=spring_layout(graph), \n    vertex_configs=nothing,\n    edge_configs=nothing,\n    texts=[\"1\", \"2\", ...],\n    format=SVG,\n    io=nothing,\n    kwargs...)\n\nShow a gallery of graphs for multiple vertex configurations or edge configurations.\n\nPositional arguments\n\ngraph is a graph instance.\ngrid is the grid layout of the gallery, e.g. input value (2, 3) means a grid layout with 2 rows and 3 columns.\n\nKeyword arguments\n\nlocs is a vector of tuples for specifying the vertex locations.\nvertex_configs is an iterator of bit strings for specifying vertex configurations, e.g. a ConfigEnumerator instance.\nedge_configs is an iterator of bit strings for specifying edge configurations.\ntexts is a vector of strings for labeling vertices.\nformat is the output format, which can be Compose.SVG, Compose.PNG, Compose.PDF et al. Check the Compose documentation for details.\nio can be nothing for the direct output, or a filename to saving to a file. For direct output, you will need a VSCode editor, an Atom editor, a Pluto notebook or a Jupyter notebook to display the image.\n\nExtra keyword arguments\n\nline, vertex and text\nscale::Float64 = 1.0\npad::Float64 = 1.5\nvertex\nvertex_text_color::String = \"black\"\nvertex_stroke_color = \"black\"\nvertex_fill_color = \"white\"\nedge\nedge_color::String = \"black\"\nimage size in cm\nimage_size::Float64 = 12\n\nExample\n\njulia> using Graphs, GenericTensorNetworks, Compose\n\njulia> show_gallery(smallgraph(:petersen), (2, 3); format=Compose.SVG, io=tempname(), vertex_configs=[rand(Bool, 10) for k=1:6]);\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.spring_layout","page":"References","title":"GenericTensorNetworks.spring_layout","text":"Spring layout for graph plotting, returns a vector of vertex locations.\n\nnote: Note\nThis function is copied from GraphPlot.jl, where you can find more information about his function.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.diagonal_coupled_graph","page":"References","title":"GenericTensorNetworks.diagonal_coupled_graph","text":"diagonal_coupled_graph(mask::AbstractMatrix{Bool})\n\nCreate a masked diagonal coupled square lattice graph from a specified mask.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.square_lattice_graph","page":"References","title":"GenericTensorNetworks.square_lattice_graph","text":"square_lattice_graph(mask::AbstractMatrix{Bool})\n\nCreate a masked square lattice graph.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.unit_disk_graph","page":"References","title":"GenericTensorNetworks.unit_disk_graph","text":"unit_disk_graph(locs::AbstractVector, unit::Real)\n\nCreate a unit disk graph with locations specified by locs and unit distance unit.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.line_graph","page":"References","title":"GenericTensorNetworks.line_graph","text":"line_graph(g::SimpleGraph)\n\nReturns the line graph of g. The line graph is generated by mapping an edge to a vertex and two edges sharing a common vertex will be connected.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.random_diagonal_coupled_graph","page":"References","title":"GenericTensorNetworks.random_diagonal_coupled_graph","text":"random_diagonal_coupled_graph(m::Int, n::Int, ρ::Real)\n\nCreate a mtimes n random masked diagonal coupled square lattice graph,  with number of vertices equal to lfloor m times ntimes rho rceil.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.random_square_lattice_graph","page":"References","title":"GenericTensorNetworks.random_square_lattice_graph","text":"random_square_lattice_graph(m::Int, n::Int, ρ::Real)\n\nCreate a random masked square lattice graph, with number of vertices fixed to lfloor mnrho rceil.\n\n\n\n\n\n","category":"function"},{"location":"ref/","page":"References","title":"References","text":"One can also use random_regular_graph and smallgraph in Graphs to build special graphs.","category":"page"},{"location":"ref/#Multiprocessing","page":"References","title":"Multiprocessing","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"GenericTensorNetworks.SimpleMultiprocessing.multiprocess_run","category":"page"},{"location":"ref/#GenericTensorNetworks.SimpleMultiprocessing.multiprocess_run","page":"References","title":"GenericTensorNetworks.SimpleMultiprocessing.multiprocess_run","text":"multiprocess_run(func, inputs::AbstractVector)\n\nExecute function func on inputs with multiple processing.\n\nExample\n\nSuppose we have a file run.jl with the following contents\n\nusing GenericTensorNetworks.SimpleMultiprocessing\n\nresults = multiprocess_run(x->x^2, randn(8))\n\nIn an terminal, you may run the script with 4 processes by typing\n\n$ julia -p4 run.jl\n      From worker 2:\t[ Info: running argument -0.17544008350172655 on device 2\n      From worker 5:\t[ Info: running argument 0.34578117779452555 on device 5\n      From worker 3:\t[ Info: running argument 2.0312551239727705 on device 3\n      From worker 4:\t[ Info: running argument -0.7319353419291961 on device 4\n      From worker 2:\t[ Info: running argument 0.013132180639054629 on device 2\n      From worker 3:\t[ Info: running argument 0.9960101782201602 on device 3\n      From worker 4:\t[ Info: running argument -0.5613942832743966 on device 4\n      From worker 5:\t[ Info: running argument 0.39460402723831134 on device 5\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GenericTensorNetworks","category":"page"},{"location":"#GenericTensorNetworks","page":"Home","title":"GenericTensorNetworks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package implements generic tensor networks to compute solution space properties of a class of hard combinatorial problems. The solution space properties include","category":"page"},{"location":"","page":"Home","title":"Home","text":"The maximum/minimum solution sizes,\nThe number of solutions at certain sizes,\nThe enumeration of solutions at certain sizes.\nThe direct sampling of solutions at certain sizes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The solvable problems include Independent set problem, Maximal independent set problem, Cutting problem (Spin-glass problem), Vertex matching problem, Binary paint shop problem, Coloring problem, Dominating set problem, Satisfiability problem, Set packing problem and Set covering problem.","category":"page"},{"location":"#Background-knowledge","page":"Home","title":"Background knowledge","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please check our paper \"Computing properties of independent sets by generic programming tensor networks\"(paper to be released soon). If you find our paper or software useful in your work, we would be grateful if you could cite our work. The CITATION.bib file in the root of this repository lists the relevant papers.","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can find a set up guide in our README. To get started, open a Julia REPL and type the following code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using GenericTensorNetworks, Graphs\n\njulia> # using CUDA\n\njulia> solve(\n           IndependentSet(\n               Graphs.random_regular_graph(20, 3);\n               optimizer = TreeSA(),\n               weights = NoWeight(),  # the default value\n               openvertices = ()      # the default value\n           ),\n           GraphPolynomial();\n           usecuda=false              # the default value\n       )\n0-dimensional Array{Polynomial{BigInt, :x}, 0}:\nPolynomial(1 + 20*x + 160*x^2 + 659*x^3 + 1500*x^4 + 1883*x^5 + 1223*x^6 + 347*x^7 + 25*x^8)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here the main function solve takes three input arguments, the problem instance of type IndependentSet, the property instance of type GraphPolynomial and an optional key word argument usecuda to decide use GPU or not. If one wants to use GPU to accelerate the computation, the using CUDA statement must uncommented.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The problem instance takes four arguments to initialize, the only positional argument is the graph instance that one wants to solve, the key word argument optimizer is for specifying the tensor network optimization algorithm, the key word argument weights is for specifying the weights of vertices as either a vector or NoWeight() and the keyword argument openvertices is for specifying the degrees of freedom not summed over. Here, we use TreeSA method as the tensor network optimizer, and leave weights and openvertices the default values. The TreeSA method finds the best contraction order in most of our applications, while the default GreedyMethod runs the fastest.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The first execution of this function will be a bit slow due to Julia's just in time compiling. The subsequent runs will be fast. The following diagram lists possible combinations of input arguments, where functions in the Graph are mainly defined in the package Graphs, and the rest can be found in this package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div align=center>\n<img src=\"assets/fig7.svg\" width=\"75%\"/>\n</div>","category":"page"},{"location":"","page":"Home","title":"Home","text":"⠀ You can find many examples in this documentation, a good one to start with is Independent set problem.","category":"page"}]
}
