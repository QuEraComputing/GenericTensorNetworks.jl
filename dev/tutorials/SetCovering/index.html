<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Set covering problem · GenericTensorNetworks.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://QuEraComputing.github.io/GenericTensorNetworks.jl/tutorials/SetCovering/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GenericTensorNetworks.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Problems</span><ul><li><a class="tocitem" href="../IndependentSet/">Independent set problem</a></li><li><a class="tocitem" href="../MaximalIS/">Maximal independent set problem</a></li><li><a class="tocitem" href="../MaxCut/">Cutting problem</a></li><li><a class="tocitem" href="../Matching/">Vertex Matching problem</a></li><li><a class="tocitem" href="../PaintShop/">Binary paint shop problem</a></li><li><a class="tocitem" href="../Coloring/">Coloring problem</a></li><li><a class="tocitem" href="../DominatingSet/">Dominating set problem</a></li><li><a class="tocitem" href="../Satisfiability/">Satisfiability problem</a></li><li class="is-active"><a class="tocitem" href>Set covering problem</a><ul class="internal"><li><a class="tocitem" href="#Problem-definition"><span>Problem definition</span></a></li><li><a class="tocitem" href="#Generic-tensor-network-representation"><span>Generic tensor network representation</span></a></li><li><a class="tocitem" href="#Solving-properties"><span>Solving properties</span></a></li></ul></li><li><a class="tocitem" href="../SetPacking/">Set packing problem</a></li></ul></li><li><span class="tocitem">Topics</span><ul><li><a class="tocitem" href="../saveload/">Save and load solutions</a></li><li><a class="tocitem" href="../../sumproduct/">Sum product tree representation</a></li><li><a class="tocitem" href="../weighted/">Weighted problems</a></li><li><a class="tocitem" href="../open/">Open degree of freedoms</a></li></ul></li><li><a class="tocitem" href="../../performancetips/">Performance Tips</a></li><li><a class="tocitem" href="../../ref/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Problems</a></li><li class="is-active"><a href>Set covering problem</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Set covering problem</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/QuEraComputing/GenericTensorNetworks.jl/blob/master/examples/SetCovering.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Set-covering-problem"><a class="docs-heading-anchor" href="#Set-covering-problem">Set covering problem</a><a id="Set-covering-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Set-covering-problem" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is highly recommended to read the <a href="../IndependentSet/#Independent-set-problem">Independent set problem</a> chapter before reading this one.</p></div></div><h2 id="Problem-definition"><a class="docs-heading-anchor" href="#Problem-definition">Problem definition</a><a id="Problem-definition-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-definition" title="Permalink"></a></h2><p>The <a href="https://en.wikipedia.org/wiki/Set_cover_problem">set covering problem</a> is a significant NP-hard problem in combinatorial optimization. Given a collection of elements, the set covering problem aims to find the minimum number of sets that incorporate (cover) all of these elements. In the following, we will find the solution space properties for the camera location and stadium area example in the <a href="https://optimization.cbe.cornell.edu/index.php?title=Set_covering_problem">Cornell University Computational Optimization Open Textbook</a>.</p><pre><code class="language-julia hljs">using GenericTensorNetworks, Graphs</code></pre><p>The covering stadium areas of cameras are represented as the following sets.</p><pre><code class="language-julia hljs">sets = [[1,3,4,6,7], [4,7,8,12], [2,5,9,11,13],
    [1,2,14,15], [3,6,10,12,14], [8,14,15],
    [1,2,6,11], [1,2,4,6,8,12]]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8-element Vector{Vector{Int64}}:
 [1, 3, 4, 6, 7]
 [4, 7, 8, 12]
 [2, 5, 9, 11, 13]
 [1, 2, 14, 15]
 [3, 6, 10, 12, 14]
 [8, 14, 15]
 [1, 2, 6, 11]
 [1, 2, 4, 6, 8, 12]</code></pre><h2 id="Generic-tensor-network-representation"><a class="docs-heading-anchor" href="#Generic-tensor-network-representation">Generic tensor network representation</a><a id="Generic-tensor-network-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-tensor-network-representation" title="Permalink"></a></h2><p>We create a [<code>SetCovering</code>] instance that contains a generic tensor network as its <code>code</code> field.</p><pre><code class="language-julia hljs">problem = SetCovering(sets);</code></pre><h3 id="Theory-(can-skip)"><a class="docs-heading-anchor" href="#Theory-(can-skip)">Theory (can skip)</a><a id="Theory-(can-skip)-1"></a><a class="docs-heading-anchor-permalink" href="#Theory-(can-skip)" title="Permalink"></a></h3><p>Let <span>$S$</span> be the target set covering problem that we want to solve. For each set <span>$s \in S$</span>, we associate it with a weight <span>$w_s$</span> to it. The tensor network representation map a set <span>$s\in S$</span> to a boolean degree of freedom <span>$v_s\in\{0, 1\}$</span>. For each set <span>$s$</span>, we defined a parameterized rank-one tensor indexed by <span>$v_s$</span> as</p><p class="math-container">\[W(x_s^{w_s}) = \left(\begin{matrix}
    1 \\
    x_s^{w_s}
    \end{matrix}\right)\]</p><p>where <span>$x_s$</span> is a variable associated with <span>$s$</span>. For each unique element <span>$a$</span>, we defined the constraint over all sets containing it <span>$N(a) = \{s | s \in S \land a\in s\}$</span>:</p><p class="math-container">\[B_{s_1,s_2,\ldots,s_{|N(a)|}} = \begin{cases}
    0 &amp; s_1=s_2=\ldots=s_{|N(a)|}=0,\\
    1 &amp; \text{otherwise}.
\end{cases}\]</p><p>This tensor means if none of the sets containing element <span>$a$</span> are included, then this configuration is forbidden, One can check the contraction time space complexity of a <a href="../../ref/#GenericTensorNetworks.SetCovering"><code>SetCovering</code></a> instance by typing:</p><pre><code class="language-julia hljs">timespacereadwrite_complexity(problem)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(8.845490050944376, 4.0, 10.130570562805428)</code></pre><h2 id="Solving-properties"><a class="docs-heading-anchor" href="#Solving-properties">Solving properties</a><a id="Solving-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-properties" title="Permalink"></a></h2><h3 id="Counting-properties"><a class="docs-heading-anchor" href="#Counting-properties">Counting properties</a><a id="Counting-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Counting-properties" title="Permalink"></a></h3><h5 id="The-&quot;graph&quot;-polynomial"><a class="docs-heading-anchor" href="#The-&quot;graph&quot;-polynomial">The &quot;graph&quot; polynomial</a><a id="The-&quot;graph&quot;-polynomial-1"></a><a class="docs-heading-anchor-permalink" href="#The-&quot;graph&quot;-polynomial" title="Permalink"></a></h5><p>The graph polynomial for the set covering problem is defined as</p><p class="math-container">\[P(S, x) = \sum_{k=0}^{|S|} c_k x^k,\]</p><p>where <span>$c_k$</span> is the number of configurations having <span>$k$</span> sets.</p><pre><code class="language-julia hljs">covering_polynomial = solve(problem, GraphPolynomial())[]</code></pre>2&#8729;x<sup>4</sup> &#43; 11&#8729;x<sup>5</sup> &#43; 13&#8729;x<sup>6</sup> &#43; 6&#8729;x<sup>7</sup> &#43; x<sup>8</sup><p>The minimum number of sets that covering the set of elements can be computed with the <a href="../../ref/#GenericTensorNetworks.SizeMin"><code>SizeMin</code></a> property:</p><pre><code class="language-julia hljs">min_cover_size = solve(problem, SizeMin())[]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4.0ₜ</code></pre><p>Similarly, we have its counting <a href="../../ref/#GenericTensorNetworks.CountingMin"><code>CountingMin</code></a>:</p><pre><code class="language-julia hljs">counting_minimum_setcovering = solve(problem, CountingMin())[]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(4.0, 2.0)ₜ</code></pre><h3 id="Configuration-properties"><a class="docs-heading-anchor" href="#Configuration-properties">Configuration properties</a><a id="Configuration-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Configuration-properties" title="Permalink"></a></h3><h5 id="Finding-minimum-set-covering"><a class="docs-heading-anchor" href="#Finding-minimum-set-covering">Finding minimum set covering</a><a id="Finding-minimum-set-covering-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-minimum-set-covering" title="Permalink"></a></h5><p>One can enumerate all minimum set covering with the <a href="../../ref/#GenericTensorNetworks.ConfigsMin"><code>ConfigsMin</code></a> property in the program.</p><pre><code class="language-julia hljs">min_configs = solve(problem, ConfigsMin())[].c</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">{01111000, 10101100}</code></pre><p>Hence the two optimal solutions are <span>$\{z_1, z_3, z_5, z_6\}$</span> and <span>$\{z_2, z_3, z_4, z_5\}$</span>. The correctness of this result can be checked with the <a href="../../ref/#GenericTensorNetworks.is_set_covering"><code>is_set_covering</code></a> function.</p><pre><code class="language-julia hljs">all(c-&gt;is_set_covering(sets, c), min_configs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Similarly, if one is only interested in computing one of the minimum set coverings, one can use the graph property <a href="../../ref/#GenericTensorNetworks.SingleConfigMin"><code>SingleConfigMin</code></a>.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Satisfiability/">« Satisfiability problem</a><a class="docs-footer-nextpage" href="../SetPacking/">Set packing problem »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Tuesday 12 April 2022 22:08">Tuesday 12 April 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
