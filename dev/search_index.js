var documenterSearchIndex = {"docs":
[{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"EditURL = \"../../../examples/IndependentSet.jl\"","category":"page"},{"location":"generated/IndependentSet/#Independent-Set-Problem","page":"Independent set problem","title":"Independent Set Problem","text":"","category":"section"},{"location":"generated/IndependentSet/#Overview","page":"Independent set problem","title":"Overview","text":"","category":"section"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"This example demonstrates how to solve the Independent Set problem using tensor networks. An independent set is a set of vertices in a graph where no two vertices are adjacent. We'll explore this problem using the Petersen graph as our example.","category":"page"},{"location":"generated/IndependentSet/#Problem-definition","page":"Independent set problem","title":"Problem definition","text":"","category":"section"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"In graph theory, an independent set is a set of vertices in a graph, no two of which are adjacent.","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"In the following, we are going to solve the solution space properties of the independent set problem on the Petersen graph. To start, let us define a Petersen graph instance.","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"using GenericTensorNetworks, Graphs\n\ngraph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"We can visualize this graph using the show_graph function","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"# set the vertex locations manually instead of using the default spring layout\nrot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\nlocations = [[rot15(0.0, 60.0, i) for i=0:4]..., [rot15(0.0, 30, i) for i=0:4]...]\nshow_graph(graph, locations; format=:svg)","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"The graphical display is available in the following editors","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"a VSCode editor,\na Jupyter notebook,\nor a Pluto notebook,","category":"page"},{"location":"generated/IndependentSet/#Tensor-Network-Formulation","page":"Independent set problem","title":"Tensor Network Formulation","text":"","category":"section"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"We represent the independent set problem using a tensor network approach. This allows us to efficiently compute various properties of the solution space.","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"iset = IndependentSet(graph)","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"The problem has two main components:","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"Independence constraints: Ensure no adjacent vertices are selected\nOptimization objective: Maximize the size of the independent set","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"constraints(iset)","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"objectives(iset)","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"The tensor network representation of the independent set problem can be obtained by","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"problem = GenericTensorNetwork(iset; optimizer=TreeSA())","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"where the key word argument optimizer specifies the tensor network contraction order optimizer as a local search based optimizer TreeSA.","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"Here, the key word argument optimizer specifies the tensor network contraction order optimizer as a local search based optimizer TreeSA. The resulting contraction order optimized tensor network is contained in the code field of problem.","category":"page"},{"location":"generated/IndependentSet/#Mathematical-Background","page":"Independent set problem","title":"Mathematical Background","text":"","category":"section"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"Let G=(V E) be a graph with each vertex vin V associated with a weight w_v. To reduce the independent set problem on it to a tensor network contraction, we first map a vertex vin V to a label s_v in 0 1 of dimension 2, where we use 0 (1) to denote a vertex absent (present) in the set. For each vertex v, we defined a parameterized rank-one tensor indexed by s_v as","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"W(x_v^w_v) = left(beginmatrix\n    1 \n    x_v^w_v\n    endmatrixright)","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"where x_v is a variable associated with v. Similarly, for each edge (u v) in E, we define a matrix B indexed by s_u and s_v as","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"B = left(beginmatrix\n1   1\n1  0\nendmatrixright)","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"Ideally, an optimal contraction order has a space complexity 2^rm tw(G), where rm tw(G) is the tree-width of G (or graph in the code). We can check the time, space and read-write complexities by typing","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"contraction_complexity(problem)","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"For more information about how to improve the contraction order, please check the Performance Tips.","category":"page"},{"location":"generated/IndependentSet/#Solution-Space-Analysis","page":"Independent set problem","title":"Solution Space Analysis","text":"","category":"section"},{"location":"generated/IndependentSet/#1.-Maximum-Independent-Set-Size-(α(G))","page":"Independent set problem","title":"1. Maximum Independent Set Size (α(G))","text":"","category":"section"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"First, we compute the size of the largest independent set:","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"maximum_independent_set_size = solve(problem, SizeMax())[]\nread_size(maximum_independent_set_size)","category":"page"},{"location":"generated/IndependentSet/#2.-Counting-Solutions","page":"Independent set problem","title":"2. Counting Solutions","text":"","category":"section"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"We can analyze the solution space in several ways:","category":"page"},{"location":"generated/IndependentSet/#a.-Total-Count","page":"Independent set problem","title":"a. Total Count","text":"","category":"section"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"Count all possible independent sets:","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"count_all_independent_sets = solve(problem, CountingAll())[]","category":"page"},{"location":"generated/IndependentSet/#b.-Maximum-Solutions","page":"Independent set problem","title":"b. Maximum Solutions","text":"","category":"section"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"Count independent sets of maximum size:","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"count_maximum_independent_sets = solve(problem, CountingMax())[]\nread_size_count(count_maximum_independent_sets)","category":"page"},{"location":"generated/IndependentSet/#Configuration-Analysis","page":"Independent set problem","title":"Configuration Analysis","text":"","category":"section"},{"location":"generated/IndependentSet/#1.-Finding-Optimal-Solutions","page":"Independent set problem","title":"1. Finding Optimal Solutions","text":"","category":"section"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"We can find a single optimal solution using SingleConfigMax:","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"max_config = solve(problem, SingleConfigMax(; bounded=false))[]\nsingle_solution = read_config(max_config)","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"Visualize the maximum independent set:","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"show_graph(graph, locations; format=:svg, vertex_colors=\n    [iszero(single_solution[i]) ? \"white\" : \"red\" for i=1:nv(graph)])","category":"page"},{"location":"generated/IndependentSet/#2.-Solution-Enumeration","page":"Independent set problem","title":"2. Solution Enumeration","text":"","category":"section"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"We can enumerate all optimal solutions or generate samples:","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"a. Find all maximum independent sets:","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"all_max_configs = solve(problem, ConfigsMax(; bounded=true))[]\n_, configs_vector = read_size_config(all_max_configs)","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"b. Store all independent sets efficiently using a tree structure:","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"all_independent_sets_tree = solve(problem, ConfigsAll(; tree_storage=true))[]","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"Generate a sample of 10 random solutions:","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"generate_samples(all_independent_sets_tree, 10)","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"","category":"page"},{"location":"generated/IndependentSet/","page":"Independent set problem","title":"Independent set problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"EditURL = \"../../../examples/PaintShop.jl\"","category":"page"},{"location":"generated/PaintShop/#Binary-Paint-Shop-Problem","page":"Binary paint shop problem","title":"Binary Paint Shop Problem","text":"","category":"section"},{"location":"generated/PaintShop/#Overview","page":"Binary paint shop problem","title":"Overview","text":"","category":"section"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"The Binary Paint Shop Problem involves a sequence of cars, each appearing exactly twice. Each car must be painted red in one occurrence and blue in the other. The goal is to minimize the number of color changes when processing the sequence in order.","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"This example demonstrates:","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"Formulating the paint shop problem\nConverting it to a tensor network\nFinding optimal coloring sequences\nVisualizing solutions","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"We'll use a character sequence where each character represents a car.","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"using GenericTensorNetworks, Graphs, GenericTensorNetworks.ProblemReductions","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"Define our sequence (each character appears exactly twice)","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"sequence = collect(\"iadgbeadfcchghebif\")","category":"page"},{"location":"generated/PaintShop/#Problem-Visualization","page":"Binary paint shop problem","title":"Problem Visualization","text":"","category":"section"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"We can represent this problem as a graph:","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"Vertices are positions in the sequence\nBlue edges connect the same car's two occurrences\nBlack edges connect adjacent positions in the sequence","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"rot(a, b, θ) = cos(θ)*a + sin(θ)*b, cos(θ)*b - sin(θ)*a\nlocations = [rot(0.0, 100.0, -0.25π - 1.5*π*(i-0.5)/length(sequence)) for i=1:length(sequence)]\ngraph = path_graph(length(sequence))\nfor i=1:length(sequence)\n    j = findlast(==(sequence[i]), sequence)\n    i != j && add_edge!(graph, i, j)\nend\nshow_graph(graph, locations; texts=string.(sequence), format=:svg, edge_colors=\n    [sequence[e.src] == sequence[e.dst] ? \"blue\" : \"black\" for e in edges(graph)])","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"Note: Vertices connected by blue edges must have different colors, and our goal becomes a min-cut problem on the black edges.","category":"page"},{"location":"generated/PaintShop/#Tensor-Network-Formulation","page":"Binary paint shop problem","title":"Tensor Network Formulation","text":"","category":"section"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"Define the binary paint shop problem:","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"pshop = PaintShop(sequence)","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"The objective is to minimize color changes:","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"objectives(pshop)","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"Convert to tensor network representation:","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"problem = GenericTensorNetwork(pshop)","category":"page"},{"location":"generated/PaintShop/#Mathematical-Background","page":"Binary paint shop problem","title":"Mathematical Background","text":"","category":"section"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"For each car c_i, we assign a boolean variable s_c_i in 01, where:","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"0 means the first appearance is colored red\n1 means the first appearance is colored blue","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"For adjacent positions (ii+1), we define edge tensors:","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"If both cars are at their first or both at their second appearance:\nB^textparallel = beginpmatrix\n    x  1 \n    1  x\nendpmatrix\n(Cars tend to have the same configuration to avoid color changes)\nOtherwise (one first, one second appearance):\nB^textanti-parallel = beginpmatrix\n    1  x \n    x  1\nendpmatrix\n(Cars tend to have different configurations to avoid color changes)","category":"page"},{"location":"generated/PaintShop/#Solution-Analysis","page":"Binary paint shop problem","title":"Solution Analysis","text":"","category":"section"},{"location":"generated/PaintShop/#1.-Paint-Shop-Polynomial","page":"Binary paint shop problem","title":"1. Paint Shop Polynomial","text":"","category":"section"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"The paint shop polynomial P(Gx) = sum_i p_i x^i counts colorings by number of color changes, where p_i is the number of colorings with (2m-1-i) color changes","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"paint_polynomial = solve(problem, GraphPolynomial())[]","category":"page"},{"location":"generated/PaintShop/#2.-Optimal-Coloring-Configurations","page":"Binary paint shop problem","title":"2. Optimal Coloring Configurations","text":"","category":"section"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"Find all optimal coloring configurations:","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"best_configs = solve(problem, ConfigsMin())[]","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"Note: We get two identical bitstrings corresponding to different vertex configurations due to bit-flip symmetry (we can start with either red or blue)","category":"page"},{"location":"generated/PaintShop/#3.-Solution-Visualization","page":"Binary paint shop problem","title":"3. Solution Visualization","text":"","category":"section"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"Convert the optimal configuration to a coloring sequence:","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"painting1 = ProblemReductions.paint_shop_coloring_from_config(pshop, read_config(best_configs)[1])","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"Visualize the optimal coloring:","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"show_graph(graph, locations; format=:svg, texts=string.(sequence),\n    edge_colors=[sequence[e.src] == sequence[e.dst] ? \"blue\" : \"black\" for e in edges(graph)],\n    vertex_colors=[isone(c) ? \"red\" : \"black\" for c in painting1],\n    config=GraphDisplayConfig(;vertex_text_color=\"white\"))","category":"page"},{"location":"generated/PaintShop/#4.-Verification","page":"Binary paint shop problem","title":"4. Verification","text":"","category":"section"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"Verify the solution by counting the number of color switches:","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"num_paint_shop_color_switch(sequence, painting1)","category":"page"},{"location":"generated/PaintShop/#More-APIs","page":"Binary paint shop problem","title":"More APIs","text":"","category":"section"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"The Independent Set Problem chapter has more examples on how to use the APIs.","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"","category":"page"},{"location":"generated/PaintShop/","page":"Binary paint shop problem","title":"Binary paint shop problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"sumproduct/#Efficient-Configuration-Storage-with-Sum-Product-Trees","page":"Sum product tree representation","title":"Efficient Configuration Storage with Sum-Product Trees","text":"","category":"section"},{"location":"sumproduct/#Overview","page":"Sum product tree representation","title":"Overview","text":"","category":"section"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"When dealing with combinatorial problems, the number of valid configurations can grow exponentially with problem size. The SumProductTree data structure provides a memory-efficient solution for storing and sampling from these large configuration spaces.","category":"page"},{"location":"sumproduct/#The-Sum-Product-Tree-Approach","page":"Sum product tree representation","title":"The Sum-Product Tree Approach","text":"","category":"section"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"A SumProductTree is a specialized data structure that:","category":"page"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"Uses polynomial memory to store an exponential number of configurations\nRepresents configurations as a sum-product expression tree\nEnables lazy evaluation through depth-first search\nSupports efficient directed sampling from the configuration space","category":"page"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"This approach is particularly valuable when working with large graphs where storing all configurations explicitly would be prohibitively expensive.","category":"page"},{"location":"sumproduct/#Example:-Independent-Sets-in-Large-Graphs","page":"Sum product tree representation","title":"Example: Independent Sets in Large Graphs","text":"","category":"section"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"Let's examine how to use a SumProductTree for a large random regular graph:","category":"page"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"using GenericTensorNetworks\ngraph = random_regular_graph(70, 3)\nproblem = GenericTensorNetwork(IndependentSet(graph); optimizer=TreeSA())\ntree = solve(problem, ConfigsAll(; tree_storage=true))[]","category":"page"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"For this 70-vertex graph, storing all independent sets explicitly would require approximately 256 TB of storage! However, the SumProductTree representation requires only a fraction of this memory.","category":"page"},{"location":"sumproduct/#Sampling-from-the-Configuration-Space","page":"Sum product tree representation","title":"Sampling from the Configuration Space","text":"","category":"section"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"One of the most powerful features of the SumProductTree is its ability to generate unbiased random samples from the configuration space:","category":"page"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"samples = generate_samples(tree, 1000)","category":"page"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"This generates 1000 random independent set configurations from our graph, allowing us to analyze statistical properties without enumerating the entire solution space.","category":"page"},{"location":"sumproduct/#Statistical-Analysis:-Hamming-Distance-Distribution","page":"Sum product tree representation","title":"Statistical Analysis: Hamming Distance Distribution","text":"","category":"section"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"With these samples, we can compute useful properties such as the Hamming distance distribution between configurations. The Hamming distance measures how many bit positions differ between two configurations.","category":"page"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"using CairoMakie\ndist = hamming_distribution(samples, samples)\n\n# Create a bar plot of the distribution\nfig = Figure()\nax = Axis(fig[1, 1]; xlabel=\"Hamming Distance\", ylabel=\"Frequency\")\nbarplot!(ax, 0:length(dist)-1, dist)\nfig","category":"page"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"This visualization reveals the structure of the solution space by showing how similar or dissimilar the independent set configurations tend to be to each other.","category":"page"},{"location":"sumproduct/#Applications","page":"Sum product tree representation","title":"Applications","text":"","category":"section"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"The SumProductTree approach is particularly valuable for:","category":"page"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"Analyzing very large problem instances\nEstimating statistical properties of solution spaces\nPerforming Monte Carlo sampling for approximation algorithms\nStudying the structure of configuration spaces without exhaustive enumeration","category":"page"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"By combining compact representation with efficient sampling, SumProductTree enables analysis of problem instances that would otherwise be computationally intractable.","category":"page"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"using GenericTensorNetworks\ngraph = random_regular_graph(70, 3)\nproblem = GenericTensorNetwork(IndependentSet(graph); optimizer=TreeSA());\ntree = solve(problem, ConfigsAll(; tree_storage=true))[]","category":"page"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"If one wants to store these configurations, he will need a hard disk of size 256 TB! However, this sum-product binary tree structure supports efficient and unbiased direct sampling.","category":"page"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"samples = generate_samples(tree, 1000)","category":"page"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"With these samples, one can already compute useful properties like Hamming distance (see hamming_distribution) distribution. The following code visualizes this distribution with CairoMakie.","category":"page"},{"location":"sumproduct/","page":"Sum product tree representation","title":"Sum product tree representation","text":"using CairoMakie\ndist = hamming_distribution(samples, samples)\n# bar plot\nfig = Figure()\nax = Axis(fig[1, 1]; xlabel=\"Hamming distance\", ylabel=\"Frequency\")\nbarplot!(ax, 0:length(dist)-1, dist)\nfig","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"EditURL = \"../../../examples/Coloring.jl\"","category":"page"},{"location":"generated/Coloring/#Graph-Coloring-Problem","page":"Coloring problem","title":"Graph Coloring Problem","text":"","category":"section"},{"location":"generated/Coloring/#Overview","page":"Coloring problem","title":"Overview","text":"","category":"section"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"Graph coloring is a fundamental problem in graph theory where we assign colors to vertices such that no adjacent vertices share the same color. This example demonstrates solving a 3-coloring problem on the Petersen graph using tensor networks.","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"using GenericTensorNetworks, Graphs","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"Create a Petersen graph instance","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"graph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"Define vertex layout for visualization","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\nlocations = [[rot15(0.0, 60.0, i) for i=0:4]..., [rot15(0.0, 30, i) for i=0:4]...]\nshow_graph(graph, locations; format=:svg)","category":"page"},{"location":"generated/Coloring/#Tensor-Network-Formulation","page":"Coloring problem","title":"Tensor Network Formulation","text":"","category":"section"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"We represent the 3-coloring problem using tensor networks:","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"coloring = Coloring{3}(graph)\n\nconstraints(coloring)","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"objectives(coloring)","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"Convert the coloring problem to a tensor network:","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"problem = GenericTensorNetwork(coloring)","category":"page"},{"location":"generated/Coloring/#Mathematical-Background","page":"Coloring problem","title":"Mathematical Background","text":"","category":"section"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"Type Coloring can be used for constructing the tensor network with optimized contraction order for a coloring problem. Let us use 3-coloring problem defined on vertices as an example. For a vertex v, we define the degrees of freedom c_vin123 and a vertex tensor labelled by it as","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"W(v) = left(beginmatrix\n    1\n    1\n    1\nendmatrixright)","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"For an edge (u v), we define an edge tensor as a matrix labelled by (c_u c_v) to specify the constraint","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"B = left(beginmatrix\n    1  x  x\n    x  1  x\n    x  x  1\nendmatrixright)","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"The number of possible colorings can be obtained by contracting this tensor network by setting vertex tensor elements to 1.","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"We can check the time, space and read-write complexities by typing:","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"contraction_complexity(problem)","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"For more information about how to improve the contraction order, please check the Performance Tips.","category":"page"},{"location":"generated/Coloring/#Solution-Analysis","page":"Coloring problem","title":"Solution Analysis","text":"","category":"section"},{"location":"generated/Coloring/#1.-Count-All-Valid-Colorings","page":"Coloring problem","title":"1. Count All Valid Colorings","text":"","category":"section"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"num_of_coloring = solve(problem, CountingMax())[]","category":"page"},{"location":"generated/Coloring/#2.-Find-One-Valid-Coloring","page":"Coloring problem","title":"2. Find One Valid Coloring","text":"","category":"section"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"single_solution = solve(problem, SingleConfigMax())[]\ncoloring_config = read_config(single_solution)","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"Verify the solution is valid","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"is_vertex_coloring(graph, coloring_config)","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"Visualize the coloring solution","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"vertex_color_map = Dict(0=>\"red\", 1=>\"green\", 2=>\"blue\")\nshow_graph(graph, locations; format=:svg, vertex_colors=[vertex_color_map[Int(c)]\n     for c in coloring_config])","category":"page"},{"location":"generated/Coloring/#Edge-Coloring-Analysis","page":"Coloring problem","title":"Edge Coloring Analysis","text":"","category":"section"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"Let's examine the same problem on the line graph (where edges become vertices)","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"linegraph = line_graph(graph)","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"Visualize the line graph","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"show_graph(linegraph, [(locations[e.src] .+ locations[e.dst])\n     for e in edges(graph)]; format=:svg)","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"Attempt to solve 3-coloring on the line graph","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"lineproblem = Coloring{3}(linegraph)\nnum_of_coloring = solve(GenericTensorNetwork(lineproblem), CountingMax())[]\nread_size_count(num_of_coloring)","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"Note: The maximum size of 28 is less than the number of edges in the line graph, proving that no valid 3-coloring exists for the edges of a Petersen graph.","category":"page"},{"location":"generated/Coloring/#More-APIs","page":"Coloring problem","title":"More APIs","text":"","category":"section"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"The Independent Set Problem chapter has more examples on how to use the APIs.","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"","category":"page"},{"location":"generated/Coloring/","page":"Coloring problem","title":"Coloring problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"EditURL = \"../../../examples/SetPacking.jl\"","category":"page"},{"location":"generated/SetPacking/#Set-Packing-Problem","page":"Set packing problem","title":"Set Packing Problem","text":"","category":"section"},{"location":"generated/SetPacking/#Overview","page":"Set packing problem","title":"Overview","text":"","category":"section"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"The Set Packing Problem is a generalization of the Independent Set problem from simple graphs to hypergraphs. Given a collection of sets, the goal is to find the maximum number of mutually disjoint sets (sets that share no common elements).","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"This example demonstrates:","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"Formulating a set packing problem\nConverting it to a tensor network\nFinding maximum set packings\nAnalyzing the solution space","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"We'll use the same sets from the Set Covering Problem example for comparison.","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"using GenericTensorNetworks, Graphs","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"Define our sets (each representing a camera's coverage area)","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"sets = [[1,3,4,6,7], [4,7,8,12], [2,5,9,11,13],\n    [1,2,14,15], [3,6,10,12,14], [8,14,15],\n    [1,2,6,11], [1,2,4,6,8,12]]","category":"page"},{"location":"generated/SetPacking/#Tensor-Network-Formulation","page":"Set packing problem","title":"Tensor Network Formulation","text":"","category":"section"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"Define the set packing problem:","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"setpacking = SetPacking(sets)","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"The problem consists of:","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"Packing constraints: No element can be covered by more than one set\nOptimization objective: Maximize the number of sets used","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"constraints(setpacking)","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"objectives(setpacking)","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"Convert to tensor network representation:","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"problem = GenericTensorNetwork(setpacking)","category":"page"},{"location":"generated/SetPacking/#Mathematical-Background","page":"Set packing problem","title":"Mathematical Background","text":"","category":"section"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"For each set s with weight w_s, we assign a boolean variable v_s  01, indicating whether the set is included in the solution.","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"The network uses two types of tensors:","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"Set Tensors: For each set s:\nW(x_s w_s) = beginpmatrix\n    1 \n    x_s^w_s\nendpmatrix\nElement Constraint Tensors: For each element a and its containing sets N(a):\nB_s_1s_N(a) =\nbegincases\n    0  textif  sum_i s_i  1 text (element covered multiple times - invalid) \n    1  textotherwise (element covered at most once - valid)\nendcases","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"Check the contraction complexity:","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"contraction_complexity(problem)","category":"page"},{"location":"generated/SetPacking/#Solution-Analysis","page":"Set packing problem","title":"Solution Analysis","text":"","category":"section"},{"location":"generated/SetPacking/#1.-Set-Packing-Polynomial","page":"Set packing problem","title":"1. Set Packing Polynomial","text":"","category":"section"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"The polynomial P(Sx) = sum_i c_i x^i counts set packings by size, where c_i is the number of valid packings using i sets","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"packing_polynomial = solve(problem, GraphPolynomial())[]","category":"page"},{"location":"generated/SetPacking/#2.-Maximum-Set-Packing-Size","page":"Set packing problem","title":"2. Maximum Set Packing Size","text":"","category":"section"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"Find the maximum number of mutually disjoint sets:","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"max_packing_size = solve(problem, SizeMax())[]","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"Count maximum set packings:","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"counting_maximum_set_packing = solve(problem, CountingMax())[]","category":"page"},{"location":"generated/SetPacking/#3.-Maximum-Set-Packing-Configurations","page":"Set packing problem","title":"3. Maximum Set Packing Configurations","text":"","category":"section"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"Enumerate all maximum set packings:","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"max_configs = read_config(solve(problem, ConfigsMax())[])","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"The optimal solution is z_1 z_3 z_6 with size 3, where z_i represents the i-th set in our original list.","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"Verify solutions are valid:","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"all(c->is_set_packing(problem.problem, c), max_configs)","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"Note: For finding just one maximum set packing, use the SingleConfigMax property","category":"page"},{"location":"generated/SetPacking/#More-APIs","page":"Set packing problem","title":"More APIs","text":"","category":"section"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"The Independent Set Problem chapter has more examples on how to use the APIs.","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"","category":"page"},{"location":"generated/SetPacking/","page":"Set packing problem","title":"Set packing problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"EditURL = \"../../../examples/open.jl\"","category":"page"},{"location":"generated/open/#Open-and-Fixed-Degrees-of-Freedom","page":"Open and fixed degrees of freedom","title":"Open and Fixed Degrees of Freedom","text":"","category":"section"},{"location":"generated/open/#Overview","page":"Open and fixed degrees of freedom","title":"Overview","text":"","category":"section"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"When analyzing complex systems, we often need to examine specific variables while marginalizing or conditioning on others. This example demonstrates two approaches:","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"Open degrees of freedom: Compute marginals over selected variables\nFixed degrees of freedom: Compute conditional values by fixing certain variables","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"We'll illustrate these concepts using the Maximum Independent Set (MIS) problem on the Petersen graph.","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"using GenericTensorNetworks, Graphs","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"Create a Petersen graph instance","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"graph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"generated/open/#Approach-1:-Open-Degrees-of-Freedom","page":"Open and fixed degrees of freedom","title":"Approach 1: Open Degrees of Freedom","text":"","category":"section"},{"location":"generated/open/#Computing-Marginals","page":"Open and fixed degrees of freedom","title":"Computing Marginals","text":"","category":"section"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"The openvertices parameter allows us to compute marginals over specified vertices. Here we compute the MIS tropical tensor with open vertices 1, 2, and 3:","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"problem = GenericTensorNetwork(IndependentSet(graph); openvertices=[1,2,3])\nmarginal = solve(problem, SizeMax())","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"The result is a rank-3 tensor where each element represents the maximum independent set size for a specific configuration of the open vertices. This tensor is known as the MIS tropical tensor, which has applications in tropical tensor analysis.","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"Each index corresponds to a vertex state (0 or 1), and the tensor value gives the maximum achievable independent set size given those fixed vertex states.","category":"page"},{"location":"generated/open/#Approach-2:-Fixed-Degrees-of-Freedom","page":"Open and fixed degrees of freedom","title":"Approach 2: Fixed Degrees of Freedom","text":"","category":"section"},{"location":"generated/open/#Computing-Conditional-Values","page":"Open and fixed degrees of freedom","title":"Computing Conditional Values","text":"","category":"section"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"The fixedvertices parameter allows us to condition on specific vertex assignments. We can achieve the same result as above by systematically fixing vertices to different values:","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"problem = GenericTensorNetwork(IndependentSet(graph); fixedvertices=Dict(1=>0, 2=>0, 3=>0))","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"Create a tensor to store results for all possible configurations of vertices 1, 2, and 3","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"output = zeros(TropicalF64, 2, 2, 2)","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"Compute MIS size for each possible configuration of the three vertices","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"marginal_alternative = map(CartesianIndices((2,2,2))) do ci\n    problem.fixedvertices[1] = ci.I[1]-1  # Convert from 1-indexed to 0-indexed\n    problem.fixedvertices[2] = ci.I[2]-1\n    problem.fixedvertices[3] = ci.I[3]-1\n    output[ci] = solve(problem, SizeMax())[]\nend","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"Both approaches produce the same marginal information for vertices 1, 2, and 3.","category":"page"},{"location":"generated/open/#Performance-Considerations","page":"Open and fixed degrees of freedom","title":"Performance Considerations","text":"","category":"section"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"While both approaches yield the same results, their computational efficiency can differ significantly. The openvertices approach allows the contraction order optimizer to consider these degrees of freedom during optimization, potentially leading to more efficient contraction paths.","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"Choose the appropriate method based on your specific needs:","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"Use openvertices when you need marginals over multiple configurations\nUse fixedvertices when you need to condition on specific configurations or when exploring a small number of fixed assignments","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"","category":"page"},{"location":"generated/open/","page":"Open and fixed degrees of freedom","title":"Open and fixed degrees of freedom","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"EditURL = \"../../../examples/Matching.jl\"","category":"page"},{"location":"generated/Matching/#Vertex-Matching-Problem","page":"Vertex matching problem","title":"Vertex Matching Problem","text":"","category":"section"},{"location":"generated/Matching/#Overview","page":"Vertex matching problem","title":"Overview","text":"","category":"section"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"A k-matching in a graph is a set of k edges where no two edges share a common vertex. A perfect matching occurs when every vertex in the graph is matched. This example demonstrates:","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"Finding maximum matchings\nComputing the matching polynomial\nVisualizing matching configurations","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"We'll explore these concepts using the Petersen graph.","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"using GenericTensorNetworks, Graphs","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"Create a Petersen graph instance","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"graph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"Define vertex layout for visualization","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\nlocations = [[rot15(0.0, 60.0, i) for i=0:4]..., [rot15(0.0, 30, i) for i=0:4]...]\nshow_graph(graph, locations; format=:svg)","category":"page"},{"location":"generated/Matching/#Tensor-Network-Formulation","page":"Vertex matching problem","title":"Tensor Network Formulation","text":"","category":"section"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"Define the matching problem using tensor networks:","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"matching = Matching(graph)","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"The problem consists of:","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"Matching constraints: No vertex can be matched more than once\nOptimization objective: Maximize the number of matches","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"constraints(matching)","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"objectives(matching)","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"Convert to tensor network representation:","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"problem = GenericTensorNetwork(matching)","category":"page"},{"location":"generated/Matching/#Mathematical-Background","page":"Vertex matching problem","title":"Mathematical Background","text":"","category":"section"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"For a graph G=(VE), we assign a boolean variable s_e in 01 to each edge e, where 1 indicates the vertices are matched.","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"The network uses two types of tensors:","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"Vertex Tensors: For vertex v with incident edges e_1e_k:\nW_s_e₁s_eₖ = begincases\n    1  textif  sum_i=1^k s_e_i leq 1\n    0  textotherwise\nendcases\nThis ensures at most one incident edge is selected (at most one match per vertex)\nEdge Tensors: For edge e:\nB_s_e = begincases\n    1  textif  s_e = 0\n    x  textif  s_e = 1\nendcases\nThis assigns weight x to matched edges and 1 to unmatched edges","category":"page"},{"location":"generated/Matching/#Solution-Analysis","page":"Vertex matching problem","title":"Solution Analysis","text":"","category":"section"},{"location":"generated/Matching/#1.-Maximum-Matching","page":"Vertex matching problem","title":"1. Maximum Matching","text":"","category":"section"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"Find the size of the maximum matching:","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"max_matching = solve(problem, SizeMax())[]\nread_size(max_matching)","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"Note: A maximum matching size of 5 indicates a perfect matching exists (all vertices are paired)","category":"page"},{"location":"generated/Matching/#2.-Matching-Polynomial","page":"Vertex matching problem","title":"2. Matching Polynomial","text":"","category":"section"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"The matching polynomial M(Gx) = sum_i c_i x^i counts matchings by size, where c_i is the number of i-matchings in G","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"matching_poly = solve(problem, GraphPolynomial())[]\nread_size_count(matching_poly)","category":"page"},{"location":"generated/Matching/#3.-Perfect-Matching-Visualization","page":"Vertex matching problem","title":"3. Perfect Matching Visualization","text":"","category":"section"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"Find one perfect matching configuration:","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"match_config = solve(problem, SingleConfigMax())[]\nsize, config = read_size_config(match_config)","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"Visualize the matching by highlighting matched edges in red:","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"show_graph(graph, locations; format=:svg, edge_colors=\n    [isone(read_config(match_config)[i]) ? \"red\" : \"black\" for i=1:ne(graph)])","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"Red edges indicate pairs of matched vertices","category":"page"},{"location":"generated/Matching/#More-APIs","page":"Vertex matching problem","title":"More APIs","text":"","category":"section"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"The Independent Set Problem chapter has more examples on how to use the APIs.","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"","category":"page"},{"location":"generated/Matching/","page":"Vertex matching problem","title":"Vertex matching problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"EditURL = \"../../../examples/Satisfiability.jl\"","category":"page"},{"location":"generated/Satisfiability/#Boolean-Satisfiability-Problem","page":"Satisfiability problem","title":"Boolean Satisfiability Problem","text":"","category":"section"},{"location":"generated/Satisfiability/#Overview","page":"Satisfiability problem","title":"Overview","text":"","category":"section"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"The Boolean Satisfiability Problem (SAT) determines whether there exists an assignment of truth values to variables that makes a given Boolean formula evaluate to true.","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"This example demonstrates:","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"Formulating a SAT problem in Conjunctive Normal Form (CNF)\nConverting it to a tensor network\nFinding satisfying assignments\nCounting satisfiable solutions","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"We'll work with a CNF formula consisting of multiple clauses.","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"using GenericTensorNetworks, GenericTensorNetworks.ProblemReductions","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"Define boolean variables","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"@bools a b c d e f g","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"Create a CNF formula: (a ∨ b ∨ ¬d ∨ ¬e) ∧ (¬a ∨ d ∨ e ∨ ¬f) ∧ (f ∨ g) ∧ (¬b ∨ c)","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"cnf = ∧(∨(a, b, ¬d, ¬e), ∨(¬a, d, e, ¬f), ∨(f, g), ∨(¬b, c))","category":"page"},{"location":"generated/Satisfiability/#Manual-Verification","page":"Satisfiability problem","title":"Manual Verification","text":"","category":"section"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"For small problems, we can manually find and verify a satisfying assignment:","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"assignment = Dict([:a=>true, :b=>false, :c=>false, :d=>true, :e=>false, :f=>false, :g=>true])","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"Check if this assignment satisfies the formula:","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"satisfiable(cnf, assignment)","category":"page"},{"location":"generated/Satisfiability/#Tensor-Network-Formulation","page":"Satisfiability problem","title":"Tensor Network Formulation","text":"","category":"section"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"Define the satisfiability problem:","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"sat = Satisfiability(cnf)","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"The objective is to maximize the number of satisfied clauses:","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"objectives(sat)","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"Convert to tensor network representation:","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"problem = GenericTensorNetwork(sat)","category":"page"},{"location":"generated/Satisfiability/#Mathematical-Background","page":"Satisfiability problem","title":"Mathematical Background","text":"","category":"section"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"For each boolean variable x, we assign a degree of freedom s_x  01, where:","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"0 represents the value 'false'\n1 represents the value 'true'","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"Each clause is mapped to a tensor. For example, the clause ¬x ∨ y ∨ ¬z becomes a tensor labeled by (s_x s_y s_z):","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"C_s_xs_ys_z = begincases\n    0  textif  s_x = 1 s_y = 0 s_z = 1 \n    1  textotherwise\nendcases","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"Only the configuration (s_x s_y s_z) = (1 0 1) makes this clause unsatisfied.","category":"page"},{"location":"generated/Satisfiability/#Solution-Analysis","page":"Satisfiability problem","title":"Solution Analysis","text":"","category":"section"},{"location":"generated/Satisfiability/#1.-Satisfiability-Check","page":"Satisfiability problem","title":"1. Satisfiability Check","text":"","category":"section"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"Find the maximum number of clauses that can be satisfied:","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"num_satisfiable = solve(problem, SizeMax())[]","category":"page"},{"location":"generated/Satisfiability/#2.-Counting-Solutions","page":"Satisfiability problem","title":"2. Counting Solutions","text":"","category":"section"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"The graph polynomial counts assignments by number of satisfied clauses:","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"num_satisfiable_count = read_size_count(solve(problem, GraphPolynomial())[])","category":"page"},{"location":"generated/Satisfiability/#3.-Finding-a-Satisfying-Assignment","page":"Satisfiability problem","title":"3. Finding a Satisfying Assignment","text":"","category":"section"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"Find one satisfying assignment:","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"single_config = read_config(solve(problem, SingleConfigMax())[])","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"Convert the bit vector to a variable assignment and verify:","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"solution_assignment = Dict(zip(ProblemReductions.symbols(problem.problem), single_config))\nsatisfiable(cnf, solution_assignment)","category":"page"},{"location":"generated/Satisfiability/#More-APIs","page":"Satisfiability problem","title":"More APIs","text":"","category":"section"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"The Independent Set Problem chapter has more examples on how to use the APIs.","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"","category":"page"},{"location":"generated/Satisfiability/","page":"Satisfiability problem","title":"Satisfiability problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"EditURL = \"../../../examples/SpinGlass.jl\"","category":"page"},{"location":"generated/SpinGlass/#Spin-Glass-Problem","page":"Spin glass problem","title":"Spin Glass Problem","text":"","category":"section"},{"location":"generated/SpinGlass/#Overview","page":"Spin glass problem","title":"Overview","text":"","category":"section"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Spin glasses are magnetic systems characterized by disordered interactions between spins. They represent a fundamental model in statistical physics with applications in optimization, neural networks, and complex systems. This example demonstrates:","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Formulating spin glass problems on simple graphs and hypergraphs\nConverting them to tensor networks\nFinding ground states and excited states\nComputing partition functions and energy distributions","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"We'll explore both standard graphs and hypergraphs to showcase the versatility of the approach.","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"using GenericTensorNetworks, Graphs","category":"page"},{"location":"generated/SpinGlass/#Part-1:-Spin-Glass-on-a-Simple-Graph","page":"Spin glass problem","title":"Part 1: Spin Glass on a Simple Graph","text":"","category":"section"},{"location":"generated/SpinGlass/#Problem-Definition","page":"Spin glass problem","title":"Problem Definition","text":"","category":"section"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"A spin glass on a graph G=(V,E) is defined by the Hamiltonian: H = ∑{ij∈E} J{ij} si sj + ∑{i∈V} hi s_i","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Where:","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"s_i ∈ {-1,1} are spin variables\nJ_{ij} are coupling strengths between spins\nh_i are local field terms","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"We use boolean variables ni = (1-si)/2 in our implementation.","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Create a Petersen graph instance","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"graph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Define vertex layout for visualization","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\nlocations = [[rot15(0.0, 60.0, i) for i=0:4]..., [rot15(0.0, 30, i) for i=0:4]...]\nshow_graph(graph, locations; format=:svg)","category":"page"},{"location":"generated/SpinGlass/#Tensor-Network-Formulation","page":"Spin glass problem","title":"Tensor Network Formulation","text":"","category":"section"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Define an anti-ferromagnetic spin glass with uniform couplings:","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"spinglass = SpinGlass(graph, fill(1, ne(graph)), zeros(Int, nv(graph)))","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"The objective is to minimize the energy:","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"objectives(spinglass)","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Convert to tensor network representation:","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"problem = GenericTensorNetwork(spinglass)","category":"page"},{"location":"generated/SpinGlass/#Mathematical-Background","page":"Spin glass problem","title":"Mathematical Background","text":"","category":"section"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"The tensor network for a spin glass uses:","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Edge Tensors: For edge (ij) with coupling J_ij:\nB_s_is_j(x) = beginpmatrix\n    x^J_ij  x^-J_ij \n    x^-J_ij  x^J_ij\nendpmatrix\nContributes x^J_ij when spins are aligned (s_i = s_j)\nContributes x^-J_ij when spins are anti-aligned (s_i  s_j)\nVertex Tensors: For vertex i with local field h_i:\nW_i(x) = beginpmatrix\n    x^h_i \n    x^-h_i\nendpmatrix","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"This formulation allows efficient computation of various properties.","category":"page"},{"location":"generated/SpinGlass/#Solution-Analysis","page":"Spin glass problem","title":"Solution Analysis","text":"","category":"section"},{"location":"generated/SpinGlass/#1.-Energy-Extrema","page":"Spin glass problem","title":"1. Energy Extrema","text":"","category":"section"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Find the minimum energy (ground state):","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Emin = solve(problem, SizeMin())[]","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Find the maximum energy (highest excited state):","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Emax = solve(problem, SizeMax())[]","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Note: The state with highest energy has all spins with the same value","category":"page"},{"location":"generated/SpinGlass/#2.-Partition-Function","page":"Spin glass problem","title":"2. Partition Function","text":"","category":"section"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"The graph polynomial Z(GJhx) = sum_i c_i x^i counts configurations by energy, where c_i is the number of configurations with energy i","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"partition_function = solve(problem, GraphPolynomial())[]","category":"page"},{"location":"generated/SpinGlass/#3.-Ground-State-Configuration","page":"Spin glass problem","title":"3. Ground State Configuration","text":"","category":"section"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Find one ground state configuration:","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"ground_state = read_config(solve(problem, SingleConfigMin())[])","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Verify the energy matches our earlier computation:","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Emin_verify = energy(problem.problem, ground_state)","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Visualize the ground state:","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"show_graph(graph, locations; vertex_colors=[\n    iszero(ground_state[i]) ? \"white\" : \"red\" for i=1:nv(graph)], format=:svg)","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Note: Red vertices represent spins with value -1 (or 1 in boolean representation)","category":"page"},{"location":"generated/SpinGlass/#Part-2:-Spin-Glass-on-a-Hypergraph","page":"Spin glass problem","title":"Part 2: Spin Glass on a Hypergraph","text":"","category":"section"},{"location":"generated/SpinGlass/#Problem-Definition-2","page":"Spin glass problem","title":"Problem Definition","text":"","category":"section"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"A spin glass on a hypergraph H=(V,E) is defined by the Hamiltonian: E = ∑{c∈E} wc ∏{v∈c} Sv","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Where:","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"S_v ∈ {-1,1} are spin variables\nw_c are coupling strengths for hyperedges","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"We use boolean variables sv = (1-Sv)/2 in our implementation.","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Define a hypergraph with 15 vertices","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"num_vertices = 15\n\nhyperedges = [[1,3,4,6,7], [4,7,8,12], [2,5,9,11,13],\n    [1,2,14,15], [3,6,10,12,14], [8,14,15],\n    [1,2,6,11], [1,2,4,6,8,12]]\n\nweights = [-1, 1, -1, 1, -1, 1, -1, 1]","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Define the hypergraph spin glass problem:","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"hyperspinglass = SpinGlass(HyperGraph(num_vertices, hyperedges), weights, zeros(Int, num_vertices))","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Convert to tensor network representation:","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"hyperproblem = GenericTensorNetwork(hyperspinglass)","category":"page"},{"location":"generated/SpinGlass/#Solution-Analysis-2","page":"Spin glass problem","title":"Solution Analysis","text":"","category":"section"},{"location":"generated/SpinGlass/#1.-Energy-Extrema-2","page":"Spin glass problem","title":"1. Energy Extrema","text":"","category":"section"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Find the minimum energy (ground state):","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Emin = solve(hyperproblem, SizeMin())[]","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Find the maximum energy (highest excited state):","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Emax = solve(hyperproblem, SizeMax())[]","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Note: Spin configurations can be chosen to make all hyperedges have either even or odd spin parity","category":"page"},{"location":"generated/SpinGlass/#2.-Partition-Function-and-Polynomial","page":"Spin glass problem","title":"2. Partition Function and Polynomial","text":"","category":"section"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Compute the partition function at inverse temperature β = 2.0:","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"β = 2.0\nZ = solve(hyperproblem, PartitionFunction(β))[]","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Compute the infinite temperature partition function (counts all configurations):","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"solve(hyperproblem, PartitionFunction(0.0))[]","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Compute the full graph polynomial:","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"poly = solve(hyperproblem, GraphPolynomial())[]","category":"page"},{"location":"generated/SpinGlass/#3.-Ground-State-Configuration-2","page":"Spin glass problem","title":"3. Ground State Configuration","text":"","category":"section"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Find one ground state configuration:","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"ground_state = read_config(solve(hyperproblem, SingleConfigMin())[])","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Verify the energy matches our earlier computation:","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"Emin_verify = energy(hyperproblem.problem, ground_state)","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"The result should match the Emin value computed earlier","category":"page"},{"location":"generated/SpinGlass/#More-APIs","page":"Spin glass problem","title":"More APIs","text":"","category":"section"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"The Independent Set Problem chapter has more examples on how to use the APIs.","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"","category":"page"},{"location":"generated/SpinGlass/","page":"Spin glass problem","title":"Spin glass problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"performancetips/#Performance-Tips","page":"Performance Tips","title":"Performance Tips","text":"","category":"section"},{"location":"performancetips/#Overview","page":"Performance Tips","title":"Overview","text":"","category":"section"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"This guide provides strategies to optimize performance when using GenericTensorNetworks.jl.  We'll cover:","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Optimizing contraction orders\nUsing slicing techniques for large problems\nAccelerating computations with specialized GEMM operations\nLeveraging multiprocessing for parallel execution\nUtilizing GPU acceleration\nPerformance benchmarks and comparisons","category":"page"},{"location":"performancetips/#1.-Optimizing-Contraction-Orders","page":"Performance Tips","title":"1. Optimizing Contraction Orders","text":"","category":"section"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Let's examine how to optimize contraction orders using the independent set problem on 3-regular graphs:","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"using GenericTensorNetworks, Graphs, Random\ngraph = random_regular_graph(120, 3)\niset = IndependentSet(graph)\nproblem = GenericTensorNetwork(iset; optimizer=TreeSA(\n    sc_target=20, sc_weight=1.0, rw_weight=3.0, ntrials=10, βs=0.01:0.1:15.0, niters=20))","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"The GenericTensorNetwork constructor maps a problem to a tensor network with an optimized contraction order. The optimizer parameter specifies the algorithm to use:","category":"page"},{"location":"performancetips/#Available-Optimizers:","page":"Performance Tips","title":"Available Optimizers:","text":"","category":"section"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"TreeSA (used above): A simulated annealing-based optimizer that often finds the smallest time/space complexity and supports slicing. See arXiv: 2108.05665 for details.\nGreedyMethod (default): Fastest search but typically yields higher contraction complexity\nKaHyParBipartite: Uses hypergraph partitioning\nSABipartite: Simulated annealing on bipartite representation","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"The returned problem object contains a code field specifying the tensor network with optimized contraction order. For an independent set problem, the optimal contraction complexity is approximately 2^(tw(G)), where tw(G) is the tree-width of graph G.","category":"page"},{"location":"performancetips/#Analyzing-Contraction-Complexity","page":"Performance Tips","title":"Analyzing Contraction Complexity","text":"","category":"section"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"You can check the time, space, and read-write complexity with:","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"contraction_complexity(problem)","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"This returns log2 values of:","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Number of multiplications\nNumber of elements in the largest tensor during contraction\nNumber of read-write operations to tensor elements","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"In our example, the computation requires approximately 2^21.9 multiplications, 2^20 read-write operations, and the largest tensor contains 2^17 elements.","category":"page"},{"location":"performancetips/#Memory-Requirements","page":"Performance Tips","title":"Memory Requirements","text":"","category":"section"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Different element types have different memory footprints:","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"sizeof(TropicalF64)\nsizeof(TropicalF32)\nsizeof(StaticBitVector{200,4})\nsizeof(TruncatedPoly{5,Float64,Float64})","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"For a more accurate estimate of peak memory usage in bytes, use:","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"estimate_memory(problem, GraphPolynomial(; method=:finitefield))\nestimate_memory(problem, GraphPolynomial(; method=:polynomial))","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"The finite field approach requires only 298 KB, while using the Polynomial type requires 71 MB.","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Note: Actual runtime memory can be several times larger than the maximum tensor size\nFor mutable element types like ConfigEnumerator, memory estimation functions may not accurately measure actual usage","category":"page"},{"location":"performancetips/#2.-Slicing-Technique-for-Large-Problems","page":"Performance Tips","title":"2. Slicing Technique for Large Problems","text":"","category":"section"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"For large-scale applications, you can slice over certain degrees of freedom to reduce space complexity. This approach loops and accumulates over selected degrees of freedom, resulting in smaller tensor networks inside the loop.","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"In the TreeSA optimizer, set nslices to a value greater than zero:","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"# Without slicing\nproblem = GenericTensorNetwork(iset; optimizer=TreeSA(βs=0.01:0.1:25.0, ntrials=10, niters=10))\ncontraction_complexity(problem)\n\n# With slicing over 5 degrees of freedom\nproblem = GenericTensorNetwork(iset; optimizer=TreeSA(βs=0.01:0.1:25.0, ntrials=10, niters=10, nslices=5))\ncontraction_complexity(problem)","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"In this example, slicing over 5 degrees of freedom reduces space complexity by a factor of 32 (2^5), while increasing computation time by less than a factor of 2.","category":"page"},{"location":"performancetips/#3.-Accelerating-Tropical-Number-Operations","page":"Performance Tips","title":"3. Accelerating Tropical Number Operations","text":"","category":"section"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"You can significantly speed up Tropical number matrix multiplication when computing SizeMax() by using specialized GEMM routines from TropicalGEMM:","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"using BenchmarkTools\n\n# Without TropicalGEMM\n@btime solve(problem, SizeMax())\n# 91.630 ms (19203 allocations: 23.72 MiB)\n# 0-dimensional Array{TropicalF64, 0}:\n# 53.0ₜ\n\n# With TropicalGEMM\nusing TropicalGEMM\n@btime solve(problem, SizeMax())\n# 8.960 ms (18532 allocations: 17.01 MiB)\n# 0-dimensional Array{TropicalF64, 0}:\n# 53.0ₜ","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"TropicalGEMM overrides the LinearAlgebra.mul! interface and takes effect immediately upon loading. This example shows more than 10x speedup on a single-threaded CPU. Performance can be further improved with Julia multi-threading.","category":"page"},{"location":"performancetips/#4.-Multiprocessing-for-Parallel-Execution","page":"Performance Tips","title":"4. Multiprocessing for Parallel Execution","text":"","category":"section"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"The GenericTensorNetworks.SimpleMultiprocessing submodule provides a convenient multiprocess_run function for parallel jobs. Here's how to find independence polynomials for multiple graphs using 4 processes:","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"# File: run.jl\nusing Distributed, GenericTensorNetworks.SimpleMultiprocessing\nusing Random, GenericTensorNetworks  # to avoid multi-precompilation\n@everywhere using Random, GenericTensorNetworks\n\nresults = multiprocess_run(collect(1:10)) do seed\n    Random.seed!(seed)\n    n = 10\n    @info \"Graph size $n x $n, seed= $seed\"\n    g = random_diagonal_coupled_graph(n, n, 0.8)\n    gp = GenericTensorNetwork(IndependentSet(g); optimizer=TreeSA())\n    res = solve(gp, GraphPolynomial())[]\n    return res\nend\n\nprintln(results)","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Run this script with:","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"$ julia -p4 run.jl","category":"page"},{"location":"performancetips/#5.-GPU-Acceleration","page":"Performance Tips","title":"5. GPU Acceleration","text":"","category":"section"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"To run computations on a GPU, simply load CUDA and set the usecuda parameter:","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"using CUDA\n# [ Info: OMEinsum loaded the CUDA module successfully\n\nsolve(problem, SizeMax(), usecuda=true)\n# 0-dimensional CuArray{TropicalF64, 0, CUDA.Mem.DeviceBuffer}:\n# 53.0ₜ","category":"page"},{"location":"performancetips/#GPU-Compatible-Solution-Properties:","page":"Performance Tips","title":"GPU-Compatible Solution Properties:","text":"","category":"section"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"SizeMax and SizeMin\nCountingAll\nCountingMax and CountingMin\nGraphPolynomial\nSingleConfigMax and SingleConfigMin","category":"page"},{"location":"performancetips/#6.-Performance-Benchmarks","page":"Performance Tips","title":"6. Performance Benchmarks","text":"","category":"section"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"We benchmarked performance on an Intel Xeon CPU E5-2686 v4 @ 2.30GHz (single thread) and a Tesla V100-SXM2 16GB GPU. The benchmark code is available in our paper repository.","category":"page"},{"location":"performancetips/#Independent-Set-Problem-Benchmarks","page":"Performance Tips","title":"Independent Set Problem Benchmarks","text":"","category":"section"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"(Image: benchmark-independent-set)","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"These benchmarks show computation time for various independent set properties on random three-regular graphs:","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Figure (a): Time and space complexity vs. number of vertices","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Slicing was used for graphs with space complexity > 2^27 (above yellow line)","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Figure (b): Computation time for:","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"MIS size calculation\nCounting all independent sets\nCounting MISs\nCounting sets of size α(G) and α(G)-1\nFinding 100 largest set sizes","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Figure (c): Computation time for independence polynomials:","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Fourier transformation method is fastest but may have round-off errors\nFinite field (GF(p)) approach has no round-off errors and works on GPU","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Figure (d): Configuration enumeration time:","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Bounding techniques improve performance by >10x for MIS enumeration\nBounding also significantly reduces memory usage","category":"page"},{"location":"performancetips/#Maximal-Independent-Set-Benchmarks","page":"Performance Tips","title":"Maximal Independent Set Benchmarks","text":"","category":"section"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"(Image: benchmark-maximal-independent-set)","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Figure (a): Time and space complexity for maximal IS problems","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Typically higher than for standard independent set problems","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Figure (b): Wall clock time comparison:","category":"page"},{"location":"performancetips/","page":"Performance Tips","title":"Performance Tips","text":"Counting maximal ISs is much more efficient than enumeration\nOur tensor network approach is slightly faster than Bron-Kerbosch for enumerating maximal ISs","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"EditURL = \"../../../examples/MaximalIS.jl\"","category":"page"},{"location":"generated/MaximalIS/#Maximal-Independent-Set-Problem","page":"Maximal independent set problem","title":"Maximal Independent Set Problem","text":"","category":"section"},{"location":"generated/MaximalIS/#Overview","page":"Maximal independent set problem","title":"Overview","text":"","category":"section"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"A maximal independent set is an independent set that cannot be expanded by including more vertices. Unlike a maximum independent set, it's not necessarily the largest possible independent set.","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"This example demonstrates:","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Finding maximal independent sets\nComputing the independence polynomial\nFinding minimum maximal independent sets\nComparing with traditional algorithms","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"We'll explore these concepts using the Petersen graph.","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"using GenericTensorNetworks, Graphs","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Create a Petersen graph instance","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"graph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Define vertex layout for visualization","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\nlocations = [[rot15(0.0, 60.0, i) for i=0:4]..., [rot15(0.0, 30, i) for i=0:4]...]\nshow_graph(graph, locations; format=:svg)","category":"page"},{"location":"generated/MaximalIS/#Tensor-Network-Formulation","page":"Maximal independent set problem","title":"Tensor Network Formulation","text":"","category":"section"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Define the maximal independent set problem:","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"maximalis = MaximalIS(graph)","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"The problem consists of:","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Independence constraints: No adjacent vertices can be selected\nMaximality constraints: No more vertices can be added while maintaining independence","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"constraints(maximalis)","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"objectives(maximalis)","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Convert to tensor network representation:","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"problem = GenericTensorNetwork(maximalis)","category":"page"},{"location":"generated/MaximalIS/#Mathematical-Background","page":"Maximal independent set problem","title":"Mathematical Background","text":"","category":"section"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"For a graph G=(VE), we assign a boolean variable s_v  01 to each vertex. For vertex v with neighborhood N(v), we define tensor:","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"T(x_v)_s_1s_N(v)s_v =\nbegincases\ns_v x_v^w_v  textif all neighbors are 0 (v must be included for maximality) \n1-s_v  textif any neighbor is 1 (v must be excluded for independence)\nendcases","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Note: This tensor network is often more complex to contract than the regular independent set problem, as its complexity isn't directly tied to the graph's tree-width.","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"contraction_complexity(problem)","category":"page"},{"location":"generated/MaximalIS/#Solution-Analysis","page":"Maximal independent set problem","title":"Solution Analysis","text":"","category":"section"},{"location":"generated/MaximalIS/#1.-Independence-Polynomial","page":"Maximal independent set problem","title":"1. Independence Polynomial","text":"","category":"section"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"The maximal independence polynomial I_textmax(Gx) = sum_i b_i x^i counts maximal independent sets by size, where b_i is the number of sets of size i","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"maximal_indenpendence_polynomial = solve(problem, GraphPolynomial())[]","category":"page"},{"location":"generated/MaximalIS/#2.-Independent-Domination-Number","page":"Maximal independent set problem","title":"2. Independent Domination Number","text":"","category":"section"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Find the size of the smallest maximal independent set:","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"independent_domination_number = solve(problem, SizeMin())[]","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Count minimum maximal independent sets:","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"counting_min_maximal_independent_set = solve(problem, CountingMin())[]","category":"page"},{"location":"generated/MaximalIS/#3.-Configuration-Analysis","page":"Maximal independent set problem","title":"3. Configuration Analysis","text":"","category":"section"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Find all maximal independent sets:","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"maximal_configs = read_config(solve(problem, ConfigsAll())[])","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Verify solutions are valid:","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"all(c->is_maximal_independent_set(graph, c), maximal_configs)","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Visualize all maximal independent sets:","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"show_configs(graph, locations, reshape(collect(maximal_configs), 3, 5); padding_left=20)","category":"page"},{"location":"generated/MaximalIS/#4.-Comparison-with-Classical-Algorithms","page":"Maximal independent set problem","title":"4. Comparison with Classical Algorithms","text":"","category":"section"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Compare with Bron-Kerbosch algorithm on complement graph:","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"cliques = maximal_cliques(complement(graph))","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Note: For sparse graphs, our tensor network approach is typically faster and more memory efficient than Bron-Kerbosch.","category":"page"},{"location":"generated/MaximalIS/#5.-Minimum-Maximal-Independent-Sets","page":"Maximal independent set problem","title":"5. Minimum Maximal Independent Sets","text":"","category":"section"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Find all minimum maximal independent sets:","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"minimum_maximal_configs = read_config(solve(problem, ConfigsMin())[])","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Visualize minimum maximal independent sets:","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"show_configs(graph, locations, reshape(collect(minimum_maximal_configs), 2, 5); padding_left=20)","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"Note: For finding just one minimum maximal independent set, use the SingleConfigMin property instead","category":"page"},{"location":"generated/MaximalIS/#More-APIs","page":"Maximal independent set problem","title":"More APIs","text":"","category":"section"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"The Independent Set Problem chapter has more examples on how to use the APIs.","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"","category":"page"},{"location":"generated/MaximalIS/","page":"Maximal independent set problem","title":"Maximal independent set problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"EditURL = \"../../../examples/MaxCut.jl\"","category":"page"},{"location":"generated/MaxCut/#Maximum-Cut-Problem","page":"Cutting problem","title":"Maximum Cut Problem","text":"","category":"section"},{"location":"generated/MaxCut/#Overview","page":"Cutting problem","title":"Overview","text":"","category":"section"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"A cut in graph theory divides vertices into two disjoint subsets. The size of a cut is measured by the number of edges (or sum of edge weights) that cross between the subsets. The Maximum Cut (MaxCut) problem seeks to find a cut with the largest possible size.","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"Key concepts covered:","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"Finding maximum cuts\nComputing cut polynomials\nVisualizing cut configurations","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"This example uses the Petersen graph to demonstrate these concepts.","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"using GenericTensorNetworks, Graphs","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"Create a Petersen graph instance","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"graph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"Define vertex layout for visualization","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\nlocations = [[rot15(0.0, 60.0, i) for i=0:4]..., [rot15(0.0, 30, i) for i=0:4]...]\nshow_graph(graph, locations; format=:svg)","category":"page"},{"location":"generated/MaxCut/#Tensor-Network-Formulation","page":"Cutting problem","title":"Tensor Network Formulation","text":"","category":"section"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"Define the MaxCut problem using tensor networks:","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"maxcut = MaxCut(graph)","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"The objective is to maximize the number of edges crossing the cut","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"objectives(maxcut)","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"Convert to tensor network representation:","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"problem = GenericTensorNetwork(maxcut)","category":"page"},{"location":"generated/MaxCut/#Mathematical-Background","page":"Cutting problem","title":"Mathematical Background","text":"","category":"section"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"For a graph G=(VE), we assign a boolean variable s_v  01 to each vertex, indicating which subset it belongs to. The tensor network uses:","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"For edge (ij) with weight w_ij:","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"B(x_i x_j w_ij) = beginpmatrix\n   1  x_i^w_ij \n   x_j^w_ij  1\nendpmatrix","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"Contributes x_i^w_ij or x_j^w_ij when vertices are in different subsets","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"The contraction complexity is O(2^tw(G)), where tw(G) is the graph's tree-width.","category":"page"},{"location":"generated/MaxCut/#Solution-Analysis","page":"Cutting problem","title":"Solution Analysis","text":"","category":"section"},{"location":"generated/MaxCut/#1.-Maximum-Cut-Size","page":"Cutting problem","title":"1. Maximum Cut Size","text":"","category":"section"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"Find the size of the maximum cut:","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"max_cut_size = solve(problem, SizeMax())[]","category":"page"},{"location":"generated/MaxCut/#2.-Cut-Polynomial","page":"Cutting problem","title":"2. Cut Polynomial","text":"","category":"section"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"The cut polynomial C(Gx) = sum_i c_i x^i counts cuts by size, where c_i2 is the number of cuts of size i","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"max_config = solve(problem, GraphPolynomial())[]","category":"page"},{"location":"generated/MaxCut/#3.-Maximum-Cut-Configuration","page":"Cutting problem","title":"3. Maximum Cut Configuration","text":"","category":"section"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"Find one maximum cut solution:","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"max_vertex_config = read_config(solve(problem, SingleConfigMax())[])","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"Verify the cut size matches our earlier computation:","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"max_cut_size_verify = cut_size(graph, max_vertex_config)","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"Visualize the maximum cut:","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"show_graph(graph, locations; vertex_colors=[\n    iszero(max_vertex_config[i]) ? \"white\" : \"red\" for i=1:nv(graph)], format=:svg)","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"Note: Red and white vertices represent the two disjoint subsets of the cut","category":"page"},{"location":"generated/MaxCut/#More-APIs","page":"Cutting problem","title":"More APIs","text":"","category":"section"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"The Independent Set Problem chapter has more examples on how to use the APIs.","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"","category":"page"},{"location":"generated/MaxCut/","page":"Cutting problem","title":"Cutting problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"EditURL = \"../../../examples/saveload.jl\"","category":"page"},{"location":"generated/saveload/#Saving-and-Loading-Solutions","page":"Save and load solutions","title":"Saving and Loading Solutions","text":"","category":"section"},{"location":"generated/saveload/#Overview","page":"Save and load solutions","title":"Overview","text":"","category":"section"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"When working with large solution spaces, it's often necessary to save results to disk for later analysis or to share with other tools. This example demonstrates how to:","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"Save and load configuration enumerators\nSave and load sum-product trees\nExport solutions for use in Python","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"We'll use the Maximum Independent Set problem on the Petersen graph as our example.","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"using GenericTensorNetworks, Graphs","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"Create our problem instance","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"problem = GenericTensorNetwork(IndependentSet(Graphs.smallgraph(:petersen)))","category":"page"},{"location":"generated/saveload/#Saving-Configuration-Enumerators","page":"Save and load solutions","title":"Saving Configuration Enumerators","text":"","category":"section"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"First, let's enumerate all independent sets","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"all_independent_sets = solve(problem, ConfigsAll())[]","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"The result is a ConfigEnumerator instance containing all valid configurations. We can save this to disk and load it later:","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"Create a temporary file for demonstration","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"filename = tempname()","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"Save configurations in binary format (most efficient)","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"save_configs(filename, all_independent_sets; format=:binary)","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"Load configurations from the saved file","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"loaded_sets = load_configs(filename; format=:binary, bitlength=10)","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"note: Note\nWhen loading data in binary format, you must specify the bitlength parameter, which represents the number of bits used for each configuration. In this example, the Petersen graph has 10 vertices, so we use bitlength=10.","category":"page"},{"location":"generated/saveload/#Saving-Sum-Product-Trees","page":"Save and load solutions","title":"Saving Sum-Product Trees","text":"","category":"section"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"For larger solution spaces, the SumProductTree format is more memory-efficient. It stores solutions in a compressed tree structure:","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"Generate solutions using tree storage","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"all_independent_sets_tree = solve(problem, ConfigsAll(; tree_storage=true))[]","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"Save the sum-product tree","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"save_sumproduct(filename, all_independent_sets_tree)","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"Load the sum-product tree","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"loaded_sets_tree = load_sumproduct(filename)","category":"page"},{"location":"generated/saveload/#Interoperability-with-Python","page":"Save and load solutions","title":"Interoperability with Python","text":"","category":"section"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"The binary format can be loaded in Python for further analysis. Here's a Python function to load and unpack the solutions as a NumPy array:","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"import numpy as np\n\ndef loadfile(filename: str, bitlength: int):\n    \"\"\"\n    Load binary configuration data saved by GenericTensorNetworks.jl\n\n    Parameters:\n    -----------\n    filename : str\n        Path to the binary file\n    bitlength : int\n        Number of bits per configuration (typically number of vertices)\n\n    Returns:\n    --------\n    numpy.ndarray\n        2D array where each row is a configuration\n    \"\"\"\n    C = int(np.ceil(bitlength / 64))\n    arr = np.fromfile(filename, dtype=\"uint8\")\n    # Transform from big endian to little endian\n    res = np.unpackbits(arr).reshape(-1, C, 8, 8)[:,::-1,::-1,:]\n    res = res.reshape(-1, C*64)[:, :(64*C-bitlength)-1:-1]\n    print(f\"Number of solutions: {len(res)}\")\n    return res  # in big endian format\n\n# Example usage:\nsolutions = loadfile(filename, 10)","category":"page"},{"location":"generated/saveload/#Additional-Resources","page":"Save and load solutions","title":"Additional Resources","text":"","category":"section"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"For more examples of working with solution spaces:","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"See the Maximal Independent Set Problem section for examples of:\nUsing SizeMin to find minimum set sizes\nUsing CountingMin to count minimum set sizes\nUsing SingleConfigMin to find one minimum solution\nUsing ConfigsMin to enumerate all minimum solutions","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"","category":"page"},{"location":"generated/saveload/","page":"Save and load solutions","title":"Save and load solutions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"EditURL = \"../../../examples/SetCovering.jl\"","category":"page"},{"location":"generated/SetCovering/#Set-Covering-Problem","page":"Set covering problem","title":"Set Covering Problem","text":"","category":"section"},{"location":"generated/SetCovering/#Overview","page":"Set covering problem","title":"Overview","text":"","category":"section"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"The Set Covering Problem is a fundamental optimization challenge: given a collection of sets, find the minimum number of sets needed to cover all elements. This NP-hard problem appears in many real-world applications including facility location, scheduling, and resource allocation.","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"This example demonstrates:","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"Formulating a set covering problem\nConverting it to a tensor network\nFinding minimum set covers\nAnalyzing the solution space","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"We'll use the camera location and stadium area example from the Cornell University Computational Optimization Open Textbook.","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"using GenericTensorNetworks, Graphs","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"Define our sets (each representing a camera's coverage area)","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"sets = [[1,3,4,6,7], [4,7,8,12], [2,5,9,11,13],\n    [1,2,14,15], [3,6,10,12,14], [8,14,15],\n    [1,2,6,11], [1,2,4,6,8,12]]","category":"page"},{"location":"generated/SetCovering/#Tensor-Network-Formulation","page":"Set covering problem","title":"Tensor Network Formulation","text":"","category":"section"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"Define the set covering problem:","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"setcover = SetCovering(sets)","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"The problem consists of:","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"Coverage constraints: Every element must be covered by at least one set\nOptimization objective: Minimize the number of sets used","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"constraints(setcover)","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"objectives(setcover)","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"Convert to tensor network representation:","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"problem = GenericTensorNetwork(setcover)","category":"page"},{"location":"generated/SetCovering/#Mathematical-Background","page":"Set covering problem","title":"Mathematical Background","text":"","category":"section"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"For each set s with weight w_s, we assign a boolean variable v_s  01, indicating whether the set is included in the solution.","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"The network uses two types of tensors:","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"Set Tensors: For each set s:\nW(x_s w_s) = beginpmatrix\n    1 \n    x_s^w_s\nendpmatrix\nElement Constraint Tensors: For each element a and its containing sets N(a):\nB_s_1s_N(a) =\nbegincases\n    0  textif all  s_i = 0 text (element not covered - invalid) \n    1  textotherwise (element is covered - valid)\nendcases","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"Check the contraction complexity:","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"contraction_complexity(problem)","category":"page"},{"location":"generated/SetCovering/#Solution-Analysis","page":"Set covering problem","title":"Solution Analysis","text":"","category":"section"},{"location":"generated/SetCovering/#1.-Set-Covering-Polynomial","page":"Set covering problem","title":"1. Set Covering Polynomial","text":"","category":"section"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"The polynomial P(Sx) = sum_i c_i x^i counts set covers by size, where c_i is the number of valid covers using i sets","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"covering_polynomial = solve(problem, GraphPolynomial())[]","category":"page"},{"location":"generated/SetCovering/#2.-Minimum-Set-Cover-Size","page":"Set covering problem","title":"2. Minimum Set Cover Size","text":"","category":"section"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"Find the minimum number of sets needed:","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"min_cover_size = solve(problem, SizeMin())[]","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"Count minimum set covers:","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"counting_minimum_setcovering = solve(problem, CountingMin())[]","category":"page"},{"location":"generated/SetCovering/#3.-Minimum-Set-Cover-Configurations","page":"Set covering problem","title":"3. Minimum Set Cover Configurations","text":"","category":"section"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"Enumerate all minimum set covers:","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"min_configs = read_config(solve(problem, ConfigsMin())[])","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"The two optimal solutions are z_1 z_3 z_5 z_6 and z_2 z_3 z_4 z_5, where z_i represents the i-th set in our original list.","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"Verify solutions are valid:","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"all(c->is_set_covering(problem.problem, c), min_configs)","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"Note: For finding just one minimum set cover, use the SingleConfigMin property","category":"page"},{"location":"generated/SetCovering/#More-APIs","page":"Set covering problem","title":"More APIs","text":"","category":"section"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"The Independent Set Problem chapter has more examples on how to use the APIs.","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"","category":"page"},{"location":"generated/SetCovering/","page":"Set covering problem","title":"Set covering problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"gist/#Gist-of-implementation","page":"Gist","title":"Gist of implementation","text":"","category":"section"},{"location":"gist/","page":"Gist","title":"Gist","text":"The code we will show below is a gist of how this package is implemented for pedagogical purpose, which covers many functionalities of the main repo without caring much about performance. This project depends on multiple open source packages in the Julia ecosystem:","category":"page"},{"location":"gist/","page":"Gist","title":"Gist","text":"OMEinsum and OMEinsumContractionOrders are packages providing the support for Einstein's (or tensor network) notation and state-of-the-art algorithms for contraction order optimization, which includes multiple state of the art algorithms.\nTropicalNumbers and TropicalGEMM are packages providing tropical number and efficient tropical matrix multiplication.\nGraphs is a foundational package for graph manipulation in the Julia community.\nPolynomials is a package providing polynomial algebra and polynomial fitting.\nMods and the Primes package providing finite field algebra and prime number manipulation.","category":"page"},{"location":"gist/","page":"Gist","title":"Gist","text":"They can be installed in a similar way to GenericTensorNetworks. After installing the required packages, one can open a Julia REPL, and copy-paste the following code snippet into it.","category":"page"},{"location":"gist/","page":"Gist","title":"Gist","text":"using OMEinsum\nusing Graphs\nusing Random\n\n# generate a random regular graph of size 50, degree 3\ngraph = (Random.seed!(2); Graphs.random_regular_graph(50, 3))\n\n# generate einsum code, i.e. the labels of tensors\ncode = EinCode(([minmax(e.src,e.dst) for e in Graphs.edges(graph)]..., # labels for edge tensors\n                [(i,) for i in Graphs.vertices(graph)]...), ())        # labels for vertex tensors\n\n# an einsum contraction without a contraction order specified is called `EinCode`,\n# an einsum contraction having a contraction order (specified as a tree structure) is called `NestedEinsum`.\n# assign each label a dimension-2, it will be used in the contraction order optimization\n# `uniquelabels` function extracts the tensor labels into a vector.\nsize_dict = Dict([s=>2 for s in uniquelabels(code)])\n# optimize the contraction order using the `TreeSA` method; the target space complexity is 2^17\noptimized_code = optimize_code(code, size_dict, TreeSA())\nprintln(\"time/space complexity is $(OMEinsum.timespace_complexity(optimized_code, size_dict))\")\n\n# a function for computing the independence polynomial\nfunction independence_polynomial(x::T, code) where {T}\n\txs = map(getixsv(code)) do ix\n        # if the tensor rank is 1, create a vertex tensor.\n        # otherwise the tensor rank must be 2, create a bond tensor.\n        length(ix)==1 ? [one(T), x] : [one(T) one(T); one(T) zero(T)]\n    end\n    # both `EinCode` and `NestedEinsum` are callable, inputs are tensors.\n\tcode(xs...)\nend\n\n########## COMPUTING THE MAXIMUM INDEPENDENT SET SIZE AND ITS COUNTING/DEGENERACY ###########\n\n# using Tropical numbers to compute the MIS size and the MIS degeneracy.\nusing TropicalNumbers\nmis_size(code) = independence_polynomial(TropicalF64(1.0), code)[]\nprintln(\"the maximum independent set size is $(mis_size(optimized_code).n)\")\n\n# A `CountingTropical` object has two fields, tropical field `n` and counting field `c`.\nmis_count(code) = independence_polynomial(CountingTropical{Float64,Float64}(1.0, 1.0), code)[]\nprintln(\"the degeneracy of maximum independent sets is $(mis_count(optimized_code).c)\")\n\n########## COMPUTING THE INDEPENDENCE POLYNOMIAL ###########\n\n# using Polynomial numbers to compute the polynomial directly\nusing Polynomials\nprintln(\"the independence polynomial is $(independence_polynomial(Polynomial([0.0, 1.0]), optimized_code)[])\")\n\n########## FINDING MIS CONFIGURATIONS ###########\n\n# define the set algebra\nstruct ConfigEnumerator{N}\n    # NOTE: BitVector is dynamic and it can be very slow; check our repo for the static version\n    data::Vector{BitVector}\nend\nfunction Base.:+(x::ConfigEnumerator{N}, y::ConfigEnumerator{N}) where {N}\n    res = ConfigEnumerator{N}(vcat(x.data, y.data))\n    return res\nend\nfunction Base.:*(x::ConfigEnumerator{L}, y::ConfigEnumerator{L}) where {L}\n    M, N = length(x.data), length(y.data)\n    z = Vector{BitVector}(undef, M*N)\n    for j=1:N, i=1:M\n        z[(j-1)*M+i] = x.data[i] .| y.data[j]\n    end\n    return ConfigEnumerator{L}(z)\nend\nBase.zero(::Type{ConfigEnumerator{N}}) where {N} = ConfigEnumerator{N}(BitVector[])\nBase.one(::Type{ConfigEnumerator{N}}) where {N} = ConfigEnumerator{N}([falses(N)])\n\n# the algebra sampling one of the configurations\nstruct ConfigSampler{N}\n    data::BitVector\nend\n\nfunction Base.:+(x::ConfigSampler{N}, y::ConfigSampler{N}) where {N}  # biased sampling: return `x`\n    return x  # randomly pick one\nend\nfunction Base.:*(x::ConfigSampler{L}, y::ConfigSampler{L}) where {L}\n    ConfigSampler{L}(x.data .| y.data)\nend\n\nBase.zero(::Type{ConfigSampler{N}}) where {N} = ConfigSampler{N}(trues(N))\nBase.one(::Type{ConfigSampler{N}}) where {N} = ConfigSampler{N}(falses(N))\n\n# enumerate all configurations if `all` is true; compute one otherwise.\n# a configuration is stored in the data type of `StaticBitVector`; it uses integers to represent bit strings.\n# `ConfigTropical` is defined in `TropicalNumbers`. It has two fields: tropical number `n` and optimal configuration `config`.\n# `CountingTropical{T,<:ConfigEnumerator}` stores configurations instead of simple counting.\nfunction mis_config(code; all=false)\n    # map a vertex label to an integer\n    vertex_index = Dict([s=>i for (i, s) in enumerate(uniquelabels(code))])\n    N = length(vertex_index)  # number of vertices\n    xs = map(getixsv(code)) do ix\n        T = all ? CountingTropical{Float64, ConfigEnumerator{N}} : CountingTropical{Float64, ConfigSampler{N}}\n        if length(ix) == 2\n            return [one(T) one(T); one(T) zero(T)]\n        else\n            s = falses(N)\n            s[vertex_index[ix[1]]] = true  # one hot vector\n            if all\n                [one(T), T(1.0, ConfigEnumerator{N}([s]))]\n            else\n                [one(T), T(1.0, ConfigSampler{N}(s))]\n            end\n        end\n    end\n\treturn code(xs...)\nend\n\nprintln(\"one of the optimal configurations is $(mis_config(optimized_code; all=false)[].c.data)\")\n\n# direct enumeration of configurations can be very slow; please check the bounding version in our Github repo.\nprintln(\"all optimal configurations are $(mis_config(optimized_code; all=true)[].c)\")","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"EditURL = \"../../../examples/DominatingSet.jl\"","category":"page"},{"location":"generated/DominatingSet/#Dominating-Set-Problem","page":"Dominating set problem","title":"Dominating Set Problem","text":"","category":"section"},{"location":"generated/DominatingSet/#Overview","page":"Dominating set problem","title":"Overview","text":"","category":"section"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"A dominating set in graph theory is a subset D of vertices where every vertex in the graph either belongs to D or is adjacent to a vertex in D. The domination number γ(G) is the size of the smallest possible dominating set. This example demonstrates how to:","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"Find the domination number\nCount and enumerate dominating sets\nCompute the domination polynomial","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"We'll explore these concepts using the Petersen graph as our example.","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"using GenericTensorNetworks, Graphs","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"Create a Petersen graph instance","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"graph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"Define vertex layout for visualization","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\nlocations = [[rot15(0.0, 60.0, i) for i=0:4]..., [rot15(0.0, 30, i) for i=0:4]...]\nshow_graph(graph, locations; format=:svg)","category":"page"},{"location":"generated/DominatingSet/#Tensor-Network-Formulation","page":"Dominating set problem","title":"Tensor Network Formulation","text":"","category":"section"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"We represent the dominating set problem using tensor networks:","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"dom = DominatingSet(graph)","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"The problem has two components:","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"Domination constraints: Every vertex must be dominated\nOptimization objective: Minimize the size of the dominating set","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"constraints(dom)","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"objectives(dom)","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"Convert to tensor network representation with optimized contraction order:","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"problem = GenericTensorNetwork(dom; optimizer=TreeSA())","category":"page"},{"location":"generated/DominatingSet/#Mathematical-Background","page":"Dominating set problem","title":"Mathematical Background","text":"","category":"section"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"For a graph G=(VE), we assign a boolean variable s_v in 01 to each vertex v. The tensor network uses the following components:","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"Vertex Tensors: For vertex v and its neighbors N(v):\nT(x_v)_s_1s_N(v)s_v =\nbegincases\n    0  textif all  s text values are  0 text (invalid configuration) \n    1  textif  s_v = 0 text (vertex not in set) \n    x_v^w_v  textotherwise (vertex in set)\nendcases","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"Check the contraction complexity:","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"contraction_complexity(problem)","category":"page"},{"location":"generated/DominatingSet/#Solution-Analysis","page":"Dominating set problem","title":"Solution Analysis","text":"","category":"section"},{"location":"generated/DominatingSet/#1.-Domination-Polynomial","page":"Dominating set problem","title":"1. Domination Polynomial","text":"","category":"section"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"The domination polynomial D(Gx) = sum_i d_i x^i counts dominating sets by size, where d_i is the number of dominating sets of size i.","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"domination_polynomial = solve(problem, GraphPolynomial())[]","category":"page"},{"location":"generated/DominatingSet/#2.-Minimum-Dominating-Set","page":"Dominating set problem","title":"2. Minimum Dominating Set","text":"","category":"section"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"Find the domination number γ(G):","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"domination_number = solve(problem, SizeMin())[]","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"Count minimum dominating sets:","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"counting_min_dominating_set = solve(problem, CountingMin())[]","category":"page"},{"location":"generated/DominatingSet/#3.-Configuration-Analysis","page":"Dominating set problem","title":"3. Configuration Analysis","text":"","category":"section"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"Enumerate all minimum dominating sets:","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"min_configs = read_config(solve(problem, ConfigsMin())[])","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"Verify solutions are valid:","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"all(c->is_dominating_set(graph, c), min_configs)","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"Visualize all minimum dominating sets:","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"show_configs(graph, locations, reshape(collect(min_configs), 2, 5); padding_left=20)","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"Note: For finding just one minimum dominating set, use SingleConfigMin property","category":"page"},{"location":"generated/DominatingSet/#More-APIs","page":"Dominating set problem","title":"More APIs","text":"","category":"section"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"The Independent Set Problem chapter has more examples on how to use the APIs.","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"","category":"page"},{"location":"generated/DominatingSet/","page":"Dominating set problem","title":"Dominating set problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"EditURL = \"../../../examples/weighted.jl\"","category":"page"},{"location":"generated/weighted/#Weighted-Problems","page":"Weighted problems","title":"Weighted Problems","text":"","category":"section"},{"location":"generated/weighted/#Overview","page":"Weighted problems","title":"Overview","text":"","category":"section"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"Many optimization problems involve weights associated with vertices or edges. This example demonstrates how to:","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"Define weighted problem instances\nSolve for optimal configurations\nAnalyze the energy spectrum of solutions\nVisualize weighted solutions","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"We'll use the Maximum Weighted Independent Set problem on the Petersen graph as our example.","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"using GenericTensorNetworks, GenericTensorNetworks.ProblemReductions, Graphs","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"Create a Petersen graph instance","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"graph = Graphs.smallgraph(:petersen)","category":"page"},{"location":"generated/weighted/#Defining-Weighted-Problems","page":"Weighted problems","title":"Defining Weighted Problems","text":"","category":"section"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"Create a weighted independent set problem where each vertex i has weight i","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"problem = GenericTensorNetwork(IndependentSet(graph, collect(1:10)))","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"Examine the weights assigned to each vertex","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"GenericTensorNetworks.weights(problem)","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"The tensor labels associated with these weights can be accessed via:","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"ProblemReductions.local_solution_spec(problem.problem)","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"Note: You can use a vector for custom weights or UnitWeight() for unweighted problems. Most solution space properties that work for unweighted graphs also work for weighted graphs.","category":"page"},{"location":"generated/weighted/#Finding-Optimal-Solutions","page":"Weighted problems","title":"Finding Optimal Solutions","text":"","category":"section"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"Find the maximum weighted independent set:","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"max_config_weighted = solve(problem, SingleConfigMax())[]","category":"page"},{"location":"generated/weighted/#Visualizing-Solutions","page":"Weighted problems","title":"Visualizing Solutions","text":"","category":"section"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"Define vertex layout for visualization","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"rot15(a, b, i::Int) = cos(2i*π/5)*a + sin(2i*π/5)*b, cos(2i*π/5)*b - sin(2i*π/5)*a\nlocations = [[rot15(0.0, 60.0, i) for i=0:4]..., [rot15(0.0, 30, i) for i=0:4]...]","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"Visualize the maximum weighted independent set","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"show_graph(graph, locations; format=:svg, vertex_colors=\n    [iszero(max_config_weighted.c.data[i]) ? \"white\" : \"red\" for i=1:nv(graph)])","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"Note: The GraphPolynomial property is the only solution space property that cannot be defined for general real-weighted graphs (though it works for integer-weighted graphs).","category":"page"},{"location":"generated/weighted/#Analyzing-the-Energy-Spectrum","page":"Weighted problems","title":"Analyzing the Energy Spectrum","text":"","category":"section"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"For weighted problems, it's often useful to examine the \"energy spectrum\" - the distribution of weights across different configurations.","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"Compute the 10 largest weights and their configurations:","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"spectrum = solve(problem, SizeMax(10))[]","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"The result is an ExtendedTropical object containing the ordered weights:","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"spectrum.orders","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"Each element in orders is a Tropical number representing a solution weight.","category":"page"},{"location":"generated/weighted/#Finding-Multiple-Top-Solutions","page":"Weighted problems","title":"Finding Multiple Top Solutions","text":"","category":"section"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"Find the 5 independent sets with the highest weights:","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"max5_configs = read_config(solve(problem, SingleConfigMax(5))[])","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"The return value contains CountingTropical{Float64,ConfigSampler} objects that store both the weights and configurations.","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"Visualize these top 5 configurations:","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"show_configs(graph, locations, [max5_configs[j] for i=1:1, j=1:5]; padding_left=20)","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"Each configuration represents an independent set with one of the 5 highest total weights.","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"","category":"page"},{"location":"generated/weighted/","page":"Weighted problems","title":"Weighted problems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"ref/#References","page":"References","title":"References","text":"","category":"section"},{"location":"ref/#Constraint-Satisfaction-Problems","page":"References","title":"Constraint Satisfaction Problems","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"solve\nGenericTensorNetwork\nConstraintSatisfactionProblem\nIndependentSet\nMaximalIS\nMatching\nColoring\nDominatingSet\nSpinGlass\nMaxCut\nPaintShop\nSatisfiability\nSetCovering\nSetPacking","category":"page"},{"location":"ref/#GenericTensorNetworks.solve","page":"References","title":"GenericTensorNetworks.solve","text":"solve(problem, property; usecuda=false, T=Float64)\n\nSolving a certain property of a graph problem.\n\nPositional Arguments\n\nproblem is the graph problem with tensor network information,\nproperty is string specifying the task. Using the maximum independent set problem as an example, it can be one of\nPartitionFunction() for computing the partition function,\nSizeMax(k=Single) for finding maximum-k set sizes,\nSizeMin(k=Single) for finding minimum-k set sizes,\nCountingMax(k=Single) for counting configurations with maximum-k sizes,\nCountingMin(k=Single) for counting configurations with minimum-k sizes,\nCountingAll() for counting all configurations,\nPartitionFunction() for counting all configurations,\nGraphPolynomial(; method=:finitefield, kwargs...) for evaluating the graph polynomial,\nSingleConfigMax(k=Single; bounded=false) for finding one maximum-k configuration for each size,\nSingleConfigMin(k=Single; bounded=false) for finding one minimum-k configuration for each size,\nConfigsMax(k=Single; bounded=true, tree_storage=false) for enumerating configurations with maximum-k sizes,\nConfigsMin(k=Single; bounded=true, tree_storage=false) for enumerating configurations with minimum-k sizes,\nConfigsAll(; tree_storage=false) for enumerating all configurations,\n\nKeyword arguments\n\nusecuda is a switch to use CUDA (if possible), user need to call statement using CUDA before turning on this switch.\nT is the \"base\" element type, sometimes can be used to reduce the memory cost.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.GenericTensorNetwork","page":"References","title":"GenericTensorNetworks.GenericTensorNetwork","text":"struct GenericTensorNetwork{CFG, CT, LT}\n\nGenericTensorNetwork(problem::ConstraintSatisfactionProblem; openvertices=(), fixedvertices=Dict(), optimizer=GreedyMethod())\n\nThe generic tensor network that generated from a ConstraintSatisfactionProblem.\n\nPositional arguments\n\nproblem is the graph problem.\ncode is the tensor network contraction code.\nfixedvertices is a dictionary specifying the fixed dimensions.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.ConstraintSatisfactionProblem","page":"References","title":"ProblemReductions.ConstraintSatisfactionProblem","text":"ConstraintSatisfactionProblem{T} <: AbstractProblem\n\nThe abstract base type of constraint satisfaction problems. T is the type of the local size of the constraints.\n\nRequired interfaces\n\nconstraints, the specification of the constraints. Once the constraints are violated, the size goes to infinity.\nobjectives, the specification of the size terms as soft constraints, which is associated with weights.\n\nOptional interfaces\n\nweights: The weights of the soft constraints.\nset_weights: Change the weights for the problem and return a new problem instance.\n\nDerived interfaces\n\nis_satisfied, check if the constraints are satisfied.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.IndependentSet","page":"References","title":"ProblemReductions.IndependentSet","text":"struct IndependentSet{GT<:Graphs.AbstractGraph, T, WT<:AbstractArray{T, 1}} <: ConstraintSatisfactionProblem{T}\n\nIndependentSet(graph::AbstractGraph, weights::AbstractVector=UnitWeight(nv(graph))) -> IndependentSet\n\nIndependent Set is a subset of vertices in a undirected graph such that all the vertices in the set are not connected by edges (or called not adjacent). The maximum IndependentSet problem is to find the independent set with maximum number of vertices, which is a NP-complete problem. Let G=(V E) be a graph, and w_v be the weight of vertex v. The energy based model of the independent set problem is:\n\nH(G mathbfn) = - sum_v in V w_v n_v + sum_(u v) in E n_u n_v\n\nwhere n_v is the number of vertices in the independent set, i.e. n_v = 1 if v is in the independent set, and n_v = 0 otherwise. The larger the size of the independent set, the lower the energy.\n\nFields\n\ngraph::AbstractGraph: The problem graph.\nweights::AbstractVector: Weights associated with the vertices of the graph. Defaults to UnitWeight(nv(graph)).\n\nExample\n\nIn the following example, we define an independent set problem on a graph with four vertices. To define an IndependentSet problem, we need to specify the graph and possibily the weights associated with vertices. The weights are set as unit by default in the current version and might be generalized to arbitrary positive weights.\n\njulia> using ProblemReductions, Graphs\n\njulia> graph = SimpleGraph(Graphs.SimpleEdge.([(1, 2), (1, 3), (3, 4), (2, 3)]))\n{4, 4} undirected simple Int64 graph\n\njulia> IS = IndependentSet(graph)\nIndependentSet{SimpleGraph{Int64}, Int64, UnitWeight}(SimpleGraph{Int64}(4, [[2, 3], [1, 3], [1, 2, 4], [3]]), [1, 1, 1, 1])\n\njulia> num_variables(IS)  # degrees of freedom\n4\n\njulia> flavors(IS)  # flavors of the vertices\n(0, 1)\n\njulia> solution_size(IS, [1, 0, 0, 1]) # Positive sample: -(size) of an independent set\nSolutionSize{Int64}(2, true)\n\njulia> solution_size(IS, [0, 1, 1, 0]) # Negative sample: 0\nSolutionSize{Int64}(2, false)\n\njulia> findbest(IS, BruteForce())  # solve the problem with brute force\n2-element Vector{Vector{Int64}}:\n [1, 0, 0, 1]\n [0, 1, 0, 1]\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.MaximalIS","page":"References","title":"ProblemReductions.MaximalIS","text":"struct MaximalIS{T, WT<:AbstractArray{T, 1}} <: ConstraintSatisfactionProblem{T}\n\nMaximal independent set is a problem that very similar to the IndependentSet problem. The difference is that the solution space of a maximal indepdent set problem does not include the independent sets that can be extended by adding one more vertex.\n\nFields\n\ngraph is the problem graph.\nweights are associated with the vertices of the graph.\n\nExample\n\nIn the following example, we define a maximal independent set problem on a graph with four vertices. To define a MaximalIS problem, we need to specify the graph and possibily the weights associated with vertices. The weights are set as unit by default in the current version and might be generalized to arbitrary positive weights in the following development.\n\njulia> using ProblemReductions, Graphs\n\njulia> graph = SimpleGraph(Graphs.SimpleEdge.([(1, 2), (1, 3), (3, 4), (2, 3), (1, 4)]))\n{4, 5} undirected simple Int64 graph\n\njulia> problem = MaximalIS(graph)\nMaximalIS{Int64, UnitWeight}(SimpleGraph{Int64}(5, [[2, 3, 4], [1, 3], [1, 2, 4], [1, 3]]), [1, 1, 1, 1])\n\njulia> num_variables(problem)  # degrees of freedom\n4\n\njulia> flavors(problem)\n(0, 1)\n\njulia> solution_size(problem, [0, 1, 0, 0])  # unlike the independent set, this configuration is not a valid solution\nSolutionSize{Int64}(1, false)\n\njulia> findbest(problem, BruteForce())\n1-element Vector{Vector{Int64}}:\n [0, 1, 0, 1]\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.Matching","page":"References","title":"ProblemReductions.Matching","text":"struct Matching{T, WT<:AbstractArray{T, 1}} <: ConstraintSatisfactionProblem{T}\n\nThe Vertex matching problem.\n\nPositional arguments\n\ngraph is the problem graph.\nweights are associated with the edges of the graph.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.Coloring","page":"References","title":"ProblemReductions.Coloring","text":"struct Coloring{K, T, WT<:AbstractArray{T, 1}, OBJ} <: ConstraintSatisfactionProblem{T}\n\nColoring{K}(graph; weights=UnitWeight(nv(graph)), use_constraints::Bool=false)\n\nThe Vertex Coloring (Coloring) problem is defined on a simple graph. Given k kinds of colors, we need to determine whether we can color all vertices on the graph such that no two adjacent vertices share the same color.\n\nFields\n\ngraph is the problem graph.\nweights are associated with the edges of the graph, default to UnitWeight(ne(graph)).\n\nExample\n\nTo initialize a Coloring problem, we need to first define a graph and decide the number of colors.\n\njulia> using ProblemReductions, Graphs\n\njulia> g = smallgraph(:petersen) # define a simple graph, petersen as example\n{10, 15} undirected simple Int64 graph\n\njulia> coloring = Coloring{3}(g)  # 3 colors\nColoring{3, Int64, UnitWeight, ProblemReductions.EXTREMA}(SimpleGraph{Int64}(15, [[2, 5, 6], [1, 3, 7], [2, 4, 8], [3, 5, 9], [1, 4, 10], [1, 8, 9], [2, 9, 10], [3, 6, 10], [4, 6, 7], [5, 7, 8]]), [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])\n\njulia> variables(coloring)\n1:10\n\njulia> flavors(coloring)\n(0, 1, 2)\n\njulia> is_vertex_coloring(coloring.graph,[1,2,3,1,3,2,1,2,3,1]) #random assignment\nfalse\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.DominatingSet","page":"References","title":"ProblemReductions.DominatingSet","text":"struct DominatingSet{GT<:Graphs.AbstractGraph, T, WT<:AbstractArray{T, 1}} <: ConstraintSatisfactionProblem{T}\n\nDominatingSet(graph::AbstractGraph, weights::AbstractVector=UnitWeight(ne(graph))) -> DominatingSet\n\nDominaing Set is a subset of vertices in a undirected graph such that all the vertices in the set are either in the dominating set or in its first-order neighborhood. The DominatingSet problem is to find the dominating set with minimum number of vertices.\n\nFields\n\ngraph is the problem graph.\nweights::AbstractVector: Weights associated with the vertices of the graph. Defaults to UnitWeight(nv(graph)).\n\nExample\n\nIn the following example, we define a dominating set problem on a path graph with five vertices. To define a DominatingSet problem, we need to specify the graph and possibily the weights associated with vertices. The weights are set as unit by default in the current version and might be generalized to arbitrary positive weights in the following development.\n\njulia> using ProblemReductions, Graphs\n\njulia> graph = path_graph(5)\n{5, 4} undirected simple Int64 graph\n\njulia> DS = DominatingSet(graph)\nDominatingSet{SimpleGraph{Int64}, Int64, UnitWeight}(SimpleGraph{Int64}(4, [[2], [1, 3], [2, 4], [3, 5], [4]]), [1, 1, 1, 1, 1])\n\njulia> variables(DS)  # degrees of freedom\n1:5\n\njulia> flavors(DS)  # flavors of the vertices\n(0, 1)\n\njulia> solution_size(DS, [0, 1, 0, 1, 0]) # Positive sample: (size) of a dominating set\nSolutionSize{Int64}(2, true)\n\njulia> solution_size(DS, [0, 1, 1, 0, 0]) # Negative sample: number of vertices\nSolutionSize{Int64}(2, false)\n\njulia> findbest(DS, BruteForce())  # solve the problem with brute force\n3-element Vector{Vector{Int64}}:\n [1, 0, 0, 1, 0]\n [0, 1, 0, 1, 0]\n [0, 1, 0, 0, 1]\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.SpinGlass","page":"References","title":"ProblemReductions.SpinGlass","text":"struct SpinGlass{GT<:Graphs.AbstractGraph, T, WT<:AbstractArray{T, 1}} <: ConstraintSatisfactionProblem{T}\n\nSpinGlass(graph::AbstractGraph, weights::AbstractVector)\nSpinGlass(graph::SimpleGraph, J, h=zeros(nv(graph)))\n\nSpin Glass is a type of disordered magnetic system that exhibits a glassy behavior. The Hamiltonian of the system on a simple graph G=(V E) is given by\n\nH(G sigma) = sum_(ij) in E J_ij sigma_i sigma_j + sum_i in V h_i sigma_i\n\nwhere J_ij in mathbbR is the coupling strength between spins i and j, h_i in mathbbR is the external field on spin i, and sigma_i in -1 1 is the spin variable. The configuration of a solution is specified by a binary variable in (0, 1), where 0 and 1 are mapped to spins -1 and 1, respectively.\n\nThis definition naturally extends to the case of a HyperGraph:\n\nH(G sigma) = sum_e in E J_e prod_ksigma_k + sum_i in V h_i sigma_i\n\nwhere J_e is the coupling strength associated with hyperedge e, and the product is over all spins in the hyperedge.\n\nFields\n\ngraph is a graph object.\nJ are the coupling strengths associated with the edges.\nh are the external fields associated with the vertices.\n\nExample\n\nIn the following example, we define a spin glass problem on a 4-vertex graph with given coupling strengths on edges and external fields on vertices.\n\njulia> using ProblemReductions, ProblemReductions.Graphs\n\njulia> graph = SimpleGraph(Graphs.SimpleEdge.([(1, 2), (1, 3), (3, 4), (2, 3)]))\n{4, 4} undirected simple Int64 graph\n\njulia> J = [1, -1, 1, -1]  # coupling strength\n4-element Vector{Int64}:\n  1\n -1\n  1\n -1\n\njulia> h = [1, -1, -1, 1]  # external field\n4-element Vector{Int64}:\n  1\n -1\n -1\n  1\n\njulia> spinglass = SpinGlass(graph, J, h)  # Define a spin glass problem\nSpinGlass{SimpleGraph{Int64}, Int64, Vector{Int64}}(SimpleGraph{Int64}(4, [[2, 3], [1, 3], [1, 2, 4], [3]]), [1, -1, 1, -1], [1, -1, -1, 1])\n\njulia> num_variables(spinglass)  # degrees of freedom\n4\n\njulia> flavors(spinglass)  # flavors of the spins, 0 for up (+1), 1 for down (-1)\n(0, 1)\n\njulia> solution_size(spinglass, [1, 0, 0, 1])  # size of a configuration\nSolutionSize{Int64}(-2, true)\n\njulia> findbest(spinglass, BruteForce())  # solve the problem with brute force\n1-element Vector{Vector{Int64}}:\n [1, 0, 1, 1]\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.MaxCut","page":"References","title":"ProblemReductions.MaxCut","text":"struct MaxCut{T, WT<:AbstractArray{T, 1}} <: ConstraintSatisfactionProblem{T}\n\nMax Cut problem is defined on weighted graphs. The goal is to find a partition of the vertices into two sets such that the sum of the weights of the edges between the two sets is maximized.\n\nPositional arguments\n\ngraph is the problem graph.\nweights are associated with the edges of the graph. We have ensure that the weights are in the same order as the edges in edges(graph).\n\nExample\n\nIn the following example, we solve a Max Cut problem on a complete graph with 3 vertices and edge weights [1,2,3].\n\njulia> using ProblemReductions, Graphs\n\njulia> g = complete_graph(3)\n{3, 3} undirected simple Int64 graph\n\njulia> maxcut = MaxCut(g,[1,2,3]) # specify the weights of the edges\nMaxCut{Int64, Vector{Int64}}(SimpleGraph{Int64}(3, [[2, 3], [1, 3], [1, 2]]), [1, 2, 3])\n\njulia> mc = set_weights(maxcut, [2,1,3]) # set the weights and get a new instance\nMaxCut{Int64, Vector{Int64}}(SimpleGraph{Int64}(3, [[2, 3], [1, 3], [1, 2]]), [2, 1, 3])\n\n\njulia> num_variables(maxcut) # return the number of vertices\n3\n\njulia> flavors(maxcut) # return the flavors of the vertices\n(0, 1)\n\njulia> solution_size(maxcut, [0,1,0]) # return the size of the configuration\nSolutionSize{Int64}(4, true)\n\njulia> findbest(maxcut, BruteForce()) # find the best configuration\n2-element Vector{Vector{Int64}}:\n [1, 1, 0]\n [0, 0, 1]\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.PaintShop","page":"References","title":"ProblemReductions.PaintShop","text":"struct PaintShop{LT} <: ConstraintSatisfactionProblem{Int64}\n\nThe binary paint shop problem is defined as follows: we are given a 2m length sequence containing m cars, where each car appears twice. Each car need to be colored red in one occurrence, and blue in the other. We need to choose which occurrence for each car to color with which color — the goal is to minimize the number of times we need to change the current color.\n\nFields\n\nsequence is a vector of symbols, each symbol is associated with a color.\nisfirst is a vector of boolean numbers, indicating whether the symbol is the first appearance in the sequence.\n\nExample\n\nIn the following example, we define a paint shop problem with 6 cars.\n\njulia> using ProblemReductions\n\njulia> problem = PaintShop([\"a\",\"b\",\"a\",\"c\",\"c\",\"b\"])\nPaintShop{String}([\"a\", \"b\", \"a\", \"c\", \"c\", \"b\"], Bool[1, 1, 0, 1, 0, 0])\n\njulia> num_variables(problem)\n3\n\njulia> flavors(problem)\n(0, 1)\n\njulia> solution_size(problem, [0, 1, 0])\nSolutionSize{Int64}(4, true)\n\njulia> findbest(problem, BruteForce())\n2-element Vector{Vector{Int64}}:\n [1, 0, 0]\n [0, 1, 1]\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.Satisfiability","page":"References","title":"ProblemReductions.Satisfiability","text":"struct Satisfiability{S, T, WT<:(AbstractArray{T}), OBJ} <: ProblemReductions.AbstractSatisfiabilityProblem{S, T, OBJ}\n\nSatisfiability(cnf::CNF{S}, weights::AbstractVector=UnitWeight(length(cnf.clauses)); use_constraints::Bool=false) where {S}\n\nSatisfiability (also called SAT) problem is to find the boolean assignment that satisfies a Conjunctive Normal Form (CNF). A tipical CNF would look like:\n\nleft(l_11 vee ldots vee l_1 n_1right) wedge ldots wedgeleft(l_m 1 vee ldots vee l_m n_mright)\n\nwhere literals are joint by vee to for m clauses and clauses are joint by wedge to form a CNF. The satisfiability problem is to find the assignment that maximizes the number of satisfied clauses if use_constraints is false, otherwise, the goal is to find one assignment that can satisfy the CNF.\n\nWe should note that all the SAT problem problem can be reduced to the 3-SAT problem and it can be proved that 3-SAT is NP-complete.\n\nFields\n\ncnf is a conjunctive normal form (CNF) for specifying the satisfiability problems.\nweights are associated with clauses. The solution size is the weighted sum of the number of satisfied assignments.\n\nExample\n\nIn the following example, we define a satisfiability problem with two clauses.\n\njulia> using ProblemReductions\n\njulia> bv1, bv2, bv3 = BoolVar.([\"x\", \"y\", \"z\"])\n3-element Vector{BoolVar{String}}:\n x\n y\n z\n\njulia> clause1 = CNFClause([bv1, bv2, bv3])\nx ∨ y ∨ z\n\njulia> clause2 = CNFClause([BoolVar(\"w\"), bv1, BoolVar(\"x\", true)])\nw ∨ x ∨ ¬x\n\njulia> cnf_test = CNF([clause1, clause2])\n(x ∨ y ∨ z) ∧ (w ∨ x ∨ ¬x)\n\njulia> sat_test = Satisfiability(cnf_test)\nSatisfiability{String, Int64, UnitWeight, ProblemReductions.EXTREMA}([\"x\", \"y\", \"z\", \"w\"], [1, 1], (x ∨ y ∨ z) ∧ (w ∨ x ∨ ¬x))\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.SetCovering","page":"References","title":"ProblemReductions.SetCovering","text":"struct SetCovering{ET, T, WT<:AbstractArray{T, 1}} <: ConstraintSatisfactionProblem{T}\n\nThe Set Covering problem is defined as follow: given a universe of elements and a collection of subsets of the universe, each set is associated with a weight.  The goal is to find a subset of sets that covers all the elements with the minimum total weight.\n\nPositional arguments\n\nelements is a vector of elements in the universe.\nsets is a vector of vectors, a collection of subsets of universe , each set is associated with a weight specified in weights.\nweights are associated with sets.\n\nExample\n\nIn the following example, we solve a Set Covering problem with 3 subsets and weights [1,2,3].\n\njulia> using ProblemReductions\n\njulia> subsets = [[1, 2, 3], [2, 4], [1, 4]]\n3-element Vector{Vector{Int64}}:\n [1, 2, 3]\n [2, 4]\n [1, 4]\n\njulia> weights = [1, 2, 3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> setcovering = SetCovering(subsets, weights)\nSetCovering{Int64, Int64, Vector{Int64}}([1, 2, 3, 4], [[1, 2, 3], [2, 4], [1, 4]], [1, 2, 3])\n\njulia> num_variables(setcovering)  # degrees of freedom\n3\n\njulia> solution_size(setcovering, [1, 0, 1])  # size of a configuration\nSolutionSize{Int64}(4, true)\n\njulia> solution_size(setcovering, [0, 1, 1])\nSolutionSize{Int64}(5, false)\n\njulia> sc = set_weights(setcovering, [1, 2, 3])  # set the weights of the subsets\nSetCovering{Int64, Int64, Vector{Int64}}([1, 2, 3, 4], [[1, 2, 3], [2, 4], [1, 4]], [1, 2, 3])\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.SetPacking","page":"References","title":"ProblemReductions.SetPacking","text":"struct SetPacking{ET, T, WT<:AbstractArray{T, 1}} <: ConstraintSatisfactionProblem{T}\n\nSetPacking(elements::AbstractVector, sets::AbstractVector, weights::AbstractVector=UnitWeight(length(sets))) -> SetPacking\n\nA packing is a set of sets where each set is pairwise disjoint from each other. The maximum (weighted) packing problem is to find the maximum packing for a given union and a set of subsets.\n\nFields\n\nelements is a vector of elements in the universe.\nsets is a vector of vectors, each set is associated with a weight specified in weights.\nweights are associated with sets. Defaults to UnitWeight(length(sets)).\n\nExample\n\nIn the following example, we define a set packing problem with five subsets. To define a SetPacking problem, we need to specify the set of subsets and possibily the weights associated with these subsets. The weights are set as unit by default in the current version and might be generalized to arbitrary positive weights in the following development. Besides, the elements would be automatically counted by the construction function.\n\njulia> using ProblemReductions\n\njulia> sets = [[1, 2, 5], [1, 3], [2, 4], [3, 6], [2, 3, 6]]\n5-element Vector{Vector{Int64}}:\n [1, 2, 5]\n [1, 3]\n [2, 4]\n [3, 6]\n [2, 3, 6]\n\njulia> SP = SetPacking(sets)\nSetPacking{Int64, Int64, UnitWeight}([1, 2, 5, 3, 4, 6], [[1, 2, 5], [1, 3], [2, 4], [3, 6], [2, 3, 6]], [1, 1, 1, 1, 1])\n\njulia> num_variables(SP)  # degrees of freedom\n5\n\njulia> flavors(SP)  # flavors of the subsets\n(0, 1)\n\njulia> solution_size(SP, [1, 0, 0, 1, 0]) # Positive sample: -(size) of a packing\nSolutionSize{Int64}(2, true)\n\njulia> solution_size(SP, [1, 0, 1, 1, 0]) # Negative sample: 0\nSolutionSize{Int64}(3, false)\n\njulia> findbest(SP, BruteForce())  # solve the problem with brute force\n3-element Vector{Vector{Int64}}:\n [0, 1, 1, 0, 0]\n [1, 0, 0, 1, 0]\n [0, 0, 1, 1, 0]\n\n\n\n\n\n","category":"type"},{"location":"ref/#Constraint-Satisfaction-Problem-Interfaces","page":"References","title":"Constraint Satisfaction Problem Interfaces","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"Constraint satisfaction problems are defined by a set of constraints and objectives defined on a set of local variables.","category":"page"},{"location":"ref/","page":"References","title":"References","text":"GenericTensorNetworks.generate_tensors\nflavors\nweights\nset_weights\nis_weighted\nnum_flavors\nnum_variables\nfixedvertices","category":"page"},{"location":"ref/#GenericTensorNetworks.generate_tensors","page":"References","title":"GenericTensorNetworks.generate_tensors","text":"generate_tensors(func, problem::GenericTensorNetwork)\n\nGenerate a vector of tensors as the inputs of the tensor network contraction code problem.code. func is a function to customize the tensors. func(symbol) returns a vector of elements, the length of which is same as the number of flavors.\n\nExample\n\nThe following code gives your the maximum independent set size\n\njulia> using Graphs, GenericTensorNetworks\n\njulia> gp = GenericTensorNetwork(IndependentSet(smallgraph(:petersen)));\n\njulia> getixsv(gp.code)\n25-element Vector{Vector{Int64}}:\n [1, 2]\n [1, 5]\n [1, 6]\n [2, 3]\n [2, 7]\n [3, 4]\n [3, 8]\n [4, 5]\n [4, 9]\n [5, 10]\n ⋮\n [2]\n [3]\n [4]\n [5]\n [6]\n [7]\n [8]\n [9]\n [10]\n\njulia> gp.code(GenericTensorNetworks.generate_tensors(Tropical(1.0), gp)...)\n0-dimensional Array{Tropical{Float64}, 0}:\n4.0ₜ\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.flavors","page":"References","title":"ProblemReductions.flavors","text":"flavors(::Type{<:AbstractProblem}) -> UnitRange\nflavors(::GT) where GT<:AbstractProblem -> UnitRange\n\nReturns a vector of integers as the flavors (domain) of a degree of freedom.\n\nwarning: Warning\nFlavors is defined a 0:num_flavors-1. To access the previous version of the flavors, use flavor_names.\n\n\n\n\n\nflavors(::Type{<:GenericTensorNetwork}) -> Vector\n\nIt returns a vector of integers as the flavors of a degree of freedom. Its size is the same as the degree of freedom on a single vertex/edge.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.weights","page":"References","title":"ProblemReductions.weights","text":"weights(problem::ConstraintSatisfactionProblem) -> Vector\n\nThe weights of the constraints in the problem.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.set_weights","page":"References","title":"ProblemReductions.set_weights","text":"set_weights(problem::ConstraintSatisfactionProblem, weights) -> ConstraintSatisfactionProblem\n\nChange the weights for the problem and return a new problem instance.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.is_weighted","page":"References","title":"ProblemReductions.is_weighted","text":"is_weighted(problem::ConstraintSatisfactionProblem) -> Bool\n\nCheck if the problem is weighted. Returns true if the problem has non-unit weights.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.num_flavors","page":"References","title":"ProblemReductions.num_flavors","text":"num_flavors(::Type{<:AbstractProblem}) -> Int\nnum_flavors(::GT) where GT<:AbstractProblem -> Int\n\nReturns the number of flavors (domain) of a degree of freedom.\n\n\n\n\n\nnum_flavors(::GenericTensorNetwork{GT}) where GT<:ConstraintSatisfactionProblem -> Int\n\nBond size is equal to the number of flavors.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.num_variables","page":"References","title":"ProblemReductions.num_variables","text":"num_variables(problem::AbstractProblem) -> Int\n\nThe number of variables in the computational problem.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.fixedvertices","page":"References","title":"GenericTensorNetworks.fixedvertices","text":"fixedvertices(tnet::GenericTensorNetwork) -> Dict\n\nReturns the fixed vertices in the graph problem, which is a dictionary specifying the fixed dimensions.\n\n\n\n\n\n","category":"function"},{"location":"ref/#Constraint-Satisfaction-Problem-Utilities","page":"References","title":"Constraint Satisfaction Problem Utilities","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"constraints\nobjectives\nflavor_names\nis_satisfied\nsolution_size\nenergy_mode\nLargerSizeIsBetter\nSmallerSizeIsBetter\nenergy\n\nis_independent_set\nis_maximal_independent_set\nis_dominating_set\nis_vertex_coloring\nis_matching\nis_set_covering\nis_set_packing\n\ncut_size\nnum_paint_shop_color_switch\n\nCNF\nCNFClause\nBoolVar\nsatisfiable\n@bools\n∨\n¬\n∧\n\nmis_compactify!","category":"page"},{"location":"ref/#ProblemReductions.constraints","page":"References","title":"ProblemReductions.constraints","text":"constraints(problem::AbstractProblem) -> Vector{LocalConstraint}\n\nThe constraints of the problem.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.objectives","page":"References","title":"ProblemReductions.objectives","text":"objectives(problem::AbstractProblem) -> Vector{<:LocalSolutionSize}\n\nThe constraints related to the size of the problem. Each term is associated with weights.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.flavor_names","page":"References","title":"ProblemReductions.flavor_names","text":"flavor_names(::Type{<:AbstractProblem}) -> Vector\n\nReturns a vector as the names of the flavors (domain) of a degree of freedom. It falls back to flavors if no method is defined. Use ProblemReductions.name2config and ProblemReductions.config2name to convert between the names and the configuration.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.is_satisfied","page":"References","title":"ProblemReductions.is_satisfied","text":"is_satisfied(constraint::LocalConstraint, config) -> Bool\nis_satisfied(problem::ConstraintSatisfactionProblem, config) -> Bool\n\nCheck if the constraint is satisfied by the configuration config.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.solution_size","page":"References","title":"ProblemReductions.solution_size","text":"solution_size(spec::LocalSolutionSize{WT}, config) where {WT}\n\nThe local solution size of a local solution configuration.\n\n\n\n\n\nsolution_size(problem::AbstractProblem, config) -> SolutionSize\n\nSize of the problem given the configuration config. If you have multiple configurations, use ProblemReductions.solution_size_multiple instead for better performance.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.energy_mode","page":"References","title":"ProblemReductions.energy_mode","text":"energy_mode(problem::AbstractProblem) -> EnergyMode\n\nThe definition of the energy function, which can be LargerSizeIsBetter or SmallerSizeIsBetter. If will be used in the energy based modeling of the target problem.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.LargerSizeIsBetter","page":"References","title":"ProblemReductions.LargerSizeIsBetter","text":"LargerSizeIsBetter <: EnergyMode\n\nThe energy is defined as the negative size of the solution, which is the larger size the lower energy.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.SmallerSizeIsBetter","page":"References","title":"ProblemReductions.SmallerSizeIsBetter","text":"SmallerSizeIsBetter <: EnergyMode\n\nThe energy is defined as the size of the solution, which is the smaller size the lower energy.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.energy","page":"References","title":"ProblemReductions.energy","text":"energy(problem::AbstractProblem, config) -> Number\n\nThe energy of the problem given the configuration config. Please check the energy_mode for the definition of the energy function.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.is_independent_set","page":"References","title":"ProblemReductions.is_independent_set","text":"is_independent_set(g::SimpleGraph, config)\n\nReturn true if config (a vector of boolean numbers as the mask of vertices) is an independent set of graph g.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.is_maximal_independent_set","page":"References","title":"ProblemReductions.is_maximal_independent_set","text":"is_maximal_independent_set(g::SimpleGraph, config)\n\nReturn true if config (a vector of boolean numbers as the mask of vertices) is a maximal independent set of graph g.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.is_dominating_set","page":"References","title":"ProblemReductions.is_dominating_set","text":"is_dominating_set(g::SimpleGraph, config)\n\nReturn true if config (a vector of boolean numbers as the mask of vertices) is a dominating set of graph g.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.is_vertex_coloring","page":"References","title":"ProblemReductions.is_vertex_coloring","text":"is_vertex_coloring(graph::SimpleGraph, config)\n\nReturns true if the coloring specified by config is a valid one, i.e. does not violate the contraints of vertices of an edges having different colors.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.is_matching","page":"References","title":"ProblemReductions.is_matching","text":"is_matching(graph::SimpleGraph, config)\n\nReturns true if config is a valid matching on graph, and false if a vertex is double matched. config is a vector of boolean variables, which has one to one correspondence with edges(graph).\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.is_set_covering","page":"References","title":"ProblemReductions.is_set_covering","text":"is_set_covering(c::SetCovering, config)\n\nReturn true if config (a vector of boolean numbers as the mask of sets) is a set covering of sets.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.is_set_packing","page":"References","title":"ProblemReductions.is_set_packing","text":"is_set_packing(sp::SetPacking, config)\n\nReturn true if config (a vector of boolean numbers as the mask of sets) is a set packing of sp.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.cut_size","page":"References","title":"ProblemReductions.cut_size","text":"cut_size(g::AbstractGraph, config; weights=UnitWeight(ne(g)))\n\nReturn the size of the cut of the graph g with configuration config. The configuration is a vector of boolean numbers as the group indices of vertices. Edges between vertices in different groups are counted as a cut.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.num_paint_shop_color_switch","page":"References","title":"ProblemReductions.num_paint_shop_color_switch","text":"num_paint_shop_color_switch(sequence::AbstractVector, coloring)\n\nReturns the number of color switches.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.CNF","page":"References","title":"ProblemReductions.CNF","text":"CNF{T}\nCNF(clauses)\n\nBoolean expression in conjunctive normal form. clauses is a vector of CNFClause, if and only if all clauses are satisfied, this CNF is satisfied.\n\nExample\n\nUnder development\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.CNFClause","page":"References","title":"ProblemReductions.CNFClause","text":"CNFClause{T}\nCNFClause(vars)\n\nA clause in CNF, its value is the logical or of vars, where vars is a vector of BoolVar.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.BoolVar","page":"References","title":"ProblemReductions.BoolVar","text":"BoolVar{T}\nBoolVar(name, neg)\n\nBoolean variable for constructing CNF clauses.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.satisfiable","page":"References","title":"ProblemReductions.satisfiable","text":"satisfiable(expr, config::AbstractDict{T}) where T\n\nCheck if the boolean expression expr is satisfied by the configuration config.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.@bools","page":"References","title":"ProblemReductions.@bools","text":"@bools(syms::Symbol...)\n\nCreate some boolean variables of type BoolVar in current scope that can be used in create a CNF.\n\nExample\n\nUnder Development\n\n\n\n\n\n","category":"macro"},{"location":"ref/#ProblemReductions.:∨","page":"References","title":"ProblemReductions.:∨","text":"∨(vars...)\n\nLogical or applied on BoolVar and CNFClause. Returns a CNFClause.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.:¬","page":"References","title":"ProblemReductions.:¬","text":"¬(var::BoolVar)\n\nNegation of a boolean variables of type BoolVar.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.:∧","page":"References","title":"ProblemReductions.:∧","text":"∧(vars...)\n\nLogical and applied on CNFClause and CNF. Returns a new CNF.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.mis_compactify!","page":"References","title":"GenericTensorNetworks.mis_compactify!","text":"mis_compactify!(tropicaltensor; potential=nothing)\n\nCompactify tropical tensor for maximum independent set problem. It will eliminate some entries by setting them to zero, by the criteria that removing these entry does not change the MIS size of its parent graph (reference to be added).\n\nArguments\n\ntropicaltensor::AbstractArray{T}: the tropical tensor\n\nKeyword arguments\n\npotential=nothing: the maximum possible MIS contribution from each open vertex\n\n\n\n\n\n","category":"function"},{"location":"ref/#Properties","page":"References","title":"Properties","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"PartitionFunction\nSizeMax\nSizeMin\nCountingAll\nCountingMax\nCountingMin\nGraphPolynomial\nSingleConfigMax\nSingleConfigMin\nConfigsAll\nConfigsMax\nConfigsMin","category":"page"},{"location":"ref/#GenericTensorNetworks.PartitionFunction","page":"References","title":"GenericTensorNetworks.PartitionFunction","text":"struct PartitionFunction{T} <: GenericTensorNetworks.AbstractProperty\n\nbeta\n\nCompute the partition function for the target problem.\n\nThe corresponding tensor element type is T.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.SizeMax","page":"References","title":"GenericTensorNetworks.SizeMax","text":"SizeMax{K} <: AbstractProperty\nSizeMax(k::Int)\n\nThe maximum-K set sizes. e.g. the largest size of the IndependentSet  problem is also know as the independence number.\n\nThe corresponding tensor element type are max-plus tropical number Tropical if K is Single and ExtendedTropical if K is an integer.\nIt is compatible with weighted Constraint Satisfaction Problems.\nBLAS (on CPU) and GPU are supported only if K is Single,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.SizeMin","page":"References","title":"GenericTensorNetworks.SizeMin","text":"SizeMin{K} <: AbstractProperty\nSizeMin(k::Int)\n\nThe minimum-K set sizes. e.g. the smallest size ofthe MaximalIS problem is also known as the independent domination number.\n\nThe corresponding tensor element type are inverted max-plus tropical number Tropical if K is Single and inverted ExtendedTropical K is an integer.\n\nThe inverted Tropical number emulates the min-plus tropical number.\n\nIt is compatible with weighted constraint satisfaction problems.\nBLAS (on CPU) and GPU are supported only if K is Single,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.CountingAll","page":"References","title":"GenericTensorNetworks.CountingAll","text":"CountingAll <: AbstractProperty\nCountingAll()\n\nCounting the total number of sets exactly without overflow. e.g. for the IndependentSet problem, it counts the independent sets. Note that PartitionFunction(0.0) also does the counting. It is more efficient, but uses floating point numbers, which does not have arbitrary precision.\n\nThe corresponding tensor element type is BigInt.\nThe weights on graph does not have effect.\nBLAS (GPU and CPU) and GPU are supported,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.CountingMax","page":"References","title":"GenericTensorNetworks.CountingMax","text":"CountingMax{K} <: AbstractProperty\nCountingMax(K=Single)\n\nCounting the number of sets with largest-K size. e.g. for IndependentSet problem, it counts independent sets of size alpha(G) alpha(G)-1 ldots alpha(G)-K+1.\n\nThe corresponding tensor element type is CountingTropical if K is Single, and TruncatedPoly{K} if K is an integer.\nWeighted constraint satisfaction problems is only supported if K is Single.\nGPU is supported,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.CountingMin","page":"References","title":"GenericTensorNetworks.CountingMin","text":"CountingMin{K} <: AbstractProperty\nCountingMin(K=Single)\n\nCounting the number of sets with smallest-K size.\n\nThe corresponding tensor element type is inverted CountingTropical if K is Single, and TruncatedPoly{K} if K is an integer.\nWeighted constraint satisfaction problems is only supported if K is Single.\nGPU is supported,\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.GraphPolynomial","page":"References","title":"GenericTensorNetworks.GraphPolynomial","text":"GraphPolynomial{METHOD} <: AbstractProperty\nGraphPolynomial(; method=:finitefield, kwargs...)\n\nCompute the graph polynomial, e.g. for IndependentSet problem, it is the independence polynomial. The METHOD type parameter can be one of the following symbols\n\nMethod Argument\n\n:finitefield, uses finite field algebra to fit the polynomial.\nThe corresponding tensor element type is Mods.Mod,\nIt does not have round-off error,\nGPU is supported,\nIt accepts keyword arguments maxorder (optional, e.g. the MIS size in the IndependentSet problem).\n:polynomial and :laurent, use (Laurent) polynomial numbers to solve the polynomial directly.\nThe corresponding tensor element types are Polynomial and LaurentPolynomial.\nIt might have small round-off error depending on the data type for storing the counting.\nIt has memory overhead that linear to the graph size.\n:fft, use fast fourier transformation to fit the polynomial.\nThe corresponding tensor element type is Base.Complex.\nIt has (controllable) round-off error.\nBLAS and GPU are supported.\nIt accepts keyword arguments maxorder (optional) and r,   if r > 1, one has better precision for coefficients of large order, if r < 1,   one has better precision for coefficients of small order.\n:fitting, fit the polynomial directly.\nThe corresponding tensor element type is floating point numbers like Base.Float64.\nIt has round-off error.\nBLAS and GPU are supported, it is the fastest among all methods.\n\nGraph polynomials are not defined for weighted constraint satisfaction problems.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.SingleConfigMax","page":"References","title":"GenericTensorNetworks.SingleConfigMax","text":"SingleConfigMax{K, BOUNDED} <: AbstractProperty\nSingleConfigMax(k::Int; bounded=false)\n\nFinding single solution for largest-K sizes, e.g. for IndependentSet problem, it is one of the maximum independent sets.\n\nThe corresponding data type is CountingTropical{Float64,<:ConfigSampler} if BOUNDED is false, Tropical otherwise.\nWeighted constraint satisfaction problems is supported.\nGPU is supported,\n\nKeyword Arguments\n\nbounded, if it is true, use bounding trick (or boolean gradients) to reduce the working memory to store intermediate configurations.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.SingleConfigMin","page":"References","title":"GenericTensorNetworks.SingleConfigMin","text":"SingleConfigMin{K, BOUNDED} <: AbstractProperty\nSingleConfigMin(k::Int; bounded=false)\n\nFinding single solution with smallest-K size.\n\nThe corresponding data type is inverted CountingTropical{Float64,<:ConfigSampler} if BOUNDED is false, inverted Tropical otherwise.\nWeighted constraint satisfaction problems is supported.\nGPU is supported,\n\nKeyword Arguments\n\nbounded, if it is true, use bounding trick (or boolean gradients) to reduce the working memory to store intermediate configurations.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.ConfigsAll","page":"References","title":"GenericTensorNetworks.ConfigsAll","text":"ConfigsAll{TREESTORAGE} <:AbstractProperty\nConfigsAll(; tree_storage=false)\n\nFind all valid configurations, e.g. for IndependentSet problem, it is finding all independent sets.\n\nThe corresponding data type is ConfigEnumerator.\nWeights do not take effect.\n\nKeyword Arguments\n\ntree_storage, if it is true, it uses more memory efficient tree-structure to store the configurations.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.ConfigsMax","page":"References","title":"GenericTensorNetworks.ConfigsMax","text":"ConfigsMax{K, BOUNDED, TREESTORAGE} <:AbstractProperty\nConfigsMax(K=Single; bounded=true, tree_storage=true)\n\nFind configurations with largest-K sizes, e.g. for IndependentSet problem, it is finding all independent sets of sizes alpha(G) alpha(G)-1 ldots alpha(G)-K+1.\n\nThe corresponding data type is CountingTropical{Float64,<:ConfigEnumerator} if K is Single and TruncatedPoly{K,<:ConfigEnumerator} if K is an integer.\nWeighted constraint satisfaction problem is only supported if K is Single.\n\nKeyword Arguments\n\nbounded, if it is true, use bounding trick (or boolean gradients) to reduce the working memory to store intermediate configurations.\ntree_storage, if it is true, it uses more memory efficient tree-structure to store the configurations.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.ConfigsMin","page":"References","title":"GenericTensorNetworks.ConfigsMin","text":"ConfigsMin{K, BOUNDED, TREESTORAGE} <:AbstractProperty\nConfigsMin(K=Single; bounded=true, tree_storage=false)\n\nFind configurations with smallest-K sizes.\n\nThe corresponding data type is inverted CountingTropical{Float64,<:ConfigEnumerator} if K is Single and inverted TruncatedPoly{K,<:ConfigEnumerator} if K is an integer.\nWeighted constraint satisfaction problem is only supported if K is Single.\n\nKeyword Arguments\n\nbounded, if it is true, use bounding trick (or boolean gradients) to reduce the working memory to store intermediate configurations.\ntree_storage, if it is true, it uses more memory efficient tree-structure to store the configurations.\n\n\n\n\n\n","category":"type"},{"location":"ref/#Element-Algebras","page":"References","title":"Element Algebras","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"is_commutative_semiring","category":"page"},{"location":"ref/#GenericTensorNetworks.is_commutative_semiring","page":"References","title":"GenericTensorNetworks.is_commutative_semiring","text":"is_commutative_semiring(a::T, b::T, c::T) where T\n\nCheck if elements a, b and c satisfied the commutative semiring requirements.\n\nbeginalign*\n(a oplus b) oplus c = a oplus (b oplus c)  hspace5emtrianglerighttextcommutative monoid oplus with identity mathbb0\na oplus mathbb0 = mathbb0 oplus a = a \na oplus b = b oplus a \n\n(a odot b) odot c = a odot (b odot c)     hspace5emtriangleright textcommutative monoid odot with identity mathbb1\na odot  mathbb1 =  mathbb1 odot a = a \na odot b = b odot a \n\na odot (boplus c) = aodot b oplus aodot c    hspace5emtriangleright textleft and right distributive\n(aoplus b) odot c = aodot c oplus bodot c \n\na odot mathbb0 = mathbb0 odot a = mathbb0\nendalign*\n\n\n\n\n\n","category":"function"},{"location":"ref/","page":"References","title":"References","text":"TropicalNumbers.Tropical\nTropicalNumbers.CountingTropical\nExtendedTropical\nGenericTensorNetworks.Mods.Mod\nTruncatedPoly\nMax2Poly\nConfigEnumerator\nSumProductTree\nConfigSampler","category":"page"},{"location":"ref/#TropicalNumbers.Tropical","page":"References","title":"TropicalNumbers.Tropical","text":"TropicalMaxPlus{T} = Tropical{T} <: AbstractSemiring\n\nTropicalMaxPlus is a semiring algebra, can be described by\n\nTropical (TropicalMaxPlus), (ℝ, max, +, -Inf, 0).\n\nIt maps\n\n+ to max in regular algebra,\n* to + in regular algebra,\n1 to 0 in regular algebra,\n0 to -Inf in regular algebra (for integer content types, this is chosen as a small integer).\n\nExample\n\njulia> TropicalMaxPlus(1.0) + TropicalMaxPlus(3.0)\n3.0ₜ\n\njulia> TropicalMaxPlus(1.0) * TropicalMaxPlus(3.0)\n4.0ₜ\n\njulia> one(TropicalMaxPlusF64)\n0.0ₜ\n\njulia> zero(TropicalMaxPlusF64)\n-Infₜ\n\n\n\n\n\n","category":"type"},{"location":"ref/#TropicalNumbers.CountingTropical","page":"References","title":"TropicalNumbers.CountingTropical","text":"CountingTropical{T,CT} <: Number\n\nCounting tropical number type is also a semiring algebra. It is tropical algebra with one extra field for counting, it is introduced in arXiv:2008.06888.\n\nExample\n\njulia> CountingTropical(1.0, 5.0) + CountingTropical(3.0, 2.0)\n(3.0, 2.0)ₜ\n\njulia> CountingTropical(1.0, 5.0) * CountingTropical(3.0, 2.0)\n(4.0, 10.0)ₜ\n\njulia> one(CountingTropicalF64)\n(0.0, 1.0)ₜ\n\njulia> zero(CountingTropicalF64)\n(-Inf, 0.0)ₜ\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.ExtendedTropical","page":"References","title":"GenericTensorNetworks.ExtendedTropical","text":"ExtendedTropical{K,TO} <: Number\nExtendedTropical{K}(orders)\n\nExtended Tropical numbers with largest K orders keeped, or the TruncatedPoly without coefficients, TO is the element type of orders, usually Tropical numbers. This algebra maps\n\n+ to finding largest K values of union of two sets.\n* to finding largest K values of sum combination of two sets.\n0 to set [-Inf, -Inf, ..., -Inf, -Inf]\n1 to set [-Inf, -Inf, ..., -Inf, 0]\n\nFields\n\norders is a vector of Tropical (CountingTropical) numbers as the largest-K solution sizes (solutions).\n\nExamples\n\njulia> x = ExtendedTropical{3}(Tropical.([1.0, 2, 3]))\nExtendedTropical{3, Tropical{Float64}}(Tropical{Float64}[1.0ₜ, 2.0ₜ, 3.0ₜ])\n\njulia> y = ExtendedTropical{3}(Tropical.([-Inf, 2, 5]))\nExtendedTropical{3, Tropical{Float64}}(Tropical{Float64}[-Infₜ, 2.0ₜ, 5.0ₜ])\n\njulia> x * y\nExtendedTropical{3, Tropical{Float64}}(Tropical{Float64}[6.0ₜ, 7.0ₜ, 8.0ₜ])\n\njulia> x + y\nExtendedTropical{3, Tropical{Float64}}(Tropical{Float64}[2.0ₜ, 3.0ₜ, 5.0ₜ])\n\njulia> one(x)\nExtendedTropical{3, Tropical{Float64}}(Tropical{Float64}[-Infₜ, -Infₜ, 0.0ₜ])\n\njulia> zero(x)\nExtendedTropical{3, Tropical{Float64}}(Tropical{Float64}[-Infₜ, -Infₜ, -Infₜ])\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.Mods.Mod","page":"References","title":"GenericTensorNetworks.Mods.Mod","text":"Mod{m}(v) creates a modular number in mod m with value mod(v,m).\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.TruncatedPoly","page":"References","title":"GenericTensorNetworks.TruncatedPoly","text":"TruncatedPoly{K,T,TO} <: Number\nTruncatedPoly(coeffs::Tuple, maxorder)\n\nPolynomial truncated to largest K orders. T is the coefficients type and TO is the orders type.\n\nFields\n\ncoeffs is the largest-K coefficients of a polynomial. In GenericTensorNetworks, it can be the counting or enumeration of solutions.\nmaxorder is the order of a polynomial.\n\nExamples\n\njulia> TruncatedPoly((1,2,3), 6)\nx⁴ + 2*x⁵ + 3*x⁶\n\njulia> TruncatedPoly((1,2,3), 6) * TruncatedPoly((5,2,1), 3)\n20*x⁷ + 8*x⁸ + 3*x⁹\n\njulia> TruncatedPoly((1,2,3), 6) + TruncatedPoly((5,2,1), 3)\nx⁴ + 2*x⁵ + 3*x⁶\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.Max2Poly","page":"References","title":"GenericTensorNetworks.Max2Poly","text":"Max2Poly{T,TO} = TruncatedPoly{2,T,TO}\nMax2Poly(a, b, maxorder)\n\nA shorthand of TruncatedPoly{2}.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.ConfigEnumerator","page":"References","title":"GenericTensorNetworks.ConfigEnumerator","text":"ConfigEnumerator{N,S,C} <: AbstractSetNumber\n\nSet algebra for enumerating configurations, where N is the length of configurations, C is the size of storage in unit of UInt64, S is the bit width to store a single element in a configuration, i.e. log2(# of flavors), for bitstrings, it is 1`.\n\nFields\n\ndata is a vector of StaticElementVector as the solution set.\n\nExamples\n\njulia> a = ConfigEnumerator([StaticBitVector([1,1,1,0,0]), StaticBitVector([1,0,0,0,1])])\n{11100, 10001}\n\njulia> b = ConfigEnumerator([StaticBitVector([0,0,0,0,0]), StaticBitVector([1,0,1,0,1])])\n{00000, 10101}\n\njulia> a + b\n{11100, 10001, 00000, 10101}\n\njulia> one(a)\n{00000}\n\njulia> zero(a)\n{}\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.SumProductTree","page":"References","title":"GenericTensorNetworks.SumProductTree","text":"SumProductTree{ET} <: AbstractSetNumber\n\nConfiguration enumerator encoded in a tree, it is the most natural representation given by a sum-product network and is often more memory efficient than putting the configurations in a vector. One can use generate_samples to sample configurations from this tree structure efficiently.\n\nFields\n\ntag is one of ZERO, ONE, LEAF, SUM, PROD.\ndata is the element stored in a LEAF node.\nleft and right are two operands of a SUM or PROD node.\n\nExamples\n\njulia> s = SumProductTree(bv\"00111\")\n00111\n\n\njulia> q = SumProductTree(bv\"10000\")\n10000\n\n\njulia> x = s + q\n+ (count = 2.0)\n├─ 00111\n└─ 10000\n\n\njulia> y = x * x\n* (count = 4.0)\n├─ + (count = 2.0)\n│  ├─ 00111\n│  └─ 10000\n└─ + (count = 2.0)\n   ├─ 00111\n   └─ 10000\n\n\njulia> collect(y)\n4-element Vector{StaticBitVector{5, 1}}:\n 00111\n 10111\n 10111\n 10000\n\njulia> zero(s)\n∅\n\n\n\njulia> one(s)\n00000\n\n\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.ConfigSampler","page":"References","title":"GenericTensorNetworks.ConfigSampler","text":"ConfigSampler{N,S,C} <: AbstractSetNumber\nConfigSampler(elements::StaticElementVector)\n\nThe algebra for sampling one configuration, where N is the length of configurations, C is the size of storage in unit of UInt64, S is the bit width to store a single element in a configuration, i.e. log2(# of flavors), for bitstrings, it is 1`.\n\nnote: Note\nConfigSampler is a probabilistic commutative semiring, adding two config samplers do not give you deterministic results.\n\nFields\n\ndata is a StaticElementVector as the sampled solution.\n\nExamples\n\njulia> ConfigSampler(StaticBitVector([1,1,1,0,0]))\nConfigSampler{5, 1, 1}(11100)\n\njulia> ConfigSampler(StaticBitVector([1,1,1,0,0])) + ConfigSampler(StaticBitVector([1,0,1,0,0]))\nConfigSampler{5, 1, 1}(10100)\n\njulia> ConfigSampler(StaticBitVector([1,1,1,0,0])) * ConfigSampler(StaticBitVector([0,0,0,0,1]))\nConfigSampler{5, 1, 1}(11101)\n\njulia> one(ConfigSampler{5, 1, 1})\nConfigSampler{5, 1, 1}(00000)\n\njulia> zero(ConfigSampler{5, 1, 1})\nConfigSampler{5, 1, 1}(11111)\n\n\n\n\n\n","category":"type"},{"location":"ref/","page":"References","title":"References","text":"Extra types include the Polynomial and LaurentPolynomial types defined in package Polynomials.","category":"page"},{"location":"ref/","page":"References","title":"References","text":"For reading the properties from the above element types, one can use the following functions.","category":"page"},{"location":"ref/","page":"References","title":"References","text":"read_size\nread_count\nread_config\nread_size_count\nread_size_config","category":"page"},{"location":"ref/#GenericTensorNetworks.read_size","page":"References","title":"GenericTensorNetworks.read_size","text":"read_size(x)\n\nRead the size information from the generic element.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.read_count","page":"References","title":"GenericTensorNetworks.read_count","text":"read_count(x)\n\nRead the counting information from the generic element.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.read_config","page":"References","title":"GenericTensorNetworks.read_config","text":"read_config(x; keeptree=false)\n\nRead the configuration information from the generic element, if keeptree=true, the tree structure will not be flattened.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.read_size_count","page":"References","title":"GenericTensorNetworks.read_size_count","text":"read_size_count(x)\n\nRead the size and counting information from the generic element.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.read_size_config","page":"References","title":"GenericTensorNetworks.read_size_config","text":"read_size_config(x; keeptree=false)\n\nRead the size and configuration information from the generic element. If keeptree=true, the tree structure will not be flattened.\n\n\n\n\n\n","category":"function"},{"location":"ref/","page":"References","title":"References","text":"The following functions are for saving and loading configurations.","category":"page"},{"location":"ref/","page":"References","title":"References","text":"StaticBitVector\nStaticElementVector\nOnehotVec\nsave_configs\nload_configs\nsave_sumproduct\nload_sumproduct\n@bv_str\nonehotv\n\ngenerate_samples\nhamming_distribution","category":"page"},{"location":"ref/#ProblemReductions.StaticBitVector","page":"References","title":"ProblemReductions.StaticBitVector","text":"StaticBitVector{N,C} = StaticElementVector{N,1,C}\nStaticBitVector(x::AbstractVector)\n\nExamples\n\njulia> sb = StaticBitVector([1,0,0,1,1])\n10011\n\njulia> sb[3]\n0x0000000000000000\n\njulia> collect(Int, sb)\n5-element Vector{Int64}:\n 1\n 0\n 0\n 1\n 1\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.StaticElementVector","page":"References","title":"ProblemReductions.StaticElementVector","text":"StaticElementVector{N,S,C}\nStaticElementVector(nflavor::Int, x::AbstractVector)\n\nN is the length of vector, C is the size of storage in unit of UInt64, S is the stride defined as the log2(# of flavors). When the number of flavors is 2, it is a StaticBitVector.\n\nFields\n\ndata is a tuple of UInt64 for storing the configuration of static elements.\n\nExamples\n\njulia> ev = StaticElementVector(3, [1,2,0,1,2])\n12012\n\njulia> ev[2]\n0x0000000000000002\n\njulia> collect(Int, ev)\n5-element Vector{Int64}:\n 1\n 2\n 0\n 1\n 2\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.OnehotVec","page":"References","title":"GenericTensorNetworks.OnehotVec","text":"OnehotVec{N,NF}\nOnehotVec{N,NF}(loc, val)\n\nOnehot vector type, N is the number of vector length, NF is the number of flavors.\n\n\n\n\n\n","category":"type"},{"location":"ref/#GenericTensorNetworks.save_configs","page":"References","title":"GenericTensorNetworks.save_configs","text":"save_configs(filename, data::ConfigEnumerator; format=:binary)\n\nSave configurations data to file filename. The format is :binary or :text.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.load_configs","page":"References","title":"GenericTensorNetworks.load_configs","text":"load_configs(filename; format=:binary, bitlength=nothing, num_flavors=2)\n\nLoad configurations from file filename. The format is :binary or :text. If the format is :binary, the bitstring length bitlength must be specified, num_flavors specifies the degree of freedom.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.save_sumproduct","page":"References","title":"GenericTensorNetworks.save_sumproduct","text":"save_sumproduct(filename, t::SumProductTree)\n\nSerialize a sum-product tree into a file.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.load_sumproduct","page":"References","title":"GenericTensorNetworks.load_sumproduct","text":"load_sumproduct(filename)\n\nDeserialize a sum-product tree from a file.\n\n\n\n\n\n","category":"function"},{"location":"ref/#ProblemReductions.@bv_str","page":"References","title":"ProblemReductions.@bv_str","text":"Constructing a static bit vector.\n\n\n\n\n\n","category":"macro"},{"location":"ref/#ProblemReductions.onehotv","page":"References","title":"ProblemReductions.onehotv","text":"onehotv(::Type{<:StaticElementVector}, i, v)\nonehotv(::Type{<:StaticBitVector}, i)\n\nReturns a static element vector, with the value at location i being v (1 if not specified).\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.generate_samples","page":"References","title":"GenericTensorNetworks.generate_samples","text":"generate_samples(t::SumProductTree, nsamples::Int)\n\nDirect sampling configurations from a SumProductTree instance.\n\nExamples\n\njulia> using Graphs\n\njulia> g= smallgraph(:petersen)\n{10, 15} undirected simple Int64 graph\n\njulia> t = solve(GenericTensorNetwork(IndependentSet(g)), ConfigsAll(; tree_storage=true))[];\n\njulia> samples = generate_samples(t, 1000);\n\njulia> all(s->is_independent_set(g, s), samples)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.hamming_distribution","page":"References","title":"GenericTensorNetworks.hamming_distribution","text":"hamming_distribution(S, T)\n\nCompute the distribution of pair-wise Hamming distances, which is defined as:\n\nc(k) = sum_sigmain S tauin T delta(rm dist(sigma tau) k)\n\nwhere delta is a function that returns 1 if two arguments are equivalent, 0 otherwise, rm dist is the Hamming distance function.\n\nReturns the counting as a vector.\n\n\n\n\n\n","category":"function"},{"location":"ref/#Tensor-Network","page":"References","title":"Tensor Network","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"optimize_code\ngetixsv\ngetiyv\ncontraction_complexity\nestimate_memory\n@ein_str\nGreedyMethod\nTreeSA\nSABipartite\nKaHyParBipartite\nMergeVectors\nMergeGreedy","category":"page"},{"location":"ref/#OMEinsumContractionOrders.optimize_code","page":"References","title":"OMEinsumContractionOrders.optimize_code","text":"optimize_code(eincode, size_dict, optimizer = GreedyMethod(), simplifier=nothing, permute=true) -> optimized_eincode\n\nOptimize the einsum contraction code and reduce the time/space complexity of tensor network contraction. Returns a NestedEinsum instance. Input arguments are\n\neincode is an einsum contraction code instance, one of DynamicEinCode, StaticEinCode or NestedEinsum.\nsize is a dictionary of \"edge label=>edge size\" that contains the size information, one can use uniformsize(eincode, 2) to create a uniform size.\noptimizer is a CodeOptimizer instance, should be one of GreedyMethod, ExactTreewidth, KaHyParBipartite, SABipartite or TreeSA. Check their docstrings for details.\nsimplifier is one of MergeVectors or MergeGreedy.\noptimize the permutation if permute is true.\n\nExamples\n\njulia> using OMEinsum\n\njulia> code = ein\"ij, jk, kl, il->\"\nij, jk, kl, il -> \n\njulia> optimize_code(code, uniformsize(code, 2), TreeSA())\nSlicedEinsum{Char, NestedEinsum{DynamicEinCode{Char}}}(Char[], ki, ki -> \n├─ jk, ij -> ki\n│  ├─ jk\n│  └─ ij\n└─ kl, il -> ki\n   ├─ kl\n   └─ il\n)\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsum.getixsv","page":"References","title":"OMEinsum.getixsv","text":"getixsv(code)\n\nGet labels of input tensors for EinCode, NestedEinsum and some other einsum like objects. Returns a vector of vectors.\n\njulia> getixsv(ein\"(ij,jk),k->i\")\n3-element Vector{Vector{Char}}:\n ['i', 'j']\n ['j', 'k']\n ['k']\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsum.getiyv","page":"References","title":"OMEinsum.getiyv","text":"getiy(code)\n\nGet labels of the output tensor for EinCode, NestedEinsum and some other einsum like objects. Returns a vector.\n\njulia> getiyv(ein\"(ij,jk),k->i\")\n1-element Vector{Char}:\n 'i': ASCII/Unicode U+0069 (category Ll: Letter, lowercase)\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsumContractionOrders.contraction_complexity","page":"References","title":"OMEinsumContractionOrders.contraction_complexity","text":"contraction_complexity(eincode, size_dict) -> ContractionComplexity\n\nReturns the time, space and read-write complexity of the einsum contraction. The returned object contains 3 fields:\n\ntime complexity tc defined as log2(number of element-wise multiplications).\nspace complexity sc defined as log2(size of the maximum intermediate tensor).\nread-write complexity rwc defined as log2(the number of read-write operations).\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.estimate_memory","page":"References","title":"GenericTensorNetworks.estimate_memory","text":"estimate_memory(\n    problem::GenericTensorNetwork,\n    property::GenericTensorNetworks.AbstractProperty;\n    T\n) -> Any\n\n\nMemory estimation in number of bytes to compute certain property of a problem. T is the base type.\n\n\n\n\n\n","category":"function"},{"location":"ref/#OMEinsum.@ein_str","page":"References","title":"OMEinsum.@ein_str","text":"ein\"ij,jk -> ik\"(A,B)\n\nString macro interface which understands numpy.einsum's notation. Translates strings into StaticEinCode-structs that can be called to evaluate an einsum. To control evaluation order, use parentheses - instead of an EinCode, a NestedEinsum is returned which evaluates the expression according to parens. The valid character ranges for index-labels are a-z and α-ω.\n\nexample\n\njulia> a, b, c = rand(10,10), rand(10,10), rand(10,1);\n\njulia> ein\"ij,jk,kl -> il\"(a,b,c) ≈ ein\"(ij,jk),kl -> il\"(a,b,c) ≈ a * b * c\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"ref/#OMEinsumContractionOrders.GreedyMethod","page":"References","title":"OMEinsumContractionOrders.GreedyMethod","text":"GreedyMethod{MT}\nGreedyMethod(; α = 0.0, temperature = 0.0, nrepeat=1)\n\nThe fast but poor greedy optimizer. Input arguments are\n\n* `α` is the parameter for the loss function, for pairwise interaction, L = size(out) - α * (size(in1) + size(in2))\n* `temperature` is the parameter for sampling, if it is zero, the minimum loss is selected; for non-zero, the loss is selected by the Boltzmann distribution, given by p ~ exp(-loss/temperature).\n* `nrepeat` is the number of repeatition, returns the best contraction order.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.TreeSA","page":"References","title":"OMEinsumContractionOrders.TreeSA","text":"TreeSA{RT,IT,GM}\nTreeSA(; sc_target=20, βs=collect(0.01:0.05:15), ntrials=10, niters=50,\n    sc_weight=1.0, rw_weight=0.2, initializer=:greedy, greedy_config=GreedyMethod(; nrepeat=1))\n\nOptimize the einsum contraction pattern using the simulated annealing on tensor expression tree.\n\nsc_target is the target space complexity,\nntrials, βs and niters are annealing parameters, doing ntrials indepedent annealings, each has inverse tempteratures specified by βs, in each temperature, do niters updates of the tree.\nsc_weight is the relative importance factor of space complexity in the loss compared with the time complexity.\nrw_weight is the relative importance factor of memory read and write in the loss compared with the time complexity.\ninitializer specifies how to determine the initial configuration, it can be :greedy or :random. If it is using :greedy method to generate the initial configuration, it also uses two extra arguments greedy_method and greedy_nrepeat.\nnslices is the number of sliced legs, default is 0.\nfixed_slices is a vector of sliced legs, default is [].\n\nReferences\n\nRecursive Multi-Tensor Contraction for XEB Verification of Quantum Circuits\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.SABipartite","page":"References","title":"OMEinsumContractionOrders.SABipartite","text":"SABipartite{RT,BT}\nSABipartite(; sc_target=25, ntrials=50, βs=0.1:0.2:15.0, niters=1000\n    max_group_size=40, greedy_config=GreedyMethod(), initializer=:random)\n\nOptimize the einsum code contraction order using the Simulated Annealing bipartition + Greedy approach. This program first recursively cuts the tensors into several groups using simulated annealing, with maximum group size specifed by max_group_size and maximum space complexity specified by sc_target, Then finds the contraction order inside each group with the greedy search algorithm. Other arguments are\n\nsize_dict, a dictionary that specifies leg dimensions,\nsc_target is the target space complexity, defined as log2(number of elements in the largest tensor),\nmax_group_size is the maximum size that allowed to used greedy search,\nβs is a list of inverse temperature 1/T,\nniters is the number of iteration in each temperature,\nntrials is the number of repetition (with different random seeds),\nsub_optimizer, the optimizer for the bipartited sub graphs, one can choose GreedyMethod() or TreeSA(),\ninitializer, the partition configuration initializer, one can choose :random or :greedy (slow but better).\n\nReferences\n\nHyper-optimized tensor network contraction\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.KaHyParBipartite","page":"References","title":"OMEinsumContractionOrders.KaHyParBipartite","text":"KaHyParBipartite{RT,IT,GM}\nKaHyParBipartite(; sc_target, imbalances=collect(0.0:0.005:0.8),\n    max_group_size=40, greedy_config=GreedyMethod())\n\nOptimize the einsum code contraction order using the KaHyPar + Greedy approach. This program first recursively cuts the tensors into several groups using KaHyPar, with maximum group size specifed by max_group_size and maximum space complexity specified by sc_target, Then finds the contraction order inside each group with the greedy search algorithm. Other arguments are\n\nsc_target is the target space complexity, defined as log2(number of elements in the largest tensor),\nimbalances is a KaHyPar parameter that controls the group sizes in hierarchical bipartition,\nmax_group_size is the maximum size that allowed to used greedy search,\ngreedy_config is a greedy optimizer.\n\nReferences\n\nHyper-optimized tensor network contraction\nSimulating the Sycamore quantum supremacy circuits\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.MergeVectors","page":"References","title":"OMEinsumContractionOrders.MergeVectors","text":"MergeVectors <: CodeSimplifier\nMergeVectors()\n\nContraction code simplifier (in order to reduce the time of calling optimizers) that merges vectors to closest tensors.\n\n\n\n\n\n","category":"type"},{"location":"ref/#OMEinsumContractionOrders.MergeGreedy","page":"References","title":"OMEinsumContractionOrders.MergeGreedy","text":"MergeGreedy <: CodeSimplifier\nMergeGreedy(; threshhold=-1e-12)\n\nContraction code simplifier (in order to reduce the time of calling optimizers) that merges tensors greedily if the space complexity of merged tensors is reduced (difference smaller than the threshhold).\n\n\n\n\n\n","category":"type"},{"location":"ref/#Others","page":"References","title":"Others","text":"","category":"section"},{"location":"ref/#Graph","page":"References","title":"Graph","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"Except the SimpleGraph defined in Graphs, GenericTensorNetworks also defines the following graph types and functions.","category":"page"},{"location":"ref/","page":"References","title":"References","text":"HyperGraph\nUnitDiskGraph\n\nshow_graph\nshow_configs\nshow_einsum\nshow_landscape\nGraphDisplayConfig\nAbstractLayout\nSpringLayout\nStressLayout\nSpectralLayout\nLayered\nLayeredSpringLayout\nLayeredStressLayout\nrender_locs\n\ndiagonal_coupled_graph\nsquare_lattice_graph\nline_graph\n\nrandom_diagonal_coupled_graph\nrandom_square_lattice_graph","category":"page"},{"location":"ref/#ProblemReductions.HyperGraph","page":"References","title":"ProblemReductions.HyperGraph","text":"struct HyperGraph <: Graphs.AbstractGraph{Int64}\n\nA hypergraph is a generalization of a graph in which an edge can connect any number of vertices.\n\nFields\n\nn::Int: the number of vertices\nedges::Vector{Vector{Int}}: a vector of vectors of integers, where each vector represents a hyperedge connecting the vertices with the corresponding indices.\n\n\n\n\n\n","category":"type"},{"location":"ref/#ProblemReductions.UnitDiskGraph","page":"References","title":"ProblemReductions.UnitDiskGraph","text":"struct UnitDiskGraph{D, T} <: Graphs.AbstractGraph{Int64}\n\nA unit disk graph is a graph in which the vertices are points in a plane and two vertices are connected by an edge if and only if the Euclidean distance between them is at most a given radius.\n\nFields\n\nlocations::Vector{NTuple{D, T}}: the locations of the vertices\nradius::Float64: the radius of the unit disk\n\n\n\n\n\n","category":"type"},{"location":"ref/#LuxorGraphPlot.show_graph","page":"References","title":"LuxorGraphPlot.show_graph","text":"show_graph([f, ]graph::AbstractGraph;\n    kwargs...\n    )\n\nShow a graph in VSCode, Pluto or Jupyter notebook, or save it to a file.\n\nPositional arguments\n\nf is a function that returns extra Luxor plotting statements.\ngraph is a graph instance.\nlocs is a vector of tuples for specifying the vertex locations, or a AbstractLayout instance.\n\nKeyword arguments\n\nconfig is a GraphDisplayConfig instance.\nvertex_colors is a vector of color strings for specifying vertex fill colors.\nvertex_sizes is a vector of real numbers for specifying vertex sizes.\nvertex_shapes is a vector of strings for specifying vertex shapes, the string should be \"circle\" or \"box\".\nvertex_stroke_colors is a vector of color strings for specifying vertex stroke colors.\nvertex_text_colors is a vector of color strings for specifying vertex text colors.\nedge_colors is a vector of color strings for specifying edge colors.\ntexts is a vector of strings for labeling vertices.\n\npadding_left::Int = 10, the padding on the left side of the drawing\npadding_right::Int = 10, the padding on the right side of the drawing\npadding_top::Int = 10, the padding on the top side of the drawing\npadding_bottom::Int = 10, the padding on the bottom side of the drawing\nformat is the output format, which can be :svg, :png or :pdf.\nfilename is a string as the output filename.\n\nExample\n\njulia> using Graphs, LuxorGraphPlot\n\njulia> show_graph(smallgraph(:petersen); format=:png, vertex_colors=rand([\"blue\", \"red\"], 10));\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.show_configs","page":"References","title":"GenericTensorNetworks.show_configs","text":"show_configs(gp::ConstraintSatisfactionProblem, locs, configs::AbstractMatrix; kwargs...)\nshow_configs(graph::SimpleGraph, locs, configs::AbstractMatrix; num_flavors=2, kwargs...)\n\nShow a gallery of configurations on a graph.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.show_einsum","page":"References","title":"GenericTensorNetworks.show_einsum","text":"show_einsum(ein::AbstractEinsum;\n    tensor_locs=nothing,\n    label_locs=nothing,  # dict\n    spring::Bool=true,\n    optimal_distance=25.0,\n\n    tensor_size=15,\n    tensor_color=\"black\",\n    tensor_text_color=\"white\",\n    annotate_tensors=false,\n\n    label_size=7,\n    label_color=\"black\",\n    open_label_color=\"black\",\n    annotate_labels=true,\n    kwargs...\n    )\n\nPositional arguments\n\nein is an Einsum contraction code (provided by package OMEinsum).\n\nKeyword arguments\n\nlocs is a tuple of tensor_locs (vector) and label_locs (dict).\nspring is switch to use spring method to optimize the location.\noptimal_distance is a optimal distance parameter for spring optimizer.\ntensor_color is a string to specify the color of tensor nodes.\ntensor_size is a real number to specify the size of tensor nodes.\ntensor_text_color is a color strings to specify tensor text color.\nannotate_tensors is a boolean switch for annotate different tensors by integers.\nlabel_size is a real number to specify label text node size.\nlabel_color is a color strings to specify label text color.\nopen_label_color is a color strings to specify open label text color.\nannotate_labels is a boolean switch for annotate different labels.\nformat is the output format, which can be :svg, :png or :pdf.\nfilename is a string as the output filename.\n\nfontsize::Float64 = 12.0, the font size\nfontface::String = \"\", the font face, leave empty to follow system\nvertex_text_color = \"black\", the default text color\nvertex_stroke_color = \"black\", the default stroke color for vertices\nvertex_color = \"transparent\", the default default fill color for vertices\nvertex_size::Float64 = 10.0, the default vertex size\nvertex_shape::Symbol = :circle, the default vertex shape, which can be :circle, :box or :dot\nvertex_line_width::Float64 = 1, the default vertex stroke line width\nvertex_line_style::String = \"solid\", the line style of vertex stroke, which can be one of [\"solid\", \"dotted\", \"dot\", \"dotdashed\", \"longdashed\", \"shortdashed\", \"dash\", \"dashed\", \"dotdotdashed\", \"dotdotdotdashed\"]\nedge_color = \"black\", the default edge color\nedge_line_width::Float64 = 1, the default line width\nedge_style::String = \"solid\", the line style of edges, which can be one of [\"solid\", \"dotted\", \"dot\", \"dotdashed\", \"longdashed\", \"shortdashed\", \"dash\", \"dashed\", \"dotdotdashed\", \"dotdotdotdashed\"]\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.show_landscape","page":"References","title":"GenericTensorNetworks.show_landscape","text":"show_landscape(is_neighbor, configurations::TruncatedPoly;\n    layer_distance=200,\n    config=GraphDisplayConfig(; edge_color=\"gray\", vertex_stroke_color=\"transparent\", vertex_size=5),\n    layout_method=:spring,\n    optimal_distance=30.0,\n    colors=fill(\"green\", K),\n    kwargs...)\n\nShow the energy landscape of configurations.\n\nArguments\n\nis_neighbor: a function to determine if two configurations are neighbors.\nconfigurations: a TruncatedPoly object, which is the default output of the solve function with ConfigsMax property as the argument.\n\nKeyword arguments\n\nlayer_distance: the distance between layers.\nconfig: a LuxorGraphPlot.GraphDisplayConfig object.\nlayout_method: the layout method, either :spring, :stress or :spectral\noptimal_distance: the optimal distance for the layout.\ncolors: a vector of colors for each layer.\nkwargs...: other keyword arguments passed to show_graph.\n\n\n\n\n\n","category":"function"},{"location":"ref/#LuxorGraphPlot.GraphDisplayConfig","page":"References","title":"LuxorGraphPlot.GraphDisplayConfig","text":"GraphDisplayConfig\n\nThe configuration for graph display.\n\nKeyword arguments\n\nlocs is a vector of tuples for specifying the vertex locations.\nedges is a vector of tuples for specifying the edges.\nfontsize::Float64 = 12.0, the font size\nfontface::String = \"\", the font face, leave empty to follow system\nvertex_text_color = \"black\", the default text color\nvertex_stroke_color = \"black\", the default stroke color for vertices\nvertex_color = \"transparent\", the default default fill color for vertices\nvertex_size::Float64 = 10.0, the default vertex size\nvertex_shape::Symbol = :circle, the default vertex shape, which can be :circle, :box or :dot\nvertex_line_width::Float64 = 1, the default vertex stroke line width\nvertex_line_style::String = \"solid\", the line style of vertex stroke, which can be one of [\"solid\", \"dotted\", \"dot\", \"dotdashed\", \"longdashed\", \"shortdashed\", \"dash\", \"dashed\", \"dotdotdashed\", \"dotdotdotdashed\"]\nedge_color = \"black\", the default edge color\nedge_line_width::Float64 = 1, the default line width\nedge_style::String = \"solid\", the line style of edges, which can be one of [\"solid\", \"dotted\", \"dot\", \"dotdashed\", \"longdashed\", \"shortdashed\", \"dash\", \"dashed\", \"dotdotdashed\", \"dotdotdotdashed\"]\n\n\n\n\n\n","category":"type"},{"location":"ref/#LuxorGraphPlot.Layouts.AbstractLayout","page":"References","title":"LuxorGraphPlot.Layouts.AbstractLayout","text":"AbstractLayout\n\nAbstract type for layout algorithms.\n\n\n\n\n\n","category":"type"},{"location":"ref/#LuxorGraphPlot.Layouts.SpringLayout","page":"References","title":"LuxorGraphPlot.Layouts.SpringLayout","text":"SpringLayout <: AbstractLayout\n\nA layout algorithm based on a spring model.\n\nFields\n\noptimal_distance::Float64: the optimal distance between vertices\nmaxiter::Int: the maximum number of iterations\nα0::Float64: the initial moving speed\nmeta::Dict{Symbol, Any}: graph dependent meta information, including\ninitial_locs: initial vertex locations\nmask: boolean mask for which vertices to relocate\n\n\n\n\n\n","category":"type"},{"location":"ref/#LuxorGraphPlot.Layouts.StressLayout","page":"References","title":"LuxorGraphPlot.Layouts.StressLayout","text":"StressLayout <: AbstractLayout\n\nA layout algorithm based on stress majorization.\n\nFields\n\noptimal_distance::Float64: the optimal distance between vertices\nmaxiter::Int: the maximum number of iterations\nrtol::Float64: the absolute tolerance\ninitial_locs: initial vertex locations\nmask: boolean mask for which vertices to relocate\nmeta::Dict{Symbol, Any}: graph dependent meta information, including\ninitial_locs: initial vertex locations\nmask: boolean mask for which vertices to relocate\n\n\n\n\n\n","category":"type"},{"location":"ref/#LuxorGraphPlot.Layouts.SpectralLayout","page":"References","title":"LuxorGraphPlot.Layouts.SpectralLayout","text":"SpectralLayout <: AbstractLayout\n\nA layout algorithm based on spectral graph theory.\n\nFields\n\noptimal_distance::Float64: the optimal distance between vertices\ndimension::Int: the number of dimensions\n\n\n\n\n\n","category":"type"},{"location":"ref/#LuxorGraphPlot.Layouts.Layered","page":"References","title":"LuxorGraphPlot.Layouts.Layered","text":"Layered <: AbstractLayout\n\nLayered version of a parent layout algorithm.\n\nFields\n\nparent::LT: the parent layout algorithm\nzlocs::Vector{T}: the z-axis locations\naspect_ratio::Float64: the aspect ratio of the z-axis\n\n\n\n\n\n","category":"type"},{"location":"ref/#LuxorGraphPlot.Layouts.LayeredSpringLayout","page":"References","title":"LuxorGraphPlot.Layouts.LayeredSpringLayout","text":"LayeredSpringLayout(; zlocs, optimal_distance, aspect_ration=0.2)\n\nCreate a layered spring layout.\n\nKeyword Arguments\n\nzlocs: the z-axis locations\noptimal_distance::Float64: the optimal distance between vertices\naspect_ration::Float64: the aspect ratio of the z-axis\nα0::Float64: the initial moving speed\nmaxiter::Int: the maximum number of iterations\n\n\n\n\n\n","category":"function"},{"location":"ref/#LuxorGraphPlot.Layouts.LayeredStressLayout","page":"References","title":"LuxorGraphPlot.Layouts.LayeredStressLayout","text":"LayeredStressLayout(; zlocs, optimal_distance, aspect_ration=0.2)\n\nCreate a layered stress layout.\n\nKeyword Arguments\n\nzlocs: the z-axis locations\noptimal_distance::Float64: the optimal distance between vertices\naspect_ration::Float64: the aspect ratio of the z-axis\nmaxiter::Int: the maximum number of iterations\nrtol::Float64: the absolute tolerance\n\n\n\n\n\n","category":"function"},{"location":"ref/#LuxorGraphPlot.Layouts.render_locs","page":"References","title":"LuxorGraphPlot.Layouts.render_locs","text":"render_locs(graph, layout::Layout)\n\nRender the vertex locations for a graph from an AbstractLayout instance.\n\nArguments\n\ngraph::AbstractGraph: the graph to render\nlayout::AbstractLayout: the layout algorithm\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.diagonal_coupled_graph","page":"References","title":"GenericTensorNetworks.diagonal_coupled_graph","text":"diagonal_coupled_graph(mask::AbstractMatrix{Bool})\n\nCreate a masked diagonal coupled square lattice graph from a specified mask.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.square_lattice_graph","page":"References","title":"GenericTensorNetworks.square_lattice_graph","text":"square_lattice_graph(mask::AbstractMatrix{Bool})\n\nCreate a masked square lattice graph.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.line_graph","page":"References","title":"GenericTensorNetworks.line_graph","text":"line_graph(g::SimpleGraph)\n\nReturns the line graph of g. The line graph is generated by mapping an edge to a vertex and two edges sharing a common vertex will be connected.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.random_diagonal_coupled_graph","page":"References","title":"GenericTensorNetworks.random_diagonal_coupled_graph","text":"random_diagonal_coupled_graph(m::Int, n::Int, ρ::Real)\n\nCreate a mtimes n random masked diagonal coupled square lattice graph,  with number of vertices equal to lfloor m times ntimes rho rceil.\n\n\n\n\n\n","category":"function"},{"location":"ref/#GenericTensorNetworks.random_square_lattice_graph","page":"References","title":"GenericTensorNetworks.random_square_lattice_graph","text":"random_square_lattice_graph(m::Int, n::Int, ρ::Real)\n\nCreate a random masked square lattice graph, with number of vertices fixed to lfloor mnrho rceil.\n\n\n\n\n\n","category":"function"},{"location":"ref/#Multiprocessing","page":"References","title":"Multiprocessing","text":"","category":"section"},{"location":"ref/","page":"References","title":"References","text":"GenericTensorNetworks.SimpleMultiprocessing.multiprocess_run","category":"page"},{"location":"ref/#GenericTensorNetworks.SimpleMultiprocessing.multiprocess_run","page":"References","title":"GenericTensorNetworks.SimpleMultiprocessing.multiprocess_run","text":"multiprocess_run(func, inputs::AbstractVector)\n\nExecute function func on inputs with multiple processing.\n\nExample\n\nSuppose we have a file run.jl with the following contents\n\nusing GenericTensorNetworks.SimpleMultiprocessing\n\nresults = multiprocess_run(x->x^2, randn(8))\n\nIn an terminal, you may run the script with 4 processes by typing\n\n$ julia -p4 run.jl\n      From worker 2:\t[ Info: running argument -0.17544008350172655 on device 2\n      From worker 5:\t[ Info: running argument 0.34578117779452555 on device 5\n      From worker 3:\t[ Info: running argument 2.0312551239727705 on device 3\n      From worker 4:\t[ Info: running argument -0.7319353419291961 on device 4\n      From worker 2:\t[ Info: running argument 0.013132180639054629 on device 2\n      From worker 3:\t[ Info: running argument 0.9960101782201602 on device 3\n      From worker 4:\t[ Info: running argument -0.5613942832743966 on device 4\n      From worker 5:\t[ Info: running argument 0.39460402723831134 on device 5\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GenericTensorNetworks","category":"page"},{"location":"#GenericTensorNetworks","page":"Home","title":"GenericTensorNetworks","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GenericTensorNetworks is a high-performance package that uses tensor network algorithms to solve challenging combinatorial optimization problems. This approach allows us to efficiently compute various solution space properties that would be intractable with traditional methods.","category":"page"},{"location":"#Key-Capabilities","page":"Home","title":"Key Capabilities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Our package can compute a wide range of solution space properties:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Maximum and minimum solution sizes\nSolution counts at specific sizes\nComplete enumeration of solutions\nStatistical sampling from the solution space","category":"page"},{"location":"#Supported-Problem-Classes","page":"Home","title":"Supported Problem Classes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GenericTensorNetworks can solve many important combinatorial problems:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Independent Set Problem\nMaximal Independent Set Problem\nSpin-Glass Problem\nMaximum Cut Problem\nVertex Matching Problem\nBinary Paint Shop Problem\nGraph Coloring Problem\nDominating Set Problem\nBoolean Satisfiability Problem\nSet Packing Problem\nSet Covering Problem","category":"page"},{"location":"#Scientific-Background","page":"Home","title":"Scientific Background","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For the theoretical foundation and algorithmic details, please refer to our paper: \"Computing properties of independent sets by generic programming tensor networks\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you find our package useful in your research, please cite our work using the references in CITATION.bib.","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Installation instructions are available in our README.","category":"page"},{"location":"#Basic-Example","page":"Home","title":"Basic Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here's a simple example that computes the independence polynomial of a random regular graph:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GenericTensorNetworks, Graphs  # Add CUDA for GPU acceleration\n\n# Create and solve a problem instance\nresult = solve(\n    GenericTensorNetwork(\n        IndependentSet(\n            Graphs.random_regular_graph(20, 3),  # Graph to analyze\n            UnitWeight(20)                       # Uniform vertex weights\n        );\n        optimizer = TreeSA(),                    # Contraction order optimizer\n        openvertices = (),                       # No open vertices\n        fixedvertices = Dict()                   # No fixed vertices\n    ),\n    GraphPolynomial();                           # Property to compute\n    usecuda = false                              # Use CPU (set true for GPU)\n)","category":"page"},{"location":"#Understanding-the-API","page":"Home","title":"Understanding the API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main function solve takes three components:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Problem Instance: Created with GenericTensorNetwork, which wraps problem types like IndependentSet\nThe first argument defines the problem (graph and weights)\nOptional arguments control the tensor network construction:\noptimizer: Algorithm for finding efficient contraction orders\nopenvertices: Degrees of freedom to leave uncontracted\nfixedvertices: Variables with fixed assignments\nProperty to Compute: Such as GraphPolynomial, SizeMax, or ConfigsAll\nComputation Options: Like usecuda to enable GPU acceleration","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note: The first execution will be slower due to Julia's just-in-time compilation. Subsequent runs will be much faster.","category":"page"},{"location":"#API-Structure","page":"Home","title":"API Structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following diagram illustrates the possible combinations of inputs:","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div align=center>\n<img src=\"assets/fig7.svg\" width=\"75%\"/>\n</div>","category":"page"},{"location":"","page":"Home","title":"Home","text":"⠀","category":"page"},{"location":"","page":"Home","title":"Home","text":"Functions in the Graph box are primarily from the Graphs package, while the rest are defined in GenericTensorNetworks.","category":"page"},{"location":"#Next-Steps","page":"Home","title":"Next Steps","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For a deeper understanding, we recommend starting with the Independent Set Problem example, which demonstrates the core functionality of the package. ```","category":"page"}]
}
