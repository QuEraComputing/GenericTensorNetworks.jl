<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Performance Tips · GenericTensorNetworks.jl</title><meta name="title" content="Performance Tips · GenericTensorNetworks.jl"/><meta property="og:title" content="Performance Tips · GenericTensorNetworks.jl"/><meta property="twitter:title" content="Performance Tips · GenericTensorNetworks.jl"/><meta name="description" content="Documentation for GenericTensorNetworks.jl."/><meta property="og:description" content="Documentation for GenericTensorNetworks.jl."/><meta property="twitter:description" content="Documentation for GenericTensorNetworks.jl."/><meta property="og:url" content="https://QuEraComputing.github.io/GenericTensorNetworks.jl/performancetips/"/><meta property="twitter:url" content="https://QuEraComputing.github.io/GenericTensorNetworks.jl/performancetips/"/><link rel="canonical" href="https://QuEraComputing.github.io/GenericTensorNetworks.jl/performancetips/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GenericTensorNetworks.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Problems</span><ul><li><a class="tocitem" href="../generated/IndependentSet/">Independent set problem</a></li><li><a class="tocitem" href="../generated/MaximalIS/">Maximal independent set problem</a></li><li><a class="tocitem" href="../generated/SpinGlass/">Spin glass problem</a></li><li><a class="tocitem" href="../generated/MaxCut/">Cutting problem</a></li><li><a class="tocitem" href="../generated/Matching/">Vertex matching problem</a></li><li><a class="tocitem" href="../generated/PaintShop/">Binary paint shop problem</a></li><li><a class="tocitem" href="../generated/Coloring/">Coloring problem</a></li><li><a class="tocitem" href="../generated/DominatingSet/">Dominating set problem</a></li><li><a class="tocitem" href="../generated/Satisfiability/">Satisfiability problem</a></li><li><a class="tocitem" href="../generated/SetCovering/">Set covering problem</a></li><li><a class="tocitem" href="../generated/SetPacking/">Set packing problem</a></li></ul></li><li><span class="tocitem">Topics</span><ul><li><a class="tocitem" href="../gist/">Gist</a></li><li><a class="tocitem" href="../generated/saveload/">Save and load solutions</a></li><li><a class="tocitem" href="../sumproduct/">Sum product tree representation</a></li><li><a class="tocitem" href="../generated/weighted/">Weighted problems</a></li><li><a class="tocitem" href="../generated/open/">Open and fixed degrees of freedom</a></li></ul></li><li class="is-active"><a class="tocitem" href>Performance Tips</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#1.-Optimizing-Contraction-Orders"><span>1. Optimizing Contraction Orders</span></a></li><li><a class="tocitem" href="#2.-Slicing-Technique-for-Large-Problems"><span>2. Slicing Technique for Large Problems</span></a></li><li><a class="tocitem" href="#3.-Accelerating-Tropical-Number-Operations"><span>3. Accelerating Tropical Number Operations</span></a></li><li><a class="tocitem" href="#4.-Multiprocessing-for-Parallel-Execution"><span>4. Multiprocessing for Parallel Execution</span></a></li><li><a class="tocitem" href="#5.-GPU-Acceleration"><span>5. GPU Acceleration</span></a></li><li><a class="tocitem" href="#6.-Performance-Benchmarks"><span>6. Performance Benchmarks</span></a></li></ul></li><li><a class="tocitem" href="../ref/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Performance Tips</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Performance Tips</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuEraComputing/GenericTensorNetworks.jl/blob/master/docs/src/performancetips.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Performance-Tips"><a class="docs-heading-anchor" href="#Performance-Tips">Performance Tips</a><a id="Performance-Tips-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Tips" title="Permalink"></a></h1><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>This guide provides strategies to optimize performance when using GenericTensorNetworks.jl.  We&#39;ll cover:</p><ol><li>Optimizing contraction orders</li><li>Using slicing techniques for large problems</li><li>Accelerating computations with specialized GEMM operations</li><li>Leveraging multiprocessing for parallel execution</li><li>Utilizing GPU acceleration</li><li>Performance benchmarks and comparisons</li></ol><h2 id="1.-Optimizing-Contraction-Orders"><a class="docs-heading-anchor" href="#1.-Optimizing-Contraction-Orders">1. Optimizing Contraction Orders</a><a id="1.-Optimizing-Contraction-Orders-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Optimizing-Contraction-Orders" title="Permalink"></a></h2><p>Let&#39;s examine how to optimize contraction orders using the independent set problem on 3-regular graphs:</p><pre><code class="language-julia hljs">using GenericTensorNetworks, Graphs, Random
graph = random_regular_graph(120, 3)
iset = IndependentSet(graph)
problem = GenericTensorNetwork(iset; optimizer=TreeSA(
    sc_target=20, sc_weight=1.0, rw_weight=3.0, ntrials=10, βs=0.01:0.1:15.0, niters=20))</code></pre><p>The <code>GenericTensorNetwork</code> constructor maps a problem to a tensor network with an optimized contraction order. The <code>optimizer</code> parameter specifies the algorithm to use:</p><h3 id="Available-Optimizers:"><a class="docs-heading-anchor" href="#Available-Optimizers:">Available Optimizers:</a><a id="Available-Optimizers:-1"></a><a class="docs-heading-anchor-permalink" href="#Available-Optimizers:" title="Permalink"></a></h3><ul><li><strong>TreeSA</strong> (used above): A simulated annealing-based optimizer that often finds the smallest time/space complexity and supports slicing. See <a href="https://arxiv.org/abs/2108.05665">arXiv: 2108.05665</a> for details.</li><li><strong>GreedyMethod</strong> (default): Fastest search but typically yields higher contraction complexity</li><li><strong>KaHyParBipartite</strong>: Uses hypergraph partitioning</li><li><strong>SABipartite</strong>: Simulated annealing on bipartite representation</li></ul><p>The returned <code>problem</code> object contains a <code>code</code> field specifying the tensor network with optimized contraction order. For an independent set problem, the optimal contraction complexity is approximately 2^(tw(G)), where tw(G) is the <a href="https://en.wikipedia.org/wiki/Treewidth">tree-width</a> of graph G.</p><h3 id="Analyzing-Contraction-Complexity"><a class="docs-heading-anchor" href="#Analyzing-Contraction-Complexity">Analyzing Contraction Complexity</a><a id="Analyzing-Contraction-Complexity-1"></a><a class="docs-heading-anchor-permalink" href="#Analyzing-Contraction-Complexity" title="Permalink"></a></h3><p>You can check the time, space, and read-write complexity with:</p><pre><code class="language-julia hljs">contraction_complexity(problem)</code></pre><p>This returns log2 values of:</p><ol><li>Number of multiplications</li><li>Number of elements in the largest tensor during contraction</li><li>Number of read-write operations to tensor elements</li></ol><p>In our example, the computation requires approximately 2^21.9 multiplications, 2^20 read-write operations, and the largest tensor contains 2^17 elements.</p><h3 id="Memory-Requirements"><a class="docs-heading-anchor" href="#Memory-Requirements">Memory Requirements</a><a id="Memory-Requirements-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-Requirements" title="Permalink"></a></h3><p>Different element types have different memory footprints:</p><pre><code class="language-julia hljs">sizeof(TropicalF64)
sizeof(TropicalF32)
sizeof(StaticBitVector{200,4})
sizeof(TruncatedPoly{5,Float64,Float64})</code></pre><p>For a more accurate estimate of peak memory usage in bytes, use:</p><pre><code class="language-julia hljs">estimate_memory(problem, GraphPolynomial(; method=:finitefield))
estimate_memory(problem, GraphPolynomial(; method=:polynomial))</code></pre><p>The finite field approach requires only 298 KB, while using the <code>Polynomial</code> type requires 71 MB.</p><blockquote><p><strong>Note</strong>: </p><ul><li>Actual runtime memory can be several times larger than the maximum tensor size</li><li>For mutable element types like <code>ConfigEnumerator</code>, memory estimation functions may not accurately measure actual usage</li></ul></blockquote><h2 id="2.-Slicing-Technique-for-Large-Problems"><a class="docs-heading-anchor" href="#2.-Slicing-Technique-for-Large-Problems">2. Slicing Technique for Large Problems</a><a id="2.-Slicing-Technique-for-Large-Problems-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Slicing-Technique-for-Large-Problems" title="Permalink"></a></h2><p>For large-scale applications, you can slice over certain degrees of freedom to reduce space complexity. This approach loops and accumulates over selected degrees of freedom, resulting in smaller tensor networks inside the loop.</p><p>In the <code>TreeSA</code> optimizer, set <code>nslices</code> to a value greater than zero:</p><pre><code class="language-julia hljs"># Without slicing
problem = GenericTensorNetwork(iset; optimizer=TreeSA(βs=0.01:0.1:25.0, ntrials=10, niters=10))
contraction_complexity(problem)

# With slicing over 5 degrees of freedom
problem = GenericTensorNetwork(iset; optimizer=TreeSA(βs=0.01:0.1:25.0, ntrials=10, niters=10, nslices=5))
contraction_complexity(problem)</code></pre><p>In this example, slicing over 5 degrees of freedom reduces space complexity by a factor of 32 (2^5), while increasing computation time by less than a factor of 2.</p><h2 id="3.-Accelerating-Tropical-Number-Operations"><a class="docs-heading-anchor" href="#3.-Accelerating-Tropical-Number-Operations">3. Accelerating Tropical Number Operations</a><a id="3.-Accelerating-Tropical-Number-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#3.-Accelerating-Tropical-Number-Operations" title="Permalink"></a></h2><p>You can significantly speed up Tropical number matrix multiplication when computing <code>SizeMax()</code> by using specialized GEMM routines from <a href="https://github.com/TensorBFS/TropicalGEMM.jl/">TropicalGEMM</a>:</p><pre><code class="language-julia hljs">using BenchmarkTools

# Without TropicalGEMM
@btime solve(problem, SizeMax())
# 91.630 ms (19203 allocations: 23.72 MiB)
# 0-dimensional Array{TropicalF64, 0}:
# 53.0ₜ

# With TropicalGEMM
using TropicalGEMM
@btime solve(problem, SizeMax())
# 8.960 ms (18532 allocations: 17.01 MiB)
# 0-dimensional Array{TropicalF64, 0}:
# 53.0ₜ</code></pre><p>TropicalGEMM overrides the <code>LinearAlgebra.mul!</code> interface and takes effect immediately upon loading. This example shows more than 10x speedup on a single-threaded CPU. Performance can be further improved with <a href="https://docs.julialang.org/en/v1/manual/multi-threading/">Julia multi-threading</a>.</p><h2 id="4.-Multiprocessing-for-Parallel-Execution"><a class="docs-heading-anchor" href="#4.-Multiprocessing-for-Parallel-Execution">4. Multiprocessing for Parallel Execution</a><a id="4.-Multiprocessing-for-Parallel-Execution-1"></a><a class="docs-heading-anchor-permalink" href="#4.-Multiprocessing-for-Parallel-Execution" title="Permalink"></a></h2><p>The <code>GenericTensorNetworks.SimpleMultiprocessing</code> submodule provides a convenient <code>multiprocess_run</code> function for parallel jobs. Here&#39;s how to find independence polynomials for multiple graphs using 4 processes:</p><pre><code class="language-julia hljs"># File: run.jl
using Distributed, GenericTensorNetworks.SimpleMultiprocessing
using Random, GenericTensorNetworks  # to avoid multi-precompilation
@everywhere using Random, GenericTensorNetworks

results = multiprocess_run(collect(1:10)) do seed
    Random.seed!(seed)
    n = 10
    @info &quot;Graph size $n x $n, seed= $seed&quot;
    g = random_diagonal_coupled_graph(n, n, 0.8)
    gp = GenericTensorNetwork(IndependentSet(g); optimizer=TreeSA())
    res = solve(gp, GraphPolynomial())[]
    return res
end

println(results)</code></pre><p>Run this script with:</p><pre><code class="language-bash hljs">$ julia -p4 run.jl</code></pre><h2 id="5.-GPU-Acceleration"><a class="docs-heading-anchor" href="#5.-GPU-Acceleration">5. GPU Acceleration</a><a id="5.-GPU-Acceleration-1"></a><a class="docs-heading-anchor-permalink" href="#5.-GPU-Acceleration" title="Permalink"></a></h2><p>To run computations on a GPU, simply load CUDA and set the <code>usecuda</code> parameter:</p><pre><code class="language-julia hljs">using CUDA
# [ Info: OMEinsum loaded the CUDA module successfully

solve(problem, SizeMax(), usecuda=true)
# 0-dimensional CuArray{TropicalF64, 0, CUDA.Mem.DeviceBuffer}:
# 53.0ₜ</code></pre><h3 id="GPU-Compatible-Solution-Properties:"><a class="docs-heading-anchor" href="#GPU-Compatible-Solution-Properties:">GPU-Compatible Solution Properties:</a><a id="GPU-Compatible-Solution-Properties:-1"></a><a class="docs-heading-anchor-permalink" href="#GPU-Compatible-Solution-Properties:" title="Permalink"></a></h3><ul><li><code>SizeMax</code> and <code>SizeMin</code></li><li><code>CountingAll</code></li><li><code>CountingMax</code> and <code>CountingMin</code></li><li><code>GraphPolynomial</code></li><li><code>SingleConfigMax</code> and <code>SingleConfigMin</code></li></ul><h2 id="6.-Performance-Benchmarks"><a class="docs-heading-anchor" href="#6.-Performance-Benchmarks">6. Performance Benchmarks</a><a id="6.-Performance-Benchmarks-1"></a><a class="docs-heading-anchor-permalink" href="#6.-Performance-Benchmarks" title="Permalink"></a></h2><p>We benchmarked performance on an Intel Xeon CPU E5-2686 v4 @ 2.30GHz (single thread) and a Tesla V100-SXM2 16GB GPU. The benchmark code is available in <a href="https://github.com/GiggleLiu/NoteOnTropicalMIS/tree/master/benchmarks">our paper repository</a>.</p><h3 id="Independent-Set-Problem-Benchmarks"><a class="docs-heading-anchor" href="#Independent-Set-Problem-Benchmarks">Independent Set Problem Benchmarks</a><a id="Independent-Set-Problem-Benchmarks-1"></a><a class="docs-heading-anchor-permalink" href="#Independent-Set-Problem-Benchmarks" title="Permalink"></a></h3><p><img src="../assets/fig1.png" alt="benchmark-independent-set"/></p><p>These benchmarks show computation time for various independent set properties on random three-regular graphs:</p><p><strong>Figure (a)</strong>: Time and space complexity vs. number of vertices</p><ul><li>Slicing was used for graphs with space complexity &gt; 2^27 (above yellow line)</li></ul><p><strong>Figure (b)</strong>: Computation time for:</p><ul><li>MIS size calculation</li><li>Counting all independent sets</li><li>Counting MISs</li><li>Counting sets of size α(G) and α(G)-1</li><li>Finding 100 largest set sizes</li></ul><p><strong>Figure (c)</strong>: Computation time for independence polynomials:</p><ul><li>Fourier transformation method is fastest but may have round-off errors</li><li>Finite field (GF(p)) approach has no round-off errors and works on GPU</li></ul><p><strong>Figure (d)</strong>: Configuration enumeration time:</p><ul><li>Bounding techniques improve performance by &gt;10x for MIS enumeration</li><li>Bounding also significantly reduces memory usage</li></ul><h3 id="Maximal-Independent-Set-Benchmarks"><a class="docs-heading-anchor" href="#Maximal-Independent-Set-Benchmarks">Maximal Independent Set Benchmarks</a><a id="Maximal-Independent-Set-Benchmarks-1"></a><a class="docs-heading-anchor-permalink" href="#Maximal-Independent-Set-Benchmarks" title="Permalink"></a></h3><p><img src="../assets/fig2.png" alt="benchmark-maximal-independent-set"/></p><p><strong>Figure (a)</strong>: Time and space complexity for maximal IS problems</p><ul><li>Typically higher than for standard independent set problems</li></ul><p><strong>Figure (b)</strong>: Wall clock time comparison:</p><ul><li>Counting maximal ISs is much more efficient than enumeration</li><li>Our tensor network approach is slightly faster than Bron-Kerbosch for enumerating maximal ISs</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../generated/open/">« Open and fixed degrees of freedom</a><a class="docs-footer-nextpage" href="../ref/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Friday 21 March 2025 07:46">Friday 21 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
